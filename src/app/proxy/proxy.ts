//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpContext } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class BanksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(bankName: string, httpContext?: HttpContext): Observable<Bank> {
        let url_ = this.baseUrl + "/api/v1/banks?";
        if (bankName === undefined || bankName === null)
            throw new Error("The parameter 'bankName' must be defined and cannot be null.");
        else
            url_ += "bankName=" + encodeURIComponent("" + bankName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Bank>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Bank>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Bank> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bank.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBanks(pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<Bank[]> {
        let url_ = this.baseUrl + "/api/v1/banks?";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBanks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBanks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Bank[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Bank[]>;
        }));
    }

    protected processGetBanks(response: HttpResponseBase): Observable<Bank[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Bank.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(bankId: number, httpContext?: HttpContext): Observable<Bank> {
        let url_ = this.baseUrl + "/api/v1/banks/{bankId}";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined.");
        url_ = url_.replace("{bankId}", encodeURIComponent("" + bankId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Bank>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Bank>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Bank> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bank.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(bankId: number, bankName: string, httpContext?: HttpContext): Observable<Bank> {
        let url_ = this.baseUrl + "/api/v1/banks/{bankId}?";
        if (bankId === undefined || bankId === null)
            throw new Error("The parameter 'bankId' must be defined.");
        url_ = url_.replace("{bankId}", encodeURIComponent("" + bankId));
        if (bankName === undefined || bankName === null)
            throw new Error("The parameter 'bankName' must be defined and cannot be null.");
        else
            url_ += "bankName=" + encodeURIComponent("" + bankName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Bank>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Bank>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Bank> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Bank.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BranchesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(branchId: number, branchName: string, description?: string | null | undefined, httpContext?: HttpContext): Observable<BranchLight> {
        let url_ = this.baseUrl + "/api/v1/branches?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined and cannot be null.");
        else
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&";
        if (branchName === undefined || branchName === null)
            throw new Error("The parameter 'branchName' must be defined and cannot be null.");
        else
            url_ += "branchName=" + encodeURIComponent("" + branchName) + "&";
        if (description !== undefined && description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranchLight>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranchLight>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BranchLight> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BranchLight.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetUserPin(branchId: number, merchantId: number, userId: string, pin: string, httpContext?: HttpContext): Observable<UserPin> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/users/{userId}/pin?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined and cannot be null.");
        else
            url_ += "merchantId=" + encodeURIComponent("" + merchantId) + "&";
        if (pin === undefined || pin === null)
            throw new Error("The parameter 'pin' must be defined and cannot be null.");
        else
            url_ += "pin=" + encodeURIComponent("" + pin) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserPin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserPin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserPin>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserPin>;
        }));
    }

    protected processResetUserPin(response: HttpResponseBase): Observable<UserPin> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserPin.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubBranches(branchId: number, httpContext?: HttpContext): Observable<Branch[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sub-branches";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubBranches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubBranches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Branch[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Branch[]>;
        }));
    }

    protected processGetSubBranches(response: HttpResponseBase): Observable<Branch[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Branch.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignMerchant(branchId: number, merchantId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/assign-merchant/{merchantId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignMerchant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignPriceList(branchId: number, priceListId: number, targetBranchId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/assign-price-list/{priceListId}/targetBranchId/{targetBranchId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        if (targetBranchId === undefined || targetBranchId === null)
            throw new Error("The parameter 'targetBranchId' must be defined.");
        url_ = url_.replace("{targetBranchId}", encodeURIComponent("" + targetBranchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignPriceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignPriceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignPriceList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubMerchants(branchId: number, saleManagerId?: number | null | undefined, isAssignedToSaleManager?: boolean | null | undefined, isRecursive?: boolean | undefined, priceListId?: number | null | undefined, searchCriteria?: string | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<Branch[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sub-merchants?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (saleManagerId !== undefined && saleManagerId !== null)
            url_ += "saleManagerId=" + encodeURIComponent("" + saleManagerId) + "&";
        if (isAssignedToSaleManager !== undefined && isAssignedToSaleManager !== null)
            url_ += "isAssignedToSaleManager=" + encodeURIComponent("" + isAssignedToSaleManager) + "&";
        if (isRecursive === null)
            throw new Error("The parameter 'isRecursive' cannot be null.");
        else if (isRecursive !== undefined)
            url_ += "isRecursive=" + encodeURIComponent("" + isRecursive) + "&";
        if (priceListId !== undefined && priceListId !== null)
            url_ += "priceListId=" + encodeURIComponent("" + priceListId) + "&";
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubMerchants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubMerchants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Branch[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Branch[]>;
        }));
    }

    protected processGetSubMerchants(response: HttpResponseBase): Observable<Branch[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Branch.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllMerchantsBranch(searchCriteria?: string | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<Branch[]> {
        let url_ = this.baseUrl + "/api/v1/branches/all-merchants-branch?";
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMerchantsBranch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMerchantsBranch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Branch[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Branch[]>;
        }));
    }

    protected processGetAllMerchantsBranch(response: HttpResponseBase): Observable<Branch[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Branch.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(branchId: number, includeSubBranches?: boolean | undefined, httpContext?: HttpContext): Observable<Branch> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (includeSubBranches === null)
            throw new Error("The parameter 'includeSubBranches' cannot be null.");
        else if (includeSubBranches !== undefined)
            url_ += "includeSubBranches=" + encodeURIComponent("" + includeSubBranches) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Branch>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Branch>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Branch> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Branch.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubMerchant(branchId: number, subMerchantId: number, httpContext?: HttpContext): Observable<Branch> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sub-merchant/{subMerchantId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (subMerchantId === undefined || subMerchantId === null)
            throw new Error("The parameter 'subMerchantId' must be defined.");
        url_ = url_.replace("{subMerchantId}", encodeURIComponent("" + subMerchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Branch>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Branch>;
        }));
    }

    protected processGetSubMerchant(response: HttpResponseBase): Observable<Branch> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Branch.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BuyOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getSaleOrders(branchId: number, subMerchantId?: number | null | undefined, currencyId?: number | null | undefined, isPhysicalCardOrder?: boolean | undefined, searchCriteria?: string | null | undefined, buyOrderStates?: string | null | undefined, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<BuyOrder[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/sales?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (subMerchantId !== undefined && subMerchantId !== null)
            url_ += "subMerchantId=" + encodeURIComponent("" + subMerchantId) + "&";
        if (currencyId !== undefined && currencyId !== null)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (isPhysicalCardOrder === null)
            throw new Error("The parameter 'isPhysicalCardOrder' cannot be null.");
        else if (isPhysicalCardOrder !== undefined)
            url_ += "isPhysicalCardOrder=" + encodeURIComponent("" + isPhysicalCardOrder) + "&";
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (buyOrderStates !== undefined && buyOrderStates !== null)
            url_ += "buyOrderStates=" + encodeURIComponent("" + buyOrderStates) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSaleOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSaleOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyOrder[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyOrder[]>;
        }));
    }

    protected processGetSaleOrders(response: HttpResponseBase): Observable<BuyOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BuyOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSaleDashboardOrders(branchId: number, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, httpContext?: HttpContext): Observable<SaleBranches[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/root-sales?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSaleDashboardOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSaleDashboardOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaleBranches[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaleBranches[]>;
        }));
    }

    protected processGetSaleDashboardOrders(response: HttpResponseBase): Observable<SaleBranches[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SaleBranches.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saleReturnOrder(branchId: number, orderId: number, httpContext?: HttpContext): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/{orderId}/roll-back-order";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaleReturnOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaleReturnOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaleReturnOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSaleReturnOrder(branchId: number, saleReturnOrderId: number, httpContext?: HttpContext): Observable<SaleReturnOrder> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/sale-return-orders/{saleReturnOrderId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (saleReturnOrderId === undefined || saleReturnOrderId === null)
            throw new Error("The parameter 'saleReturnOrderId' must be defined.");
        url_ = url_.replace("{saleReturnOrderId}", encodeURIComponent("" + saleReturnOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSaleReturnOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSaleReturnOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaleReturnOrder>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaleReturnOrder>;
        }));
    }

    protected processGetSaleReturnOrder(response: HttpResponseBase): Observable<SaleReturnOrder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaleReturnOrder.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSaleReturnOrders(branchId: number, buyOrderId?: number | null | undefined, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<SaleReturnOrder[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/sale-return-orders?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (buyOrderId !== undefined && buyOrderId !== null)
            url_ += "buyOrderId=" + encodeURIComponent("" + buyOrderId) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSaleReturnOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSaleReturnOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaleReturnOrder[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaleReturnOrder[]>;
        }));
    }

    protected processGetSaleReturnOrders(response: HttpResponseBase): Observable<SaleReturnOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SaleReturnOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CategoriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(request: CreateCategoryRequest, httpContext?: HttpContext): Observable<Category> {
        let url_ = this.baseUrl + "/api/v1/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createRoot(httpContext?: HttpContext): Observable<Category> {
        let url_ = this.baseUrl + "/api/v1/categories/root-category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRoot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRoot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processCreateRoot(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRootCategory(httpContext?: HttpContext): Observable<Category> {
        let url_ = this.baseUrl + "/api/v1/categories/root";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRootCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRootCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processGetRootCategory(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(categoryId: number, request: UpdateCategoryRequest, httpContext?: HttpContext): Observable<Category> {
        let url_ = this.baseUrl + "/api/v1/categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Category>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Category>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CreditClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCustomerCredits(merchantId: number, branchId: number, customerMerchantId: number, httpContext?: HttpContext): Observable<Wallet> {
        let url_ = this.baseUrl + "/api/v1/merchants/{merchantId}/branches/{branchId}/customer-credit?";
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (customerMerchantId === undefined || customerMerchantId === null)
            throw new Error("The parameter 'customerMerchantId' must be defined and cannot be null.");
        else
            url_ += "customerMerchantId=" + encodeURIComponent("" + customerMerchantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerCredits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerCredits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Wallet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Wallet>;
        }));
    }

    protected processGetCustomerCredits(response: HttpResponseBase): Observable<Wallet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Wallet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMyCredit(merchantId: number, branchId: number, httpContext?: HttpContext): Observable<Wallet> {
        let url_ = this.baseUrl + "/api/v1/merchants/{merchantId}/branches/{branchId}/credit";
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyCredit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyCredit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Wallet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Wallet>;
        }));
    }

    protected processGetMyCredit(response: HttpResponseBase): Observable<Wallet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Wallet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCreditTransactions(merchantId: number, branchId: number, receiverMerchantId: number, creditTransactionType?: CreditTransactionType | null | undefined, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, pageSize?: number | null | undefined, pageNumber?: number | null | undefined, httpContext?: HttpContext): Observable<WalletTransaction[]> {
        let url_ = this.baseUrl + "/api/v1/merchants/{merchantId}/branches/{branchId}/credit-transactions?";
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (receiverMerchantId === undefined || receiverMerchantId === null)
            throw new Error("The parameter 'receiverMerchantId' must be defined and cannot be null.");
        else
            url_ += "receiverMerchantId=" + encodeURIComponent("" + receiverMerchantId) + "&";
        if (creditTransactionType !== undefined && creditTransactionType !== null)
            url_ += "creditTransactionType=" + encodeURIComponent("" + creditTransactionType) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreditTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreditTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletTransaction[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletTransaction[]>;
        }));
    }

    protected processGetCreditTransactions(response: HttpResponseBase): Observable<WalletTransaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WalletTransaction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CurrenciesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(currencyName: string, httpContext?: HttpContext): Observable<Currency> {
        let url_ = this.baseUrl + "/api/v1/currencies?";
        if (currencyName === undefined || currencyName === null)
            throw new Error("The parameter 'currencyName' must be defined and cannot be null.");
        else
            url_ += "currencyName=" + encodeURIComponent("" + currencyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Currency>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Currency>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Currency> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Currency.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCurrencies(httpContext?: HttpContext): Observable<Currency[]> {
        let url_ = this.baseUrl + "/api/v1/currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencies(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Currency[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Currency[]>;
        }));
    }

    protected processGetCurrencies(response: HttpResponseBase): Observable<Currency[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Currency.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(currencyId: number, currencyName: string, httpContext?: HttpContext): Observable<Currency> {
        let url_ = this.baseUrl + "/api/v1/currencies/{currencyId}?";
        if (currencyId === undefined || currencyId === null)
            throw new Error("The parameter 'currencyId' must be defined.");
        url_ = url_.replace("{currencyId}", encodeURIComponent("" + currencyId));
        if (currencyName === undefined || currencyName === null)
            throw new Error("The parameter 'currencyName' must be defined and cannot be null.");
        else
            url_ += "currencyName=" + encodeURIComponent("" + currencyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Currency>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Currency>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Currency> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Currency.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshCurrencyExchangeRates(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/currencies/refresh-currency-exchange-rates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshCurrencyExchangeRates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshCurrencyExchangeRates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRefreshCurrencyExchangeRates(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCurrencyExchangeRate(request: PutCurrencyExchangeRateRequest, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/currencies/currency-exchange-rates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCurrencyExchangeRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCurrencyExchangeRate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateCurrencyExchangeRate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FinancialClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(branchId: number, financialType: FinancialOrderType, financialRequest: FinancialRequest, httpContext?: HttpContext): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/financial-order?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (financialType === undefined || financialType === null)
            throw new Error("The parameter 'financialType' must be defined and cannot be null.");
        else
            url_ += "financialType=" + encodeURIComponent("" + financialType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(financialRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFinancialOrders(branchId: number, customerMerchantId?: number | null | undefined, financialType?: FinancialOrderType | null | undefined, financialOrderState?: FinancialOrderState | null | undefined, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, pageSize?: number | null | undefined, pageNumber?: number | null | undefined, httpContext?: HttpContext): Observable<FinancialOrder[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/financial-order?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (customerMerchantId !== undefined && customerMerchantId !== null)
            url_ += "customerMerchantId=" + encodeURIComponent("" + customerMerchantId) + "&";
        if (financialType !== undefined && financialType !== null)
            url_ += "financialType=" + encodeURIComponent("" + financialType) + "&";
        if (financialOrderState !== undefined && financialOrderState !== null)
            url_ += "financialOrderState=" + encodeURIComponent("" + financialOrderState) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinancialOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinancialOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FinancialOrder[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FinancialOrder[]>;
        }));
    }

    protected processGetFinancialOrders(response: HttpResponseBase): Observable<FinancialOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FinancialOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    verify(branchId: number, financialType: FinancialOrderType, financialOrderId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/financial-order/{financialOrderId}/verify?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (financialOrderId === undefined || financialOrderId === null)
            throw new Error("The parameter 'financialOrderId' must be defined.");
        url_ = url_.replace("{financialOrderId}", encodeURIComponent("" + financialOrderId));
        if (financialType === undefined || financialType === null)
            throw new Error("The parameter 'financialType' must be defined and cannot be null.");
        else
            url_ += "financialType=" + encodeURIComponent("" + financialType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reject(branchId: number, financialType: FinancialOrderType, financialOrderId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/financial-order/{financialOrderId}/reject?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (financialOrderId === undefined || financialOrderId === null)
            throw new Error("The parameter 'financialOrderId' must be defined.");
        url_ = url_.replace("{financialOrderId}", encodeURIComponent("" + financialOrderId));
        if (financialType === undefined || financialType === null)
            throw new Error("The parameter 'financialType' must be defined and cannot be null.");
        else
            url_ += "financialType=" + encodeURIComponent("" + financialType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processReject(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GatewayListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(branchId: number, request: CreateGatewayListRequest, httpContext?: HttpContext): Observable<GatewayList> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GatewayList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GatewayList>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<GatewayList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GatewayList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(branchId: number, gatewayListId: number, forceDelete?: boolean | null | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (gatewayListId === undefined || gatewayListId === null)
            throw new Error("The parameter 'gatewayListId' must be defined and cannot be null.");
        else
            url_ += "gatewayListId=" + encodeURIComponent("" + gatewayListId) + "&";
        if (forceDelete !== undefined && forceDelete !== null)
            url_ += "forceDelete=" + encodeURIComponent("" + forceDelete) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getGatewayLists(branchId: number, httpContext?: HttpContext): Observable<GatewayList[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGatewayLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGatewayLists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GatewayList[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GatewayList[]>;
        }));
    }

    protected processGetGatewayLists(response: HttpResponseBase): Observable<GatewayList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GatewayList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(branchId: number, gatewayListId: number, httpContext?: HttpContext): Observable<GatewayList> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists/{gatewayListId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (gatewayListId === undefined || gatewayListId === null)
            throw new Error("The parameter 'gatewayListId' must be defined.");
        url_ = url_.replace("{gatewayListId}", encodeURIComponent("" + gatewayListId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GatewayList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GatewayList>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GatewayList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GatewayList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    put(branchId: number, gatewayListId: number, request: PutGatewayListRequest, httpContext?: HttpContext): Observable<GatewayList> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists/{gatewayListId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (gatewayListId === undefined || gatewayListId === null)
            throw new Error("The parameter 'gatewayListId' must be defined.");
        url_ = url_.replace("{gatewayListId}", encodeURIComponent("" + gatewayListId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GatewayList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GatewayList>;
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<GatewayList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GatewayList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAssignedMerchantsByGatewayListId(branchId: number, gatewayListId: number, httpContext?: HttpContext): Observable<MerchantSummary[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists/{gatewayListId}/assigned-merchants";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (gatewayListId === undefined || gatewayListId === null)
            throw new Error("The parameter 'gatewayListId' must be defined.");
        url_ = url_.replace("{gatewayListId}", encodeURIComponent("" + gatewayListId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssignedMerchantsByGatewayListId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssignedMerchantsByGatewayListId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantSummary[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantSummary[]>;
        }));
    }

    protected processGetAssignedMerchantsByGatewayListId(response: HttpResponseBase): Observable<MerchantSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MerchantSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPaymentProfiles(branchId: number, httpContext?: HttpContext): Observable<PaymentProfile[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists/payment-profiles";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentProfiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentProfiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentProfile[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentProfile[]>;
        }));
    }

    protected processGetPaymentProfiles(response: HttpResponseBase): Observable<PaymentProfile[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentProfile.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomerPaymentProfiles(branchId: number, customerMerchantId: number, httpContext?: HttpContext): Observable<PaymentProfile[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists/customer-payment-profiles?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (customerMerchantId === undefined || customerMerchantId === null)
            throw new Error("The parameter 'customerMerchantId' must be defined and cannot be null.");
        else
            url_ += "customerMerchantId=" + encodeURIComponent("" + customerMerchantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerPaymentProfiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerPaymentProfiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentProfile[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentProfile[]>;
        }));
    }

    protected processGetCustomerPaymentProfiles(response: HttpResponseBase): Observable<PaymentProfile[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentProfile.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignToMerchant(branchId: number, gatewayListId: number, subMerchantId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists/{gatewayListId}/assign-merchant/{subMerchantId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (gatewayListId === undefined || gatewayListId === null)
            throw new Error("The parameter 'gatewayListId' must be defined.");
        url_ = url_.replace("{gatewayListId}", encodeURIComponent("" + gatewayListId));
        if (subMerchantId === undefined || subMerchantId === null)
            throw new Error("The parameter 'subMerchantId' must be defined.");
        url_ = url_.replace("{subMerchantId}", encodeURIComponent("" + subMerchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignToMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignToMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignToMerchant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unAssignFromMerchant(branchId: number, gatewayListId: number, subMerchantId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/gateway-lists/{gatewayListId}/unassign-merchant/{subMerchantId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (gatewayListId === undefined || gatewayListId === null)
            throw new Error("The parameter 'gatewayListId' must be defined.");
        url_ = url_.replace("{gatewayListId}", encodeURIComponent("" + gatewayListId));
        if (subMerchantId === undefined || subMerchantId === null)
            throw new Error("The parameter 'subMerchantId' must be defined.");
        url_ = url_.replace("{subMerchantId}", encodeURIComponent("" + subMerchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnAssignFromMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnAssignFromMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnAssignFromMerchant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InvoicesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getInvoices(merchantId: number, beginCreatedTime?: Date | null | undefined, endCreatedTime?: Date | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<InvoiceSummary[]> {
        let url_ = this.baseUrl + "/api/v1/merchants/{merchantId}/Invoices?";
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        if (beginCreatedTime !== undefined && beginCreatedTime !== null)
            url_ += "beginCreatedTime=" + encodeURIComponent(beginCreatedTime ? "" + beginCreatedTime.toISOString() : "") + "&";
        if (endCreatedTime !== undefined && endCreatedTime !== null)
            url_ += "endCreatedTime=" + encodeURIComponent(endCreatedTime ? "" + endCreatedTime.toISOString() : "") + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceSummary[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceSummary[]>;
        }));
    }

    protected processGetInvoices(response: HttpResponseBase): Observable<InvoiceSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getInvoice(merchantId: number, invoiceId: number, httpContext?: HttpContext): Observable<Invoice> {
        let url_ = this.baseUrl + "/api/v1/merchants/{merchantId}/Invoices/{invoiceId}";
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Invoice>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Invoice>;
        }));
    }

    protected processGetInvoice(response: HttpResponseBase): Observable<Invoice> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MerchantCurrencyLimitsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    put(branchId: number, subMerchantId: number, request: CreateMerchantCurrencyLimitRequest, httpContext?: HttpContext): Observable<MerchantCurrencyLimit> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sub-merchants/{subMerchantId}/currency-limits";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (subMerchantId === undefined || subMerchantId === null)
            throw new Error("The parameter 'subMerchantId' must be defined.");
        url_ = url_.replace("{subMerchantId}", encodeURIComponent("" + subMerchantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantCurrencyLimit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantCurrencyLimit>;
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<MerchantCurrencyLimit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantCurrencyLimit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMerchantCurrencyLimits(branchId: number, subMerchantId: number, httpContext?: HttpContext): Observable<MerchantCurrencyLimit[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sub-merchants/{subMerchantId}/currency-limits";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (subMerchantId === undefined || subMerchantId === null)
            throw new Error("The parameter 'subMerchantId' must be defined.");
        url_ = url_.replace("{subMerchantId}", encodeURIComponent("" + subMerchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMerchantCurrencyLimits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMerchantCurrencyLimits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantCurrencyLimit[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantCurrencyLimit[]>;
        }));
    }

    protected processGetMerchantCurrencyLimits(response: HttpResponseBase): Observable<MerchantCurrencyLimit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MerchantCurrencyLimit.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createRootMerchantCurrencyLimit(branchId: number, request: CreateMerchantCurrencyLimitRequest, httpContext?: HttpContext): Observable<MerchantCurrencyLimit> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/root-currency-limits";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRootMerchantCurrencyLimit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRootMerchantCurrencyLimit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantCurrencyLimit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantCurrencyLimit>;
        }));
    }

    protected processCreateRootMerchantCurrencyLimit(response: HttpResponseBase): Observable<MerchantCurrencyLimit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantCurrencyLimit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(branchId: number, subMerchantId: number, currencyLimitId: number, amount: number, httpContext?: HttpContext): Observable<MerchantCurrencyLimit> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sub-merchants/{subMerchantId}/currency-limits/{currencyLimitId}?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (subMerchantId === undefined || subMerchantId === null)
            throw new Error("The parameter 'subMerchantId' must be defined.");
        url_ = url_.replace("{subMerchantId}", encodeURIComponent("" + subMerchantId));
        if (currencyLimitId === undefined || currencyLimitId === null)
            throw new Error("The parameter 'currencyLimitId' must be defined.");
        url_ = url_.replace("{currencyLimitId}", encodeURIComponent("" + currencyLimitId));
        if (amount === undefined || amount === null)
            throw new Error("The parameter 'amount' must be defined and cannot be null.");
        else
            url_ += "amount=" + encodeURIComponent("" + amount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantCurrencyLimit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantCurrencyLimit>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MerchantCurrencyLimit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantCurrencyLimit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(branchId: number, subMerchantId: number, currencyLimitId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sub-merchants/{subMerchantId}/currency-limits/{currencyLimitId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (subMerchantId === undefined || subMerchantId === null)
            throw new Error("The parameter 'subMerchantId' must be defined.");
        url_ = url_.replace("{subMerchantId}", encodeURIComponent("" + subMerchantId));
        if (currencyLimitId === undefined || currencyLimitId === null)
            throw new Error("The parameter 'currencyLimitId' must be defined.");
        url_ = url_.replace("{currencyLimitId}", encodeURIComponent("" + currencyLimitId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MerchantsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(branchId: number, request: CreateMerchantRequest, httpContext?: HttpContext): Observable<MerchantLight> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/merchants";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantLight>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantLight>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MerchantLight> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantLight.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(branchId: number, merchantId: number, includeSubBranches?: boolean | undefined, httpContext?: HttpContext): Observable<Merchant> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/merchants/{merchantId}?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        if (includeSubBranches === null)
            throw new Error("The parameter 'includeSubBranches' cannot be null.");
        else if (includeSubBranches !== undefined)
            url_ += "includeSubBranches=" + encodeURIComponent("" + includeSubBranches) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Merchant>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Merchant>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Merchant> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Merchant.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(branchId: number, merchantId: number, request: UpdateMerchantRequest, httpContext?: HttpContext): Observable<Merchant> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/merchants/{merchantId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Merchant>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Merchant>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Merchant> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Merchant.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    generate2FaQrCode(branchId: number, merchantId: number, httpContext?: HttpContext): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/merchants/{merchantId}/generate-2fa-qrCode";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerate2FaQrCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerate2FaQrCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGenerate2FaQrCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateSubMerchant(branchId: number, subMerchantId: number, request: UpdateSubMerchantRequest, httpContext?: HttpContext): Observable<Merchant> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/merchants/sub-merchants/{subMerchantId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (subMerchantId === undefined || subMerchantId === null)
            throw new Error("The parameter 'subMerchantId' must be defined.");
        url_ = url_.replace("{subMerchantId}", encodeURIComponent("" + subMerchantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Merchant>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Merchant>;
        }));
    }

    protected processUpdateSubMerchant(response: HttpResponseBase): Observable<Merchant> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Merchant.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateMerchantSetting(branchId: number, merchantId: number, request: UpdateMerchantSettingRequest, httpContext?: HttpContext): Observable<Merchant> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/merchants/{merchantId}/setting";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMerchantSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMerchantSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Merchant>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Merchant>;
        }));
    }

    protected processUpdateMerchantSetting(response: HttpResponseBase): Observable<Merchant> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Merchant.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PaymentOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    ordinary(branchId: number, request: CreateChargeOrdinaryPaymentOrderRequest, httpContext?: HttpContext): Observable<PaymentOrder> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/payment-orders/ordinary";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrdinary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrdinary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentOrder>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentOrder>;
        }));
    }

    protected processOrdinary(response: HttpResponseBase): Observable<PaymentOrder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentOrder.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    auto(branchId: number, request: CreateChargeAutoPaymentOrderRequest, httpContext?: HttpContext): Observable<PaymentOrder> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/payment-orders/auto";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentOrder>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentOrder>;
        }));
    }

    protected processAuto(response: HttpResponseBase): Observable<PaymentOrder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentOrder.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(branchId: number, paymentOrderId: number, httpContext?: HttpContext): Observable<PaymentOrder> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/payment-orders/{paymentOrderId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (paymentOrderId === undefined || paymentOrderId === null)
            throw new Error("The parameter 'paymentOrderId' must be defined.");
        url_ = url_.replace("{paymentOrderId}", encodeURIComponent("" + paymentOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentOrder>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentOrder>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaymentOrder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentOrder.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPaymentOrders(branchId: number, paymentOrderStates?: string | null | undefined, paymentOrderType?: PaymentOrderType | null | undefined, searchCriteria?: string | null | undefined, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<PaymentOrderSummary[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/payment-orders?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (paymentOrderStates !== undefined && paymentOrderStates !== null)
            url_ += "paymentOrderStates=" + encodeURIComponent("" + paymentOrderStates) + "&";
        if (paymentOrderType !== undefined && paymentOrderType !== null)
            url_ += "paymentOrderType=" + encodeURIComponent("" + paymentOrderType) + "&";
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentOrderSummary[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentOrderSummary[]>;
        }));
    }

    protected processGetPaymentOrders(response: HttpResponseBase): Observable<PaymentOrderSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentOrderSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    stateLogs(branchId: number, paymentOrderId: number, httpContext?: HttpContext): Observable<PaymentOrderStateLog[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/payment-orders/{paymentOrderId}/state-logs";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (paymentOrderId === undefined || paymentOrderId === null)
            throw new Error("The parameter 'paymentOrderId' must be defined.");
        url_ = url_.replace("{paymentOrderId}", encodeURIComponent("" + paymentOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStateLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStateLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentOrderStateLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentOrderStateLog[]>;
        }));
    }

    protected processStateLogs(response: HttpResponseBase): Observable<PaymentOrderStateLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentOrderStateLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubMerchantPaymentOrders(branchId: number, subMerchantId?: number | null | undefined, paymentOrderStates?: string | null | undefined, paymentOrderType?: PaymentOrderType | null | undefined, searchCriteria?: string | null | undefined, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<PaymentOrderSummary[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/payment-orders/sub-merchants-orders?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (subMerchantId !== undefined && subMerchantId !== null)
            url_ += "subMerchantId=" + encodeURIComponent("" + subMerchantId) + "&";
        if (paymentOrderStates !== undefined && paymentOrderStates !== null)
            url_ += "paymentOrderStates=" + encodeURIComponent("" + paymentOrderStates) + "&";
        if (paymentOrderType !== undefined && paymentOrderType !== null)
            url_ += "paymentOrderType=" + encodeURIComponent("" + paymentOrderType) + "&";
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubMerchantPaymentOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubMerchantPaymentOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentOrderSummary[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentOrderSummary[]>;
        }));
    }

    protected processGetSubMerchantPaymentOrders(response: HttpResponseBase): Observable<PaymentOrderSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentOrderSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PaymentProviderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCustomerPanelLink(branchId: number, merchantId: number, accessType: PaymentProviderCustomerPanelLinkAccessType, httpContext?: HttpContext): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/payment-provider/customer-panel-link?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined and cannot be null.");
        else
            url_ += "merchantId=" + encodeURIComponent("" + merchantId) + "&";
        if (accessType === undefined || accessType === null)
            throw new Error("The parameter 'accessType' must be defined and cannot be null.");
        else
            url_ += "accessType=" + encodeURIComponent("" + accessType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerPanelLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerPanelLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetCustomerPanelLink(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMerchantPaymentMethods(branchId: number, merchantId: number, httpContext?: HttpContext): Observable<PaymentProviderPaymentMethod[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/payment-provider/payment-methods?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined and cannot be null.");
        else
            url_ += "merchantId=" + encodeURIComponent("" + merchantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMerchantPaymentMethods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMerchantPaymentMethods(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentProviderPaymentMethod[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentProviderPaymentMethod[]>;
        }));
    }

    protected processGetMerchantPaymentMethods(response: HttpResponseBase): Observable<PaymentProviderPaymentMethod[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentProviderPaymentMethod.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PhysicalCardsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    placeOrder(branchId: number, request: PlacePhysicalCardOrderRequest, httpContext?: HttpContext): Observable<number> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/physical-cards/place-order";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlaceOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlaceOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processPlaceOrder(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrders(branchId: number, searchCriteria?: string | null | undefined, physicalCardOrderStates?: string | null | undefined, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<PhysicalCardOrder[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/physical-cards/orders?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (physicalCardOrderStates !== undefined && physicalCardOrderStates !== null)
            url_ += "physicalCardOrderStates=" + encodeURIComponent("" + physicalCardOrderStates) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhysicalCardOrder[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhysicalCardOrder[]>;
        }));
    }

    protected processGetOrders(response: HttpResponseBase): Observable<PhysicalCardOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhysicalCardOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubMerchantsOrders(branchId: number, subMerchantId?: number | null | undefined, searchCriteria?: string | null | undefined, physicalCardOrderStates?: string | null | undefined, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<PhysicalCardOrder[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/physical-cards/sub-merchants-orders?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (subMerchantId !== undefined && subMerchantId !== null)
            url_ += "subMerchantId=" + encodeURIComponent("" + subMerchantId) + "&";
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (physicalCardOrderStates !== undefined && physicalCardOrderStates !== null)
            url_ += "physicalCardOrderStates=" + encodeURIComponent("" + physicalCardOrderStates) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubMerchantsOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubMerchantsOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhysicalCardOrder[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhysicalCardOrder[]>;
        }));
    }

    protected processGetSubMerchantsOrders(response: HttpResponseBase): Observable<PhysicalCardOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhysicalCardOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changePhysicalCardOrderState(branchId: number, physicalCardOrderId: number, state: PhysicalCardOrderState, description?: string | null | undefined, httpContext?: HttpContext): Observable<PhysicalCardOrder> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/physical-cards/orders/{physicalCardOrderId}/change-state?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (physicalCardOrderId === undefined || physicalCardOrderId === null)
            throw new Error("The parameter 'physicalCardOrderId' must be defined.");
        url_ = url_.replace("{physicalCardOrderId}", encodeURIComponent("" + physicalCardOrderId));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (description !== undefined && description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePhysicalCardOrderState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePhysicalCardOrderState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhysicalCardOrder>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhysicalCardOrder>;
        }));
    }

    protected processChangePhysicalCardOrderState(response: HttpResponseBase): Observable<PhysicalCardOrder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PhysicalCardOrder.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderStateLogs(branchId: number, physicalCardOrderId: number, httpContext?: HttpContext): Observable<PhysicalCardOrderStateLog[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/physical-cards/orders/{physicalCardOrderId}/state-logs";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (physicalCardOrderId === undefined || physicalCardOrderId === null)
            throw new Error("The parameter 'physicalCardOrderId' must be defined.");
        url_ = url_.replace("{physicalCardOrderId}", encodeURIComponent("" + physicalCardOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderStateLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderStateLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhysicalCardOrderStateLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhysicalCardOrderStateLog[]>;
        }));
    }

    protected processGetOrderStateLogs(response: HttpResponseBase): Observable<PhysicalCardOrderStateLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhysicalCardOrderStateLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PosesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(request: CreatePosRequest, httpContext?: HttpContext): Observable<Pos> {
        let url_ = this.baseUrl + "/api/v1/poses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Pos>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Pos>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Pos> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Pos.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPoses(pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<Pos[]> {
        let url_ = this.baseUrl + "/api/v1/poses?";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Pos[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Pos[]>;
        }));
    }

    protected processGetPoses(response: HttpResponseBase): Observable<Pos[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pos.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(posId: number, request: UpdatePosRequest, httpContext?: HttpContext): Observable<Pos> {
        let url_ = this.baseUrl + "/api/v1/poses/{posId}";
        if (posId === undefined || posId === null)
            throw new Error("The parameter 'posId' must be defined.");
        url_ = url_.replace("{posId}", encodeURIComponent("" + posId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Pos>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Pos>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Pos> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Pos.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PosOrdersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(branchId: number, request: CreatePosOrderRequest, httpContext?: HttpContext): Observable<CreatePosOrderResponse> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/pos-orders";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreatePosOrderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreatePosOrderResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreatePosOrderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreatePosOrderResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPosOrders(branchId: number, posOrderStates?: string | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<PosOrder[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/pos-orders?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (posOrderStates !== undefined && posOrderStates !== null)
            url_ += "posOrderStates=" + encodeURIComponent("" + posOrderStates) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosOrder[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosOrder[]>;
        }));
    }

    protected processGetPosOrders(response: HttpResponseBase): Observable<PosOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PosOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPosOrder(branchId: number, posOrderId: number, httpContext?: HttpContext): Observable<PosOrder> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/pos-orders/{posOrderId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (posOrderId === undefined || posOrderId === null)
            throw new Error("The parameter 'posOrderId' must be defined.");
        url_ = url_.replace("{posOrderId}", encodeURIComponent("" + posOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosOrder>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosOrder>;
        }));
    }

    protected processGetPosOrder(response: HttpResponseBase): Observable<PosOrder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosOrder.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changePosOrderState(branchId: number, posOrderId: number, state: PosOrderState, description?: string | null | undefined, httpContext?: HttpContext): Observable<PosOrder> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/pos-orders/{posOrderId}/change-state?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (posOrderId === undefined || posOrderId === null)
            throw new Error("The parameter 'posOrderId' must be defined.");
        url_ = url_.replace("{posOrderId}", encodeURIComponent("" + posOrderId));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (description !== undefined && description !== null)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePosOrderState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePosOrderState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosOrder>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosOrder>;
        }));
    }

    protected processChangePosOrderState(response: HttpResponseBase): Observable<PosOrder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PosOrder.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubMerchantPosOrders(branchId: number, subMerchantId?: number | null | undefined, posOrderStates?: string | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<PosOrder[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/pos-orders/sub-merchant-pos-orders?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (subMerchantId !== undefined && subMerchantId !== null)
            url_ += "subMerchantId=" + encodeURIComponent("" + subMerchantId) + "&";
        if (posOrderStates !== undefined && posOrderStates !== null)
            url_ += "posOrderStates=" + encodeURIComponent("" + posOrderStates) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubMerchantPosOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubMerchantPosOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosOrder[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosOrder[]>;
        }));
    }

    protected processGetSubMerchantPosOrders(response: HttpResponseBase): Observable<PosOrder[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PosOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPosOrderStateLogs(branchId: number, posOrderId: number, httpContext?: HttpContext): Observable<PosOrderStateLog[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/pos-orders/{posOrderId}/state-logs";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (posOrderId === undefined || posOrderId === null)
            throw new Error("The parameter 'posOrderId' must be defined.");
        url_ = url_.replace("{posOrderId}", encodeURIComponent("" + posOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosOrderStateLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosOrderStateLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PosOrderStateLog[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PosOrderStateLog[]>;
        }));
    }

    protected processGetPosOrderStateLogs(response: HttpResponseBase): Observable<PosOrderStateLog[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PosOrderStateLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PostPayClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getMyPostPayInvoiceItems(branchId: number, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<PostPayInvoiceItem[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/post-pay-invoices?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyPostPayInvoiceItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyPostPayInvoiceItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostPayInvoiceItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostPayInvoiceItem[]>;
        }));
    }

    protected processGetMyPostPayInvoiceItems(response: HttpResponseBase): Observable<PostPayInvoiceItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostPayInvoiceItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPostPayInvoiceItems(branchId: number, postPayInvoiceId: number, httpContext?: HttpContext): Observable<PostPayInvoiceItem[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/post-pay-invoices/items?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (postPayInvoiceId === undefined || postPayInvoiceId === null)
            throw new Error("The parameter 'postPayInvoiceId' must be defined and cannot be null.");
        else
            url_ += "postPayInvoiceId=" + encodeURIComponent("" + postPayInvoiceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostPayInvoiceItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostPayInvoiceItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostPayInvoiceItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostPayInvoiceItem[]>;
        }));
    }

    protected processGetPostPayInvoiceItems(response: HttpResponseBase): Observable<PostPayInvoiceItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostPayInvoiceItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubMerchantsPostPayInvoices(branchId: number, filterMerchantId?: number | null | undefined, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<PostPayInvoiceItem[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/post-pay-invoices/sub-merchants?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (filterMerchantId !== undefined && filterMerchantId !== null)
            url_ += "filterMerchantId=" + encodeURIComponent("" + filterMerchantId) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubMerchantsPostPayInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubMerchantsPostPayInvoices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostPayInvoiceItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostPayInvoiceItem[]>;
        }));
    }

    protected processGetSubMerchantsPostPayInvoices(response: HttpResponseBase): Observable<PostPayInvoiceItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostPayInvoiceItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PriceListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(branchId: number, request: CreatePriceListRequest, httpContext?: HttpContext): Observable<PriceList> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceList>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PriceList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByBranch(branchId: number, httpContext?: HttpContext): Observable<PriceList> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByBranch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByBranch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceList>;
        }));
    }

    protected processGetByBranch(response: HttpResponseBase): Observable<PriceList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBuyPrices(branchId: number, searchCriteria?: string | null | undefined, productId?: number | null | undefined, currencyId?: number | null | undefined, categoryId?: number | null | undefined, isPhysicalProduct?: boolean | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<BuyPrice[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists/buy-prices?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (productId !== undefined && productId !== null)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (currencyId !== undefined && currencyId !== null)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (categoryId !== undefined && categoryId !== null)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (isPhysicalProduct !== undefined && isPhysicalProduct !== null)
            url_ += "isPhysicalProduct=" + encodeURIComponent("" + isPhysicalProduct) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBuyPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBuyPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BuyPrice[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BuyPrice[]>;
        }));
    }

    protected processGetBuyPrices(response: HttpResponseBase): Observable<BuyPrice[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BuyPrice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(branchId: number, priceListId: number, httpContext?: HttpContext): Observable<PriceList> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists/{priceListId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceList>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PriceList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPriceViews(branchId: number, priceListId: number, searchCriteria?: string | null | undefined, filterCurrencyId?: number | null | undefined, filterCategoryId?: number | null | undefined, isPhysicalProduct?: boolean | null | undefined, httpContext?: HttpContext): Observable<PriceView[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists/{priceListId}/price-views?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (filterCurrencyId !== undefined && filterCurrencyId !== null)
            url_ += "filterCurrencyId=" + encodeURIComponent("" + filterCurrencyId) + "&";
        if (filterCategoryId !== undefined && filterCategoryId !== null)
            url_ += "filterCategoryId=" + encodeURIComponent("" + filterCategoryId) + "&";
        if (isPhysicalProduct !== undefined && isPhysicalProduct !== null)
            url_ += "isPhysicalProduct=" + encodeURIComponent("" + isPhysicalProduct) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriceViews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriceViews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceView[]>;
        }));
    }

    protected processGetPriceViews(response: HttpResponseBase): Observable<PriceView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PriceView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPriceView(branchId: number, priceListId: number, productId: number, httpContext?: HttpContext): Observable<PriceView> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists/{priceListId}/price-view/productId:{productId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriceView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriceView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceView>;
        }));
    }

    protected processGetPriceView(response: HttpResponseBase): Observable<PriceView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPrices(branchId: number, priceListId: number, searchCriteria?: string | null | undefined, filterCurrencyId?: number | null | undefined, filterCategoryId?: number | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<PriceView[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists/{priceListId}/prices?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (filterCurrencyId !== undefined && filterCurrencyId !== null)
            url_ += "filterCurrencyId=" + encodeURIComponent("" + filterCurrencyId) + "&";
        if (filterCategoryId !== undefined && filterCategoryId !== null)
            url_ += "filterCategoryId=" + encodeURIComponent("" + filterCategoryId) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceView[]>;
        }));
    }

    protected processGetPrices(response: HttpResponseBase): Observable<PriceView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PriceView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setPrices(branchId: number, priceListId: number, priceRules: ProductPriceRule[], httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists/{priceListId}/prices";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(priceRules);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetPrices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPriceRulesByProduct(branchId: number, priceListId: number, productId: number, httpContext?: HttpContext): Observable<Price> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists/{priceListId}/prices/productId:{productId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPriceRulesByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPriceRulesByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Price>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Price>;
        }));
    }

    protected processGetPriceRulesByProduct(response: HttpResponseBase): Observable<Price> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Price.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deletePriceRulesByProduct(branchId: number, priceListId: number, productId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists/{priceListId}/prices/productId:{productId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePriceRulesByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePriceRulesByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePriceRulesByProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setPriceRulesByProduct(branchId: number, priceListId: number, productId: number, priceRules: PriceRule[], preview?: boolean | undefined, httpContext?: HttpContext): Observable<PriceView> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/price-lists/{priceListId}/prices/productId:{productId}?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (priceListId === undefined || priceListId === null)
            throw new Error("The parameter 'priceListId' must be defined.");
        url_ = url_.replace("{priceListId}", encodeURIComponent("" + priceListId));
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (preview === null)
            throw new Error("The parameter 'preview' cannot be null.");
        else if (preview !== undefined)
            url_ += "preview=" + encodeURIComponent("" + preview) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(priceRules);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPriceRulesByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPriceRulesByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceView>;
        }));
    }

    protected processSetPriceRulesByProduct(response: HttpResponseBase): Observable<PriceView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(request: CreateProductRequest, httpContext?: HttpContext): Observable<Product> {
        let url_ = this.baseUrl + "/api/v1/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProducts(searchCriteria?: string | null | undefined, filterCurrencyId?: number | null | undefined, filterCategoryId?: number | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<ProductSummary[]> {
        let url_ = this.baseUrl + "/api/v1/products?";
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (filterCurrencyId !== undefined && filterCurrencyId !== null)
            url_ += "filterCurrencyId=" + encodeURIComponent("" + filterCurrencyId) + "&";
        if (filterCategoryId !== undefined && filterCategoryId !== null)
            url_ += "filterCategoryId=" + encodeURIComponent("" + filterCategoryId) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductSummary[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductSummary[]>;
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProductSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sync(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/products/sync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSync(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(productId: number, request: UpdateProductRequest, httpContext?: HttpContext): Observable<Product> {
        let url_ = this.baseUrl + "/api/v1/products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(productId: number, httpContext?: HttpContext): Observable<Product> {
        let url_ = this.baseUrl + "/api/v1/products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Product>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Product>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAvailableProductItems(productId?: number | null | undefined, currencyId?: number | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<ProductItem[]> {
        let url_ = this.baseUrl + "/api/v1/products/available-items?";
        if (productId !== undefined && productId !== null)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (currencyId !== undefined && currencyId !== null)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableProductItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableProductItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductItem[]>;
        }));
    }

    protected processGetAvailableProductItems(response: HttpResponseBase): Observable<ProductItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RegionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(request: CreateRegionRequest, httpContext?: HttpContext): Observable<Region> {
        let url_ = this.baseUrl + "/api/v1/regions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Region>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Region>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Region> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Region.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRegions(pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<Region[]> {
        let url_ = this.baseUrl + "/api/v1/regions?";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Region[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Region[]>;
        }));
    }

    protected processGetRegions(response: HttpResponseBase): Observable<Region[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Region.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(regionId: number, httpContext?: HttpContext): Observable<Region> {
        let url_ = this.baseUrl + "/api/v1/regions/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Region>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Region>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Region> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Region.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(regionId: number, request: UpdateRegionRequest, httpContext?: HttpContext): Observable<Region> {
        let url_ = this.baseUrl + "/api/v1/regions/{regionId}";
        if (regionId === undefined || regionId === null)
            throw new Error("The parameter 'regionId' must be defined.");
        url_ = url_.replace("{regionId}", encodeURIComponent("" + regionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Region>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Region>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Region> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Region.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ReportsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    report(branchId: number, beginTime: Date, endTime: Date, httpContext?: HttpContext): Observable<Report> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/reports/report?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (beginTime === undefined || beginTime === null)
            throw new Error("The parameter 'beginTime' must be defined and cannot be null.");
        else
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report>;
        }));
    }

    protected processReport(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reportSummary(branchId: number, beginTime: Date, endTime: Date, httpContext?: HttpContext): Observable<ReportSummary[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/reports/report-summary?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (beginTime === undefined || beginTime === null)
            throw new Error("The parameter 'beginTime' must be defined and cannot be null.");
        else
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReportSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReportSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReportSummary[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReportSummary[]>;
        }));
    }

    protected processReportSummary(response: HttpResponseBase): Observable<ReportSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReportSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SaleManagersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(branchId: number, request: CreateSaleManagerRequest, httpContext?: HttpContext): Observable<SaleManager> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sale-managers";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaleManager>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaleManager>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<SaleManager> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaleManager.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSaleManagers(branchId: number, isActive?: boolean | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<SaleManager[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sale-managers?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (isActive !== undefined && isActive !== null)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSaleManagers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSaleManagers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaleManager[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaleManager[]>;
        }));
    }

    protected processGetSaleManagers(response: HttpResponseBase): Observable<SaleManager[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SaleManager.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(branchId: number, saleManagerId: number, httpContext?: HttpContext): Observable<SaleManager> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sale-managers/{saleManagerId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (saleManagerId === undefined || saleManagerId === null)
            throw new Error("The parameter 'saleManagerId' must be defined.");
        url_ = url_.replace("{saleManagerId}", encodeURIComponent("" + saleManagerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaleManager>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaleManager>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SaleManager> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaleManager.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(branchId: number, saleManagerId: number, request: UpdateSaleManagerRequest, httpContext?: HttpContext): Observable<SaleManager> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sale-managers/{saleManagerId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (saleManagerId === undefined || saleManagerId === null)
            throw new Error("The parameter 'saleManagerId' must be defined.");
        url_ = url_.replace("{saleManagerId}", encodeURIComponent("" + saleManagerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaleManager>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaleManager>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SaleManager> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaleManager.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignMerchants(branchId: number, saleManagerId: number, merchantIds: number[], forceAssign?: boolean | undefined, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sale-managers/{saleManagerId}/assign-merchants?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (saleManagerId === undefined || saleManagerId === null)
            throw new Error("The parameter 'saleManagerId' must be defined.");
        url_ = url_.replace("{saleManagerId}", encodeURIComponent("" + saleManagerId));
        if (forceAssign === null)
            throw new Error("The parameter 'forceAssign' cannot be null.");
        else if (forceAssign !== undefined)
            url_ += "forceAssign=" + encodeURIComponent("" + forceAssign) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(merchantIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignMerchants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignMerchants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignMerchants(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unAssignMerchant(branchId: number, saleManagerId: number, merchantId: number, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sale-managers/{saleManagerId}/unAssign-merchant/{merchantId}";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (saleManagerId === undefined || saleManagerId === null)
            throw new Error("The parameter 'saleManagerId' must be defined.");
        url_ = url_.replace("{saleManagerId}", encodeURIComponent("" + saleManagerId));
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnAssignMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnAssignMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnAssignMerchant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSaleReport(branchId: number, saleManagerId: number, beginTime: Date, endTime: Date, httpContext?: HttpContext): Observable<SaleManagerAccountingReport[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/sale-managers/{saleManagerId}/sale-report?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (saleManagerId === undefined || saleManagerId === null)
            throw new Error("The parameter 'saleManagerId' must be defined.");
        url_ = url_.replace("{saleManagerId}", encodeURIComponent("" + saleManagerId));
        if (beginTime === undefined || beginTime === null)
            throw new Error("The parameter 'beginTime' must be defined and cannot be null.");
        else
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSaleReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSaleReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaleManagerAccountingReport[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaleManagerAccountingReport[]>;
        }));
    }

    protected processGetSaleReport(response: HttpResponseBase): Observable<SaleManagerAccountingReport[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SaleManagerAccountingReport.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SystemClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    assignMerchantToMerchant(branchId: number, merchantId: number, targetBranchId: number, targetMerchantId: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/system/merchants/{merchantId}/assign-to-merchant/{targetMerchantId}?";
        if (merchantId === undefined || merchantId === null)
            throw new Error("The parameter 'merchantId' must be defined.");
        url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
        if (targetMerchantId === undefined || targetMerchantId === null)
            throw new Error("The parameter 'targetMerchantId' must be defined.");
        url_ = url_.replace("{targetMerchantId}", encodeURIComponent("" + targetMerchantId));
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined and cannot be null.");
        else
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&";
        if (targetBranchId === undefined || targetBranchId === null)
            throw new Error("The parameter 'targetBranchId' must be defined and cannot be null.");
        else
            url_ += "targetBranchId=" + encodeURIComponent("" + targetBranchId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignMerchantToMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignMerchantToMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignMerchantToMerchant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateSetting(request: UpdateSettingRequest, httpContext?: HttpContext): Observable<SettingModel> {
        let url_ = this.baseUrl + "/api/v1/system";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingModel>;
        }));
    }

    protected processUpdateSetting(response: HttpResponseBase): Observable<SettingModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadImage(image: FileParameter, httpContext?: HttpContext): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/system/upload-image";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (image === null || image === undefined)
            throw new Error("The parameter 'image' cannot be null.");
        else
            content_.append("Image", image.data, image.fileName ? image.fileName : "Image");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSystemRootPriceList(httpContext?: HttpContext): Observable<PriceList> {
        let url_ = this.baseUrl + "/api/v1/system/system-root-price-list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemRootPriceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemRootPriceList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PriceList>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PriceList>;
        }));
    }

    protected processGetSystemRootPriceList(response: HttpResponseBase): Observable<PriceList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceList.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    clearAll(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/system/clear-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createRootMerchant(httpContext?: HttpContext): Observable<MerchantLight> {
        let url_ = this.baseUrl + "/api/v1/system/root-merchant";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRootMerchant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRootMerchant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MerchantLight>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MerchantLight>;
        }));
    }

    protected processCreateRootMerchant(response: HttpResponseBase): Observable<MerchantLight> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MerchantLight.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPaymentProfiles(httpContext?: HttpContext): Observable<PaymentProfile[]> {
        let url_ = this.baseUrl + "/api/v1/system/payment-profiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentProfiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentProfiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentProfile[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentProfile[]>;
        }));
    }

    protected processGetPaymentProfiles(response: HttpResponseBase): Observable<PaymentProfile[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentProfile.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createPaymentProfile(request: CreatePaymentProfileRequest, httpContext?: HttpContext): Observable<PaymentProfile> {
        let url_ = this.baseUrl + "/api/v1/system/payment-profiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaymentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaymentProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentProfile>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentProfile>;
        }));
    }

    protected processCreatePaymentProfile(response: HttpResponseBase): Observable<PaymentProfile> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentProfile.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updatePaymentProfile(paymentProfileId: number, request: UpdatePaymentProfileRequest, httpContext?: HttpContext): Observable<PaymentProfile> {
        let url_ = this.baseUrl + "/api/v1/system/payment-profiles?";
        if (paymentProfileId === undefined || paymentProfileId === null)
            throw new Error("The parameter 'paymentProfileId' must be defined and cannot be null.");
        else
            url_ += "paymentProfileId=" + encodeURIComponent("" + paymentProfileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePaymentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePaymentProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentProfile>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentProfile>;
        }));
    }

    protected processUpdatePaymentProfile(response: HttpResponseBase): Observable<PaymentProfile> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentProfile.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRootBranches(searchCriteria?: string | null | undefined, pageNumber?: number | null | undefined, pageSize?: number | null | undefined, httpContext?: HttpContext): Observable<BranchLight[]> {
        let url_ = this.baseUrl + "/api/v1/system/merchants?";
        if (searchCriteria !== undefined && searchCriteria !== null)
            url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRootBranches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRootBranches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BranchLight[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BranchLight[]>;
        }));
    }

    protected processGetRootBranches(response: HttpResponseBase): Observable<BranchLight[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BranchLight.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshPostPayInvoice(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/system/refresh-post-pay-invoice";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshPostPayInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshPostPayInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRefreshPostPayInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshPosOrderPaymentInstallmentState(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/system/refresh-poss-ordr-installment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshPosOrderPaymentInstallmentState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshPosOrderPaymentInstallmentState(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRefreshPosOrderPaymentInstallmentState(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TeamClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getMerchantsBranch(httpContext?: HttpContext): Observable<Branch[]> {
        let url_ = this.baseUrl + "/api/v1/team/users/current/branches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMerchantsBranch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMerchantsBranch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Branch[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Branch[]>;
        }));
    }

    protected processGetMerchantsBranch(response: HttpResponseBase): Observable<Branch[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Branch.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserRolesFull(resourceId: number, httpContext?: HttpContext): Observable<UserRole[]> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/user-roles-full";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRolesFull(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRolesFull(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRole[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRole[]>;
        }));
    }

    protected processGetUserRolesFull(response: HttpResponseBase): Observable<UserRole[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRole.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listCurrentUserResources(httpContext?: HttpContext): Observable<string[]> {
        let url_ = this.baseUrl + "/api/v1/team/users/current/resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCurrentUserResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCurrentUserResources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processListCurrentUserResources(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listCurrentUserPermissions(resourceId: string, httpContext?: HttpContext): Observable<string[]> {
        let url_ = this.baseUrl + "/api/v1/team/users/current/resources/{resourceId}/permissions";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListCurrentUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListCurrentUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processListCurrentUserPermissions(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetBotApiKey(userId: string, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/team/users/{userId}/bot/reset-api-key";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetBotApiKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetBotApiKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processResetBotApiKey(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateBot(userId: string, updateParam: TeamUpdateBotParam, httpContext?: HttpContext): Observable<User> {
        let url_ = this.baseUrl + "/api/v1/team/users/{userId}/bot";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParam);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUpdateBot(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listRoles(resourceId: string, httpContext?: HttpContext): Observable<Role[]> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role[]>;
        }));
    }

    protected processListRoles(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listUserRoles(resourceId: string, roleId?: string | null | undefined, userId?: string | null | undefined, search?: string | null | undefined, isBot?: boolean | null | undefined, recordIndex?: number | undefined, recordCount?: number | null | undefined, httpContext?: HttpContext): Observable<ListResultOfUserRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/user-roles?";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId !== undefined && roleId !== null)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (isBot !== undefined && isBot !== null)
            url_ += "isBot=" + encodeURIComponent("" + isBot) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount !== undefined && recordCount !== null)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultOfUserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultOfUserRole>;
        }));
    }

    protected processListUserRoles(response: HttpResponseBase): Observable<ListResultOfUserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultOfUserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUser(resourceId: string, userId: string, httpContext?: HttpContext): Observable<TeamUserOfUserAndUserRoleAndRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamUserOfUserAndUserRoleAndRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamUserOfUserAndUserRoleAndRole>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<TeamUserOfUserAndUserRoleAndRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamUserOfUserAndUserRoleAndRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserByEmail(resourceId: string, email: string, httpContext?: HttpContext): Observable<TeamUserOfUserAndUserRoleAndRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/users/email:{email}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TeamUserOfUserAndUserRoleAndRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TeamUserOfUserAndUserRoleAndRole>;
        }));
    }

    protected processGetUserByEmail(response: HttpResponseBase): Observable<TeamUserOfUserAndUserRoleAndRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TeamUserOfUserAndUserRoleAndRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addNewBot(resourceId: string, roleId: string, addParam: TeamAddBotParam, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/bots";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addParam);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewBot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewBot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processAddNewBot(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addUserByEmail(resourceId: string, roleId: string, email: string, addParam?: TeamAddEmailParam | undefined, httpContext?: HttpContext): Observable<UserRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/email:{email}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addParam);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserByEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRole>;
        }));
    }

    protected processAddUserByEmail(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addUser(resourceId: string, roleId: string, userId: string, httpContext?: HttpContext): Observable<UserRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRole>;
        }));
    }

    protected processAddUser(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeUser(resourceId: string, roleId: string, userId: string, httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createSystemApiKey(secret: string, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/team/system/api-key";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (secret === null || secret === undefined)
            throw new Error("The parameter 'secret' cannot be null.");
        else
            content_.append("secret", secret.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSystemApiKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSystemApiKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processCreateSystemApiKey(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WalletsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getWallet(branchId: number, httpContext?: HttpContext): Observable<Wallet> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/wallets/wallet";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Wallet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Wallet>;
        }));
    }

    protected processGetWallet(response: HttpResponseBase): Observable<Wallet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Wallet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCustomerWallet(branchId: number, customerMerchantId: number, httpContext?: HttpContext): Observable<Wallet> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/wallets/customer-wallet?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (customerMerchantId === undefined || customerMerchantId === null)
            throw new Error("The parameter 'customerMerchantId' must be defined and cannot be null.");
        else
            url_ += "customerMerchantId=" + encodeURIComponent("" + customerMerchantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerWallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerWallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Wallet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Wallet>;
        }));
    }

    protected processGetCustomerWallet(response: HttpResponseBase): Observable<Wallet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Wallet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWalletTransactions(branchId: number, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, subMerchantId?: number | null | undefined, transferWalletType?: TransferWalletType | null | undefined, currencyId?: number | null | undefined, pageSize?: number | null | undefined, pageNumber?: number | null | undefined, httpContext?: HttpContext): Observable<WalletTransaction[]> {
        let url_ = this.baseUrl + "/api/v1/branches/{branchId}/wallets/transactions?";
        if (branchId === undefined || branchId === null)
            throw new Error("The parameter 'branchId' must be defined.");
        url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (subMerchantId !== undefined && subMerchantId !== null)
            url_ += "subMerchantId=" + encodeURIComponent("" + subMerchantId) + "&";
        if (transferWalletType !== undefined && transferWalletType !== null)
            url_ += "transferWalletType=" + encodeURIComponent("" + transferWalletType) + "&";
        if (currencyId !== undefined && currencyId !== null)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWalletTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWalletTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WalletTransaction[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WalletTransaction[]>;
        }));
    }

    protected processGetWalletTransactions(response: HttpResponseBase): Observable<WalletTransaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WalletTransaction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    catchPaymentProviderWebhook(webhookKey: string, httpContext?: HttpContext): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/v1/webhooks/payment-provider-webhook?";
        if (webhookKey === undefined || webhookKey === null)
            throw new Error("The parameter 'webhookKey' must be defined and cannot be null.");
        else
            url_ += "webhookKey=" + encodeURIComponent("" + webhookKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCatchPaymentProviderWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCatchPaymentProviderWebhook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCatchPaymentProviderWebhook(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthenticationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getCurrentUser(httpContext?: HttpContext): Observable<User> {
        let url_ = this.baseUrl + "/api/v1/authentication/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processGetCurrentUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    signOutAll(httpContext?: HttpContext): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/authentication/current/signout-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOutAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOutAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSignOutAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetCurrentUserApiKey(httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/current/reset-api-key";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetCurrentUserApiKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetCurrentUserApiKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processResetCurrentUserApiKey(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    signIn(request: SignInRequest, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processSignIn(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    signUp(request: SignUpRequest, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignUp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignUp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processSignUp(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshToken(request: RefreshTokenRequest, httpContext?: HttpContext): Observable<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiKey>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiKey>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<ApiKey> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    googleSignInHandler(httpContext?: HttpContext): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/v1/authentication/external/google/signin-handler";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGoogleSignInHandler(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGoogleSignInHandler(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGoogleSignInHandler(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getGoogleSignInUrl(csrfToken: string, nonce?: string | null | undefined, httpContext?: HttpContext): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/authentication/external/google/signin-url?";
        if (csrfToken === undefined || csrfToken === null)
            throw new Error("The parameter 'csrfToken' must be defined and cannot be null.");
        else
            url_ += "csrfToken=" + encodeURIComponent("" + csrfToken) + "&";
        if (nonce !== undefined && nonce !== null)
            url_ += "nonce=" + encodeURIComponent("" + nonce) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: false,
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGoogleSignInUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGoogleSignInUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetGoogleSignInUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Bank implements IBank {
    bankId!: number;
    bankName!: string;

    constructor(data?: IBank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankId = _data["bankId"] !== undefined ? _data["bankId"] : <any>null;
            this.bankName = _data["bankName"] !== undefined ? _data["bankName"] : <any>null;
        }
    }

    static fromJS(data: any): Bank {
        data = typeof data === 'object' ? data : {};
        let result = new Bank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankId"] = this.bankId !== undefined ? this.bankId : <any>null;
        data["bankName"] = this.bankName !== undefined ? this.bankName : <any>null;
        return data;
    }
}

export interface IBank {
    bankId: number;
    bankName: string;
}

export class BranchLight implements IBranchLight {
    branchId!: number;
    branchName!: string;
    merchantId!: number;
    merchantName!: string;
    parentBranchId?: number | null;
    description?: string | null;
    isActive!: boolean;
    rootPriceListId?: number | null;
    canSetFaceValue!: boolean;
    canSetBuyValue!: boolean;
    canCreatePaymentOrder!: boolean;
    canPlaceOrder!: boolean;
    middlePriceList?: PriceListSummary | null;
    assignedPriceList?: PriceListSummary | null;
    merchant?: MerchantLight | null;

    constructor(data?: IBranchLight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.branchName = _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.merchantName = _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
            this.parentBranchId = _data["parentBranchId"] !== undefined ? _data["parentBranchId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.rootPriceListId = _data["rootPriceListId"] !== undefined ? _data["rootPriceListId"] : <any>null;
            this.canSetFaceValue = _data["canSetFaceValue"] !== undefined ? _data["canSetFaceValue"] : <any>null;
            this.canSetBuyValue = _data["canSetBuyValue"] !== undefined ? _data["canSetBuyValue"] : <any>null;
            this.canCreatePaymentOrder = _data["canCreatePaymentOrder"] !== undefined ? _data["canCreatePaymentOrder"] : <any>null;
            this.canPlaceOrder = _data["canPlaceOrder"] !== undefined ? _data["canPlaceOrder"] : <any>null;
            this.middlePriceList = _data["middlePriceList"] ? PriceListSummary.fromJS(_data["middlePriceList"]) : <any>null;
            this.assignedPriceList = _data["assignedPriceList"] ? PriceListSummary.fromJS(_data["assignedPriceList"]) : <any>null;
            this.merchant = _data["merchant"] ? MerchantLight.fromJS(_data["merchant"]) : <any>null;
        }
    }

    static fromJS(data: any): BranchLight {
        data = typeof data === 'object' ? data : {};
        let result = new BranchLight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["branchName"] = this.branchName !== undefined ? this.branchName : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["merchantName"] = this.merchantName !== undefined ? this.merchantName : <any>null;
        data["parentBranchId"] = this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["rootPriceListId"] = this.rootPriceListId !== undefined ? this.rootPriceListId : <any>null;
        data["canSetFaceValue"] = this.canSetFaceValue !== undefined ? this.canSetFaceValue : <any>null;
        data["canSetBuyValue"] = this.canSetBuyValue !== undefined ? this.canSetBuyValue : <any>null;
        data["canCreatePaymentOrder"] = this.canCreatePaymentOrder !== undefined ? this.canCreatePaymentOrder : <any>null;
        data["canPlaceOrder"] = this.canPlaceOrder !== undefined ? this.canPlaceOrder : <any>null;
        data["middlePriceList"] = this.middlePriceList ? this.middlePriceList.toJSON() : <any>null;
        data["assignedPriceList"] = this.assignedPriceList ? this.assignedPriceList.toJSON() : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        return data;
    }
}

export interface IBranchLight {
    branchId: number;
    branchName: string;
    merchantId: number;
    merchantName: string;
    parentBranchId?: number | null;
    description?: string | null;
    isActive: boolean;
    rootPriceListId?: number | null;
    canSetFaceValue: boolean;
    canSetBuyValue: boolean;
    canCreatePaymentOrder: boolean;
    canPlaceOrder: boolean;
    middlePriceList?: PriceListSummary | null;
    assignedPriceList?: PriceListSummary | null;
    merchant?: MerchantLight | null;
}

export class PriceListSummary implements IPriceListSummary {
    priceListId!: number;
    priceListName?: string | null;

    constructor(data?: IPriceListSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.priceListId = _data["priceListId"] !== undefined ? _data["priceListId"] : <any>null;
            this.priceListName = _data["priceListName"] !== undefined ? _data["priceListName"] : <any>null;
        }
    }

    static fromJS(data: any): PriceListSummary {
        data = typeof data === 'object' ? data : {};
        let result = new PriceListSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceListId"] = this.priceListId !== undefined ? this.priceListId : <any>null;
        data["priceListName"] = this.priceListName !== undefined ? this.priceListName : <any>null;
        return data;
    }
}

export interface IPriceListSummary {
    priceListId: number;
    priceListName?: string | null;
}

export class MerchantLight implements IMerchantLight {
    merchantId!: number;
    merchantName!: string;
    parentBranchId?: number | null;
    rootBranchId?: number | null;
    description?: string | null;
    isActive!: boolean;
    email!: string;
    walletId!: number;
    creditWalletId?: number | null;
    externalReference!: string;
    exchangeTargetCurrency!: Currency;
    saleManager?: SaleManagerSummary | null;
    invoiceThresholdDay?: number | null;

    constructor(data?: IMerchantLight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.exchangeTargetCurrency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.merchantName = _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
            this.parentBranchId = _data["parentBranchId"] !== undefined ? _data["parentBranchId"] : <any>null;
            this.rootBranchId = _data["rootBranchId"] !== undefined ? _data["rootBranchId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.walletId = _data["walletId"] !== undefined ? _data["walletId"] : <any>null;
            this.creditWalletId = _data["creditWalletId"] !== undefined ? _data["creditWalletId"] : <any>null;
            this.externalReference = _data["externalReference"] !== undefined ? _data["externalReference"] : <any>null;
            this.exchangeTargetCurrency = _data["exchangeTargetCurrency"] ? Currency.fromJS(_data["exchangeTargetCurrency"]) : new Currency();
            this.saleManager = _data["saleManager"] ? SaleManagerSummary.fromJS(_data["saleManager"]) : <any>null;
            this.invoiceThresholdDay = _data["invoiceThresholdDay"] !== undefined ? _data["invoiceThresholdDay"] : <any>null;
        }
    }

    static fromJS(data: any): MerchantLight {
        data = typeof data === 'object' ? data : {};
        let result = new MerchantLight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["merchantName"] = this.merchantName !== undefined ? this.merchantName : <any>null;
        data["parentBranchId"] = this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
        data["rootBranchId"] = this.rootBranchId !== undefined ? this.rootBranchId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
        data["creditWalletId"] = this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
        data["externalReference"] = this.externalReference !== undefined ? this.externalReference : <any>null;
        data["exchangeTargetCurrency"] = this.exchangeTargetCurrency ? this.exchangeTargetCurrency.toJSON() : <any>null;
        data["saleManager"] = this.saleManager ? this.saleManager.toJSON() : <any>null;
        data["invoiceThresholdDay"] = this.invoiceThresholdDay !== undefined ? this.invoiceThresholdDay : <any>null;
        return data;
    }
}

export interface IMerchantLight {
    merchantId: number;
    merchantName: string;
    parentBranchId?: number | null;
    rootBranchId?: number | null;
    description?: string | null;
    isActive: boolean;
    email: string;
    walletId: number;
    creditWalletId?: number | null;
    externalReference: string;
    exchangeTargetCurrency: Currency;
    saleManager?: SaleManagerSummary | null;
    invoiceThresholdDay?: number | null;
}

export class Currency implements ICurrency {
    currencyId!: number;
    currencyName!: string;
    symbol?: string | null;
    isForTest?: boolean | null;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.currencyName = _data["currencyName"] !== undefined ? _data["currencyName"] : <any>null;
            this.symbol = _data["symbol"] !== undefined ? _data["symbol"] : <any>null;
            this.isForTest = _data["isForTest"] !== undefined ? _data["isForTest"] : <any>null;
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["currencyName"] = this.currencyName !== undefined ? this.currencyName : <any>null;
        data["symbol"] = this.symbol !== undefined ? this.symbol : <any>null;
        data["isForTest"] = this.isForTest !== undefined ? this.isForTest : <any>null;
        return data;
    }
}

export interface ICurrency {
    currencyId: number;
    currencyName: string;
    symbol?: string | null;
    isForTest?: boolean | null;
}

export class SaleManagerSummary implements ISaleManagerSummary {
    saleManagerId!: number;
    name?: string | null;

    constructor(data?: ISaleManagerSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saleManagerId = _data["saleManagerId"] !== undefined ? _data["saleManagerId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): SaleManagerSummary {
        data = typeof data === 'object' ? data : {};
        let result = new SaleManagerSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleManagerId"] = this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ISaleManagerSummary {
    saleManagerId: number;
    name?: string | null;
}

export class UserPin implements IUserPin {
    userPinId!: number;
    branchId!: number;
    userId!: string;
    pin!: string;

    constructor(data?: IUserPin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userPinId = _data["userPinId"] !== undefined ? _data["userPinId"] : <any>null;
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.pin = _data["pin"] !== undefined ? _data["pin"] : <any>null;
        }
    }

    static fromJS(data: any): UserPin {
        data = typeof data === 'object' ? data : {};
        let result = new UserPin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userPinId"] = this.userPinId !== undefined ? this.userPinId : <any>null;
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["pin"] = this.pin !== undefined ? this.pin : <any>null;
        return data;
    }
}

export interface IUserPin {
    userPinId: number;
    branchId: number;
    userId: string;
    pin: string;
}

export class Branch implements IBranch {
    branchId!: number;
    branchName!: string;
    merchantId!: number;
    merchantName!: string;
    parentBranchId?: number | null;
    description?: string | null;
    isActive!: boolean;
    rootPriceListId?: number | null;
    canSetFaceValue!: boolean;
    canSetBuyValue!: boolean;
    canCreatePaymentOrder!: boolean;
    canPlaceOrder!: boolean;
    canActivatePostPayForSubMerchant!: boolean;
    canCreateGatewayList!: boolean;
    middlePriceList?: PriceListSummary | null;
    assignedPriceList?: PriceListSummary | null;
    merchant?: Merchant | null;

    constructor(data?: IBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.branchName = _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.merchantName = _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
            this.parentBranchId = _data["parentBranchId"] !== undefined ? _data["parentBranchId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.rootPriceListId = _data["rootPriceListId"] !== undefined ? _data["rootPriceListId"] : <any>null;
            this.canSetFaceValue = _data["canSetFaceValue"] !== undefined ? _data["canSetFaceValue"] : <any>null;
            this.canSetBuyValue = _data["canSetBuyValue"] !== undefined ? _data["canSetBuyValue"] : <any>null;
            this.canCreatePaymentOrder = _data["canCreatePaymentOrder"] !== undefined ? _data["canCreatePaymentOrder"] : <any>null;
            this.canPlaceOrder = _data["canPlaceOrder"] !== undefined ? _data["canPlaceOrder"] : <any>null;
            this.canActivatePostPayForSubMerchant = _data["canActivatePostPayForSubMerchant"] !== undefined ? _data["canActivatePostPayForSubMerchant"] : <any>null;
            this.canCreateGatewayList = _data["canCreateGatewayList"] !== undefined ? _data["canCreateGatewayList"] : <any>null;
            this.middlePriceList = _data["middlePriceList"] ? PriceListSummary.fromJS(_data["middlePriceList"]) : <any>null;
            this.assignedPriceList = _data["assignedPriceList"] ? PriceListSummary.fromJS(_data["assignedPriceList"]) : <any>null;
            this.merchant = _data["merchant"] ? Merchant.fromJS(_data["merchant"]) : <any>null;
        }
    }

    static fromJS(data: any): Branch {
        data = typeof data === 'object' ? data : {};
        let result = new Branch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["branchName"] = this.branchName !== undefined ? this.branchName : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["merchantName"] = this.merchantName !== undefined ? this.merchantName : <any>null;
        data["parentBranchId"] = this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["rootPriceListId"] = this.rootPriceListId !== undefined ? this.rootPriceListId : <any>null;
        data["canSetFaceValue"] = this.canSetFaceValue !== undefined ? this.canSetFaceValue : <any>null;
        data["canSetBuyValue"] = this.canSetBuyValue !== undefined ? this.canSetBuyValue : <any>null;
        data["canCreatePaymentOrder"] = this.canCreatePaymentOrder !== undefined ? this.canCreatePaymentOrder : <any>null;
        data["canPlaceOrder"] = this.canPlaceOrder !== undefined ? this.canPlaceOrder : <any>null;
        data["canActivatePostPayForSubMerchant"] = this.canActivatePostPayForSubMerchant !== undefined ? this.canActivatePostPayForSubMerchant : <any>null;
        data["canCreateGatewayList"] = this.canCreateGatewayList !== undefined ? this.canCreateGatewayList : <any>null;
        data["middlePriceList"] = this.middlePriceList ? this.middlePriceList.toJSON() : <any>null;
        data["assignedPriceList"] = this.assignedPriceList ? this.assignedPriceList.toJSON() : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        return data;
    }
}

export interface IBranch {
    branchId: number;
    branchName: string;
    merchantId: number;
    merchantName: string;
    parentBranchId?: number | null;
    description?: string | null;
    isActive: boolean;
    rootPriceListId?: number | null;
    canSetFaceValue: boolean;
    canSetBuyValue: boolean;
    canCreatePaymentOrder: boolean;
    canPlaceOrder: boolean;
    canActivatePostPayForSubMerchant: boolean;
    canCreateGatewayList: boolean;
    middlePriceList?: PriceListSummary | null;
    assignedPriceList?: PriceListSummary | null;
    merchant?: Merchant | null;
}

export class Merchant implements IMerchant {
    merchantId!: number;
    merchantName!: string;
    parentBranchId?: number | null;
    rootBranchId!: number;
    description?: string | null;
    isActive!: boolean;
    email!: string;
    phoneNumber?: Phone | null;
    whatsappNumber?: Phone | null;
    address?: MerchantAddress | null;
    website?: string | null;
    walletId!: number;
    financialActivitiesTwoPhaseVerification!: boolean;
    creditWalletId?: number | null;
    externalReference!: string;
    postPayAchPaymentMethodProviderProfileId?: number | null;
    isActivePostPay!: boolean;
    isActive2Fa!: boolean;
    isActivePin!: boolean;
    exchangeTargetCurrency!: Currency;
    saleManager?: SaleManagerSummary | null;
    assignedGatewayList?: GatewayListSummary | null;
    invoiceThresholdDay?: number | null;
    timeZone?: string | null;

    constructor(data?: IMerchant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.exchangeTargetCurrency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.merchantName = _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
            this.parentBranchId = _data["parentBranchId"] !== undefined ? _data["parentBranchId"] : <any>null;
            this.rootBranchId = _data["rootBranchId"] !== undefined ? _data["rootBranchId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] ? Phone.fromJS(_data["phoneNumber"]) : <any>null;
            this.whatsappNumber = _data["whatsappNumber"] ? Phone.fromJS(_data["whatsappNumber"]) : <any>null;
            this.address = _data["address"] ? MerchantAddress.fromJS(_data["address"]) : <any>null;
            this.website = _data["website"] !== undefined ? _data["website"] : <any>null;
            this.walletId = _data["walletId"] !== undefined ? _data["walletId"] : <any>null;
            this.financialActivitiesTwoPhaseVerification = _data["financialActivitiesTwoPhaseVerification"] !== undefined ? _data["financialActivitiesTwoPhaseVerification"] : <any>null;
            this.creditWalletId = _data["creditWalletId"] !== undefined ? _data["creditWalletId"] : <any>null;
            this.externalReference = _data["externalReference"] !== undefined ? _data["externalReference"] : <any>null;
            this.postPayAchPaymentMethodProviderProfileId = _data["postPayAchPaymentMethodProviderProfileId"] !== undefined ? _data["postPayAchPaymentMethodProviderProfileId"] : <any>null;
            this.isActivePostPay = _data["isActivePostPay"] !== undefined ? _data["isActivePostPay"] : <any>null;
            this.isActive2Fa = _data["isActive2Fa"] !== undefined ? _data["isActive2Fa"] : <any>null;
            this.isActivePin = _data["isActivePin"] !== undefined ? _data["isActivePin"] : <any>null;
            this.exchangeTargetCurrency = _data["exchangeTargetCurrency"] ? Currency.fromJS(_data["exchangeTargetCurrency"]) : new Currency();
            this.saleManager = _data["saleManager"] ? SaleManagerSummary.fromJS(_data["saleManager"]) : <any>null;
            this.assignedGatewayList = _data["assignedGatewayList"] ? GatewayListSummary.fromJS(_data["assignedGatewayList"]) : <any>null;
            this.invoiceThresholdDay = _data["invoiceThresholdDay"] !== undefined ? _data["invoiceThresholdDay"] : <any>null;
            this.timeZone = _data["timeZone"] !== undefined ? _data["timeZone"] : <any>null;
        }
    }

    static fromJS(data: any): Merchant {
        data = typeof data === 'object' ? data : {};
        let result = new Merchant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["merchantName"] = this.merchantName !== undefined ? this.merchantName : <any>null;
        data["parentBranchId"] = this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
        data["rootBranchId"] = this.rootBranchId !== undefined ? this.rootBranchId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>null;
        data["whatsappNumber"] = this.whatsappNumber ? this.whatsappNumber.toJSON() : <any>null;
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
        data["financialActivitiesTwoPhaseVerification"] = this.financialActivitiesTwoPhaseVerification !== undefined ? this.financialActivitiesTwoPhaseVerification : <any>null;
        data["creditWalletId"] = this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
        data["externalReference"] = this.externalReference !== undefined ? this.externalReference : <any>null;
        data["postPayAchPaymentMethodProviderProfileId"] = this.postPayAchPaymentMethodProviderProfileId !== undefined ? this.postPayAchPaymentMethodProviderProfileId : <any>null;
        data["isActivePostPay"] = this.isActivePostPay !== undefined ? this.isActivePostPay : <any>null;
        data["isActive2Fa"] = this.isActive2Fa !== undefined ? this.isActive2Fa : <any>null;
        data["isActivePin"] = this.isActivePin !== undefined ? this.isActivePin : <any>null;
        data["exchangeTargetCurrency"] = this.exchangeTargetCurrency ? this.exchangeTargetCurrency.toJSON() : <any>null;
        data["saleManager"] = this.saleManager ? this.saleManager.toJSON() : <any>null;
        data["assignedGatewayList"] = this.assignedGatewayList ? this.assignedGatewayList.toJSON() : <any>null;
        data["invoiceThresholdDay"] = this.invoiceThresholdDay !== undefined ? this.invoiceThresholdDay : <any>null;
        data["timeZone"] = this.timeZone !== undefined ? this.timeZone : <any>null;
        return data;
    }
}

export interface IMerchant {
    merchantId: number;
    merchantName: string;
    parentBranchId?: number | null;
    rootBranchId: number;
    description?: string | null;
    isActive: boolean;
    email: string;
    phoneNumber?: Phone | null;
    whatsappNumber?: Phone | null;
    address?: MerchantAddress | null;
    website?: string | null;
    walletId: number;
    financialActivitiesTwoPhaseVerification: boolean;
    creditWalletId?: number | null;
    externalReference: string;
    postPayAchPaymentMethodProviderProfileId?: number | null;
    isActivePostPay: boolean;
    isActive2Fa: boolean;
    isActivePin: boolean;
    exchangeTargetCurrency: Currency;
    saleManager?: SaleManagerSummary | null;
    assignedGatewayList?: GatewayListSummary | null;
    invoiceThresholdDay?: number | null;
    timeZone?: string | null;
}

export class Phone implements IPhone {
    countryCode!: string;
    number!: string;

    constructor(data?: IPhone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryCode = _data["countryCode"] !== undefined ? _data["countryCode"] : <any>null;
            this.number = _data["number"] !== undefined ? _data["number"] : <any>null;
        }
    }

    static fromJS(data: any): Phone {
        data = typeof data === 'object' ? data : {};
        let result = new Phone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode !== undefined ? this.countryCode : <any>null;
        data["number"] = this.number !== undefined ? this.number : <any>null;
        return data;
    }
}

export interface IPhone {
    countryCode: string;
    number: string;
}

export class MerchantAddress implements IMerchantAddress {
    country?: string | null;
    state?: string | null;
    city?: string | null;
    rawAddress?: string | null;
    postalCode?: string | null;

    constructor(data?: IMerchantAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.country = _data["country"] !== undefined ? _data["country"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.rawAddress = _data["rawAddress"] !== undefined ? _data["rawAddress"] : <any>null;
            this.postalCode = _data["postalCode"] !== undefined ? _data["postalCode"] : <any>null;
        }
    }

    static fromJS(data: any): MerchantAddress {
        data = typeof data === 'object' ? data : {};
        let result = new MerchantAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["rawAddress"] = this.rawAddress !== undefined ? this.rawAddress : <any>null;
        data["postalCode"] = this.postalCode !== undefined ? this.postalCode : <any>null;
        return data;
    }
}

export interface IMerchantAddress {
    country?: string | null;
    state?: string | null;
    city?: string | null;
    rawAddress?: string | null;
    postalCode?: string | null;
}

export class GatewayListSummary implements IGatewayListSummary {
    gatewayListId!: number;
    name!: string;

    constructor(data?: IGatewayListSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayListId = _data["gatewayListId"] !== undefined ? _data["gatewayListId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): GatewayListSummary {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayListSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayListId"] = this.gatewayListId !== undefined ? this.gatewayListId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface IGatewayListSummary {
    gatewayListId: number;
    name: string;
}

export class BuyOrder implements IBuyOrder {
    buyOrderId!: number;
    buyOrderExternalId!: string;
    productId!: number;
    productName!: string;
    isPhysicalProduct!: boolean;
    quantity!: number;
    faceValue!: number;
    buyOrderState!: BuyOrderState;
    sellerMerchant!: MerchantSummary;
    buyerMerchant!: MerchantSummary;
    buyOrderDelivery?: BuyOrderDelivery | null;
    saleManager?: SaleManagerSummary | null;
    totalBuyAmount!: number;
    unitBuyAmount!: number;
    profit?: number | null;
    productCurrency!: Currency;
    buyCurrency!: Currency;
    createdTime!: Date;
    canDownloadCodes!: boolean;
    exchangeCalc?: ExchangeCalc | null;
    createdByUserId!: string;

    constructor(data?: IBuyOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sellerMerchant = new MerchantSummary();
            this.buyerMerchant = new MerchantSummary();
            this.productCurrency = new Currency();
            this.buyCurrency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.buyOrderId = _data["buyOrderId"] !== undefined ? _data["buyOrderId"] : <any>null;
            this.buyOrderExternalId = _data["buyOrderExternalId"] !== undefined ? _data["buyOrderExternalId"] : <any>null;
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
            this.productName = _data["productName"] !== undefined ? _data["productName"] : <any>null;
            this.isPhysicalProduct = _data["isPhysicalProduct"] !== undefined ? _data["isPhysicalProduct"] : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.faceValue = _data["faceValue"] !== undefined ? _data["faceValue"] : <any>null;
            this.buyOrderState = _data["buyOrderState"] !== undefined ? _data["buyOrderState"] : <any>null;
            this.sellerMerchant = _data["sellerMerchant"] ? MerchantSummary.fromJS(_data["sellerMerchant"]) : new MerchantSummary();
            this.buyerMerchant = _data["buyerMerchant"] ? MerchantSummary.fromJS(_data["buyerMerchant"]) : new MerchantSummary();
            this.buyOrderDelivery = _data["buyOrderDelivery"] ? BuyOrderDelivery.fromJS(_data["buyOrderDelivery"]) : <any>null;
            this.saleManager = _data["saleManager"] ? SaleManagerSummary.fromJS(_data["saleManager"]) : <any>null;
            this.totalBuyAmount = _data["totalBuyAmount"] !== undefined ? _data["totalBuyAmount"] : <any>null;
            this.unitBuyAmount = _data["unitBuyAmount"] !== undefined ? _data["unitBuyAmount"] : <any>null;
            this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
            this.productCurrency = _data["productCurrency"] ? Currency.fromJS(_data["productCurrency"]) : new Currency();
            this.buyCurrency = _data["buyCurrency"] ? Currency.fromJS(_data["buyCurrency"]) : new Currency();
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.canDownloadCodes = _data["canDownloadCodes"] !== undefined ? _data["canDownloadCodes"] : <any>null;
            this.exchangeCalc = _data["exchangeCalc"] ? ExchangeCalc.fromJS(_data["exchangeCalc"]) : <any>null;
            this.createdByUserId = _data["createdByUserId"] !== undefined ? _data["createdByUserId"] : <any>null;
        }
    }

    static fromJS(data: any): BuyOrder {
        data = typeof data === 'object' ? data : {};
        let result = new BuyOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buyOrderId"] = this.buyOrderId !== undefined ? this.buyOrderId : <any>null;
        data["buyOrderExternalId"] = this.buyOrderExternalId !== undefined ? this.buyOrderExternalId : <any>null;
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        data["productName"] = this.productName !== undefined ? this.productName : <any>null;
        data["isPhysicalProduct"] = this.isPhysicalProduct !== undefined ? this.isPhysicalProduct : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["faceValue"] = this.faceValue !== undefined ? this.faceValue : <any>null;
        data["buyOrderState"] = this.buyOrderState !== undefined ? this.buyOrderState : <any>null;
        data["sellerMerchant"] = this.sellerMerchant ? this.sellerMerchant.toJSON() : <any>null;
        data["buyerMerchant"] = this.buyerMerchant ? this.buyerMerchant.toJSON() : <any>null;
        data["buyOrderDelivery"] = this.buyOrderDelivery ? this.buyOrderDelivery.toJSON() : <any>null;
        data["saleManager"] = this.saleManager ? this.saleManager.toJSON() : <any>null;
        data["totalBuyAmount"] = this.totalBuyAmount !== undefined ? this.totalBuyAmount : <any>null;
        data["unitBuyAmount"] = this.unitBuyAmount !== undefined ? this.unitBuyAmount : <any>null;
        data["profit"] = this.profit !== undefined ? this.profit : <any>null;
        data["productCurrency"] = this.productCurrency ? this.productCurrency.toJSON() : <any>null;
        data["buyCurrency"] = this.buyCurrency ? this.buyCurrency.toJSON() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["canDownloadCodes"] = this.canDownloadCodes !== undefined ? this.canDownloadCodes : <any>null;
        data["exchangeCalc"] = this.exchangeCalc ? this.exchangeCalc.toJSON() : <any>null;
        data["createdByUserId"] = this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
        return data;
    }
}

export interface IBuyOrder {
    buyOrderId: number;
    buyOrderExternalId: string;
    productId: number;
    productName: string;
    isPhysicalProduct: boolean;
    quantity: number;
    faceValue: number;
    buyOrderState: BuyOrderState;
    sellerMerchant: MerchantSummary;
    buyerMerchant: MerchantSummary;
    buyOrderDelivery?: BuyOrderDelivery | null;
    saleManager?: SaleManagerSummary | null;
    totalBuyAmount: number;
    unitBuyAmount: number;
    profit?: number | null;
    productCurrency: Currency;
    buyCurrency: Currency;
    createdTime: Date;
    canDownloadCodes: boolean;
    exchangeCalc?: ExchangeCalc | null;
    createdByUserId: string;
}

export enum BuyOrderState {
    Reserved = "Reserved",
    Created = "Created",
    CreateStockOrder = "CreateStockOrder",
    AuthWallet = "AuthWallet",
    Failed = "Failed",
    Complete = "Complete",
    CancelAuthWallet = "CancelAuthWallet",
    CompleteStockOrder = "CompleteStockOrder",
    CreateActivatePhysicalCardOrder = "CreateActivatePhysicalCardOrder",
    CompleteActivatePhysicalCardOrder = "CompleteActivatePhysicalCardOrder",
}

export class MerchantSummary implements IMerchantSummary {
    merchantId!: number;
    merchantName!: string;
    saleManager?: SaleManagerSummary | null;

    constructor(data?: IMerchantSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.merchantName = _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
            this.saleManager = _data["saleManager"] ? SaleManagerSummary.fromJS(_data["saleManager"]) : <any>null;
        }
    }

    static fromJS(data: any): MerchantSummary {
        data = typeof data === 'object' ? data : {};
        let result = new MerchantSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["merchantName"] = this.merchantName !== undefined ? this.merchantName : <any>null;
        data["saleManager"] = this.saleManager ? this.saleManager.toJSON() : <any>null;
        return data;
    }
}

export interface IMerchantSummary {
    merchantId: number;
    merchantName: string;
    saleManager?: SaleManagerSummary | null;
}

export class BuyOrderDelivery implements IBuyOrderDelivery {
    deliveryType!: BuyOrderDeliveryType;
    deliveryTypeValue?: string | null;
    deliveredTime?: Date | null;

    constructor(data?: IBuyOrderDelivery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deliveryType = _data["deliveryType"] !== undefined ? _data["deliveryType"] : <any>null;
            this.deliveryTypeValue = _data["deliveryTypeValue"] !== undefined ? _data["deliveryTypeValue"] : <any>null;
            this.deliveredTime = _data["deliveredTime"] ? new Date(_data["deliveredTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): BuyOrderDelivery {
        data = typeof data === 'object' ? data : {};
        let result = new BuyOrderDelivery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryType"] = this.deliveryType !== undefined ? this.deliveryType : <any>null;
        data["deliveryTypeValue"] = this.deliveryTypeValue !== undefined ? this.deliveryTypeValue : <any>null;
        data["deliveredTime"] = this.deliveredTime ? this.deliveredTime.toISOString() : <any>null;
        return data;
    }
}

export interface IBuyOrderDelivery {
    deliveryType: BuyOrderDeliveryType;
    deliveryTypeValue?: string | null;
    deliveredTime?: Date | null;
}

export enum BuyOrderDeliveryType {
    Email = "Email",
    Sms = "Sms",
    WhatsApp = "WhatsApp",
}

export class ExchangeCalc implements IExchangeCalc {
    baseCurrency!: Currency;
    baseAmount!: number;
    targetCurrency!: Currency;
    targetAmount!: number;
    exchangeRate!: number;

    constructor(data?: IExchangeCalc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.baseCurrency = new Currency();
            this.targetCurrency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseCurrency = _data["baseCurrency"] ? Currency.fromJS(_data["baseCurrency"]) : new Currency();
            this.baseAmount = _data["baseAmount"] !== undefined ? _data["baseAmount"] : <any>null;
            this.targetCurrency = _data["targetCurrency"] ? Currency.fromJS(_data["targetCurrency"]) : new Currency();
            this.targetAmount = _data["targetAmount"] !== undefined ? _data["targetAmount"] : <any>null;
            this.exchangeRate = _data["exchangeRate"] !== undefined ? _data["exchangeRate"] : <any>null;
        }
    }

    static fromJS(data: any): ExchangeCalc {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeCalc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseCurrency"] = this.baseCurrency ? this.baseCurrency.toJSON() : <any>null;
        data["baseAmount"] = this.baseAmount !== undefined ? this.baseAmount : <any>null;
        data["targetCurrency"] = this.targetCurrency ? this.targetCurrency.toJSON() : <any>null;
        data["targetAmount"] = this.targetAmount !== undefined ? this.targetAmount : <any>null;
        data["exchangeRate"] = this.exchangeRate !== undefined ? this.exchangeRate : <any>null;
        return data;
    }
}

export interface IExchangeCalc {
    baseCurrency: Currency;
    baseAmount: number;
    targetCurrency: Currency;
    targetAmount: number;
    exchangeRate: number;
}

export class SaleBranches implements ISaleBranches {
    branchId!: number;
    currencyId!: number;
    currencyName!: string;
    branchName!: string;
    saleAmount!: number;

    constructor(data?: ISaleBranches) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.currencyName = _data["currencyName"] !== undefined ? _data["currencyName"] : <any>null;
            this.branchName = _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
            this.saleAmount = _data["saleAmount"] !== undefined ? _data["saleAmount"] : <any>null;
        }
    }

    static fromJS(data: any): SaleBranches {
        data = typeof data === 'object' ? data : {};
        let result = new SaleBranches();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["currencyName"] = this.currencyName !== undefined ? this.currencyName : <any>null;
        data["branchName"] = this.branchName !== undefined ? this.branchName : <any>null;
        data["saleAmount"] = this.saleAmount !== undefined ? this.saleAmount : <any>null;
        return data;
    }
}

export interface ISaleBranches {
    branchId: number;
    currencyId: number;
    currencyName: string;
    branchName: string;
    saleAmount: number;
}

export class SaleReturnOrder implements ISaleReturnOrder {
    rollBackOrderId!: number;
    buyOrder?: BuyOrderSummary | null;
    state!: SaleReturnOrderState;
    createdTime!: Date;
    modifiedTime!: Date;

    constructor(data?: ISaleReturnOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rollBackOrderId = _data["rollBackOrderId"] !== undefined ? _data["rollBackOrderId"] : <any>null;
            this.buyOrder = _data["buyOrder"] ? BuyOrderSummary.fromJS(_data["buyOrder"]) : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): SaleReturnOrder {
        data = typeof data === 'object' ? data : {};
        let result = new SaleReturnOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rollBackOrderId"] = this.rollBackOrderId !== undefined ? this.rollBackOrderId : <any>null;
        data["buyOrder"] = this.buyOrder ? this.buyOrder.toJSON() : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        return data;
    }
}

export interface ISaleReturnOrder {
    rollBackOrderId: number;
    buyOrder?: BuyOrderSummary | null;
    state: SaleReturnOrderState;
    createdTime: Date;
    modifiedTime: Date;
}

export class BuyOrderSummary implements IBuyOrderSummary {
    buyOrderId!: number;
    merchantId!: number;
    buyOrderExternalId!: string;
    buyOrderState!: BuyOrderState;

    constructor(data?: IBuyOrderSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.buyOrderId = _data["buyOrderId"] !== undefined ? _data["buyOrderId"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.buyOrderExternalId = _data["buyOrderExternalId"] !== undefined ? _data["buyOrderExternalId"] : <any>null;
            this.buyOrderState = _data["buyOrderState"] !== undefined ? _data["buyOrderState"] : <any>null;
        }
    }

    static fromJS(data: any): BuyOrderSummary {
        data = typeof data === 'object' ? data : {};
        let result = new BuyOrderSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buyOrderId"] = this.buyOrderId !== undefined ? this.buyOrderId : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["buyOrderExternalId"] = this.buyOrderExternalId !== undefined ? this.buyOrderExternalId : <any>null;
        data["buyOrderState"] = this.buyOrderState !== undefined ? this.buyOrderState : <any>null;
        return data;
    }
}

export interface IBuyOrderSummary {
    buyOrderId: number;
    merchantId: number;
    buyOrderExternalId: string;
    buyOrderState: BuyOrderState;
}

export enum SaleReturnOrderState {
    Reserved = "Reserved",
    Created = "Created",
    CancelStockOrder = "CancelStockOrder",
    CompleteCancelStockOrder = "CompleteCancelStockOrder",
    VoidWallet = "VoidWallet",
    Failed = "Failed",
}

export class Category implements ICategory {
    categoryId!: number;
    categoryName!: string;
    imageUrl?: string | null;
    parentCategoryId?: number | null;
    categories!: Category[];

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.categories = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.parentCategoryId = _data["parentCategoryId"] !== undefined ? _data["parentCategoryId"] : <any>null;
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(Category.fromJS(item));
            }
            else {
                this.categories = <any>null;
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["parentCategoryId"] = this.parentCategoryId !== undefined ? this.parentCategoryId : <any>null;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategory {
    categoryId: number;
    categoryName: string;
    imageUrl?: string | null;
    parentCategoryId?: number | null;
    categories: Category[];
}

export class CreateCategoryRequest implements ICreateCategoryRequest {
    parentCategoryId!: number;
    categoryName!: string;
    imageUrl?: string | null;

    constructor(data?: ICreateCategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentCategoryId = _data["parentCategoryId"] !== undefined ? _data["parentCategoryId"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): CreateCategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentCategoryId"] = this.parentCategoryId !== undefined ? this.parentCategoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export interface ICreateCategoryRequest {
    parentCategoryId: number;
    categoryName: string;
    imageUrl?: string | null;
}

export class UpdateCategoryRequest implements IUpdateCategoryRequest {
    categoryName?: PatchOfString | null;
    imageUrl?: PatchOfUri | null;

    constructor(data?: IUpdateCategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryName = _data["categoryName"] ? PatchOfString.fromJS(_data["categoryName"]) : <any>null;
            this.imageUrl = _data["imageUrl"] ? PatchOfUri.fromJS(_data["imageUrl"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateCategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryName"] = this.categoryName ? this.categoryName.toJSON() : <any>null;
        data["imageUrl"] = this.imageUrl ? this.imageUrl.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateCategoryRequest {
    categoryName?: PatchOfString | null;
    imageUrl?: PatchOfUri | null;
}

export class PatchOfString implements IPatchOfString {
    value?: string | null;

    constructor(data?: IPatchOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfString {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfString {
    value?: string | null;
}

export class PatchOfUri implements IPatchOfUri {
    value?: string | null;

    constructor(data?: IPatchOfUri) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfUri {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfUri();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfUri {
    value?: string | null;
}

export class Wallet implements IWallet {
    walletId!: number;
    currencies?: CurrencyBalance[] | null;

    constructor(data?: IWallet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletId = _data["walletId"] !== undefined ? _data["walletId"] : <any>null;
            if (Array.isArray(_data["currencies"])) {
                this.currencies = [] as any;
                for (let item of _data["currencies"])
                    this.currencies!.push(CurrencyBalance.fromJS(item));
            }
            else {
                this.currencies = <any>null;
            }
        }
    }

    static fromJS(data: any): Wallet {
        data = typeof data === 'object' ? data : {};
        let result = new Wallet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
        if (Array.isArray(this.currencies)) {
            data["currencies"] = [];
            for (let item of this.currencies)
                data["currencies"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWallet {
    walletId: number;
    currencies?: CurrencyBalance[] | null;
}

export class CurrencyBalance implements ICurrencyBalance {
    balance!: number;
    minBalance!: number;
    currency!: Currency;

    constructor(data?: ICurrencyBalance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.balance = _data["balance"] !== undefined ? _data["balance"] : <any>null;
            this.minBalance = _data["minBalance"] !== undefined ? _data["minBalance"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
        }
    }

    static fromJS(data: any): CurrencyBalance {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyBalance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["minBalance"] = this.minBalance !== undefined ? this.minBalance : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        return data;
    }
}

export interface ICurrencyBalance {
    balance: number;
    minBalance: number;
    currency: Currency;
}

export class WalletTransaction implements IWalletTransaction {
    supplierMerchant!: MerchantSummary;
    receiverMerchant!: MerchantSummary;
    amount!: number;
    currency!: Currency;
    bank?: Bank | null;
    createdTime!: Date;
    transferWalletType!: TransferWalletType;
    transferWalletState!: TransferWalletState;
    referenceNumber!: number;
    createdByUserId?: string | null;
    createdByUserEmail?: string | null;

    constructor(data?: IWalletTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.supplierMerchant = new MerchantSummary();
            this.receiverMerchant = new MerchantSummary();
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierMerchant = _data["supplierMerchant"] ? MerchantSummary.fromJS(_data["supplierMerchant"]) : new MerchantSummary();
            this.receiverMerchant = _data["receiverMerchant"] ? MerchantSummary.fromJS(_data["receiverMerchant"]) : new MerchantSummary();
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.bank = _data["bank"] ? Bank.fromJS(_data["bank"]) : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.transferWalletType = _data["transferWalletType"] !== undefined ? _data["transferWalletType"] : <any>null;
            this.transferWalletState = _data["transferWalletState"] !== undefined ? _data["transferWalletState"] : <any>null;
            this.referenceNumber = _data["referenceNumber"] !== undefined ? _data["referenceNumber"] : <any>null;
            this.createdByUserId = _data["createdByUserId"] !== undefined ? _data["createdByUserId"] : <any>null;
            this.createdByUserEmail = _data["createdByUserEmail"] !== undefined ? _data["createdByUserEmail"] : <any>null;
        }
    }

    static fromJS(data: any): WalletTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new WalletTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierMerchant"] = this.supplierMerchant ? this.supplierMerchant.toJSON() : <any>null;
        data["receiverMerchant"] = this.receiverMerchant ? this.receiverMerchant.toJSON() : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["bank"] = this.bank ? this.bank.toJSON() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["transferWalletType"] = this.transferWalletType !== undefined ? this.transferWalletType : <any>null;
        data["transferWalletState"] = this.transferWalletState !== undefined ? this.transferWalletState : <any>null;
        data["referenceNumber"] = this.referenceNumber !== undefined ? this.referenceNumber : <any>null;
        data["createdByUserId"] = this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
        data["createdByUserEmail"] = this.createdByUserEmail !== undefined ? this.createdByUserEmail : <any>null;
        return data;
    }
}

export interface IWalletTransaction {
    supplierMerchant: MerchantSummary;
    receiverMerchant: MerchantSummary;
    amount: number;
    currency: Currency;
    bank?: Bank | null;
    createdTime: Date;
    transferWalletType: TransferWalletType;
    transferWalletState: TransferWalletState;
    referenceNumber: number;
    createdByUserId?: string | null;
    createdByUserEmail?: string | null;
}

export enum TransferWalletType {
    Charge = "Charge",
    Buy = "Buy",
    Credit = "Credit",
    Payment = "Payment",
    Settle = "Settle",
    Withdraw = "Withdraw",
    Rebate = "Rebate",
    SaleReturn = "SaleReturn",
    PosOrder = "PosOrder",
}

export enum TransferWalletState {
    Reserved = "Reserved",
    Pending = "Pending",
    Failed = "Failed",
    Completed = "Completed",
    Unverified = "Unverified",
    Created = "Created",
    Rejecting = "Rejecting",
}

export enum CreditTransactionType {
    Credit = "Credit",
    Settle = "Settle",
}

export class PutCurrencyExchangeRateRequest implements IPutCurrencyExchangeRateRequest {
    baseCurrencyId!: number;
    targetCurrencyId!: number;
    exchangeRateFee!: number;

    constructor(data?: IPutCurrencyExchangeRateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseCurrencyId = _data["baseCurrencyId"] !== undefined ? _data["baseCurrencyId"] : <any>null;
            this.targetCurrencyId = _data["targetCurrencyId"] !== undefined ? _data["targetCurrencyId"] : <any>null;
            this.exchangeRateFee = _data["exchangeRateFee"] !== undefined ? _data["exchangeRateFee"] : <any>null;
        }
    }

    static fromJS(data: any): PutCurrencyExchangeRateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutCurrencyExchangeRateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseCurrencyId"] = this.baseCurrencyId !== undefined ? this.baseCurrencyId : <any>null;
        data["targetCurrencyId"] = this.targetCurrencyId !== undefined ? this.targetCurrencyId : <any>null;
        data["exchangeRateFee"] = this.exchangeRateFee !== undefined ? this.exchangeRateFee : <any>null;
        return data;
    }
}

export interface IPutCurrencyExchangeRateRequest {
    baseCurrencyId: number;
    targetCurrencyId: number;
    exchangeRateFee: number;
}

export enum FinancialOrderType {
    Charge = "Charge",
    Withdraw = "Withdraw",
    Credit = "Credit",
    Settle = "Settle",
    Rebate = "Rebate",
}

export class FinancialRequest implements IFinancialRequest {
    customerMerchantId!: number;
    currencyId!: number;
    amount!: number;
    description!: string;
    bankId?: number | null;

    constructor(data?: IFinancialRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerMerchantId = _data["customerMerchantId"] !== undefined ? _data["customerMerchantId"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.bankId = _data["bankId"] !== undefined ? _data["bankId"] : <any>null;
        }
    }

    static fromJS(data: any): FinancialRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerMerchantId"] = this.customerMerchantId !== undefined ? this.customerMerchantId : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["bankId"] = this.bankId !== undefined ? this.bankId : <any>null;
        return data;
    }
}

export interface IFinancialRequest {
    customerMerchantId: number;
    currencyId: number;
    amount: number;
    description: string;
    bankId?: number | null;
}

export class FinancialOrder implements IFinancialOrder {
    orderId!: number;
    amount!: number;
    currency!: Currency;
    financialOrderType!: FinancialOrderType;
    financialOrderState!: FinancialOrderState;
    firstVerifierUserId?: string | null;
    firstVerifierUserEmail?: string | null;
    secondVerifierUserId?: string | null;
    secondVerifierUserEmail?: string | null;
    rejecterUserId?: string | null;
    rejecterUserEmail?: string | null;
    createdTime!: Date;
    baseMerchant!: MerchantSummary;
    targetMerchant!: MerchantSummary;
    description?: string | null;
    bank?: Bank | null;

    constructor(data?: IFinancialOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
            this.baseMerchant = new MerchantSummary();
            this.targetMerchant = new MerchantSummary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.financialOrderType = _data["financialOrderType"] !== undefined ? _data["financialOrderType"] : <any>null;
            this.financialOrderState = _data["financialOrderState"] !== undefined ? _data["financialOrderState"] : <any>null;
            this.firstVerifierUserId = _data["firstVerifierUserId"] !== undefined ? _data["firstVerifierUserId"] : <any>null;
            this.firstVerifierUserEmail = _data["firstVerifierUserEmail"] !== undefined ? _data["firstVerifierUserEmail"] : <any>null;
            this.secondVerifierUserId = _data["secondVerifierUserId"] !== undefined ? _data["secondVerifierUserId"] : <any>null;
            this.secondVerifierUserEmail = _data["secondVerifierUserEmail"] !== undefined ? _data["secondVerifierUserEmail"] : <any>null;
            this.rejecterUserId = _data["rejecterUserId"] !== undefined ? _data["rejecterUserId"] : <any>null;
            this.rejecterUserEmail = _data["rejecterUserEmail"] !== undefined ? _data["rejecterUserEmail"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.baseMerchant = _data["baseMerchant"] ? MerchantSummary.fromJS(_data["baseMerchant"]) : new MerchantSummary();
            this.targetMerchant = _data["targetMerchant"] ? MerchantSummary.fromJS(_data["targetMerchant"]) : new MerchantSummary();
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.bank = _data["bank"] ? Bank.fromJS(_data["bank"]) : <any>null;
        }
    }

    static fromJS(data: any): FinancialOrder {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["financialOrderType"] = this.financialOrderType !== undefined ? this.financialOrderType : <any>null;
        data["financialOrderState"] = this.financialOrderState !== undefined ? this.financialOrderState : <any>null;
        data["firstVerifierUserId"] = this.firstVerifierUserId !== undefined ? this.firstVerifierUserId : <any>null;
        data["firstVerifierUserEmail"] = this.firstVerifierUserEmail !== undefined ? this.firstVerifierUserEmail : <any>null;
        data["secondVerifierUserId"] = this.secondVerifierUserId !== undefined ? this.secondVerifierUserId : <any>null;
        data["secondVerifierUserEmail"] = this.secondVerifierUserEmail !== undefined ? this.secondVerifierUserEmail : <any>null;
        data["rejecterUserId"] = this.rejecterUserId !== undefined ? this.rejecterUserId : <any>null;
        data["rejecterUserEmail"] = this.rejecterUserEmail !== undefined ? this.rejecterUserEmail : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["baseMerchant"] = this.baseMerchant ? this.baseMerchant.toJSON() : <any>null;
        data["targetMerchant"] = this.targetMerchant ? this.targetMerchant.toJSON() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["bank"] = this.bank ? this.bank.toJSON() : <any>null;
        return data;
    }
}

export interface IFinancialOrder {
    orderId: number;
    amount: number;
    currency: Currency;
    financialOrderType: FinancialOrderType;
    financialOrderState: FinancialOrderState;
    firstVerifierUserId?: string | null;
    firstVerifierUserEmail?: string | null;
    secondVerifierUserId?: string | null;
    secondVerifierUserEmail?: string | null;
    rejecterUserId?: string | null;
    rejecterUserEmail?: string | null;
    createdTime: Date;
    baseMerchant: MerchantSummary;
    targetMerchant: MerchantSummary;
    description?: string | null;
    bank?: Bank | null;
}

export enum FinancialOrderState {
    Completed = "Completed",
    Failed = "Failed",
    Unverified = "Unverified",
    Created = "Created",
    Rejecting = "Rejecting",
    Verifying = "Verifying",
}

export class GatewayList implements IGatewayList {
    gatewayListId!: number;
    name!: string;
    branch!: BranchLight;
    gatewayListPaymentProfiles!: GatewayListPaymentProfile[];

    constructor(data?: IGatewayList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.branch = new BranchLight();
            this.gatewayListPaymentProfiles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayListId = _data["gatewayListId"] !== undefined ? _data["gatewayListId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.branch = _data["branch"] ? BranchLight.fromJS(_data["branch"]) : new BranchLight();
            if (Array.isArray(_data["gatewayListPaymentProfiles"])) {
                this.gatewayListPaymentProfiles = [] as any;
                for (let item of _data["gatewayListPaymentProfiles"])
                    this.gatewayListPaymentProfiles!.push(GatewayListPaymentProfile.fromJS(item));
            }
            else {
                this.gatewayListPaymentProfiles = <any>null;
            }
        }
    }

    static fromJS(data: any): GatewayList {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayListId"] = this.gatewayListId !== undefined ? this.gatewayListId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>null;
        if (Array.isArray(this.gatewayListPaymentProfiles)) {
            data["gatewayListPaymentProfiles"] = [];
            for (let item of this.gatewayListPaymentProfiles)
                data["gatewayListPaymentProfiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGatewayList {
    gatewayListId: number;
    name: string;
    branch: BranchLight;
    gatewayListPaymentProfiles: GatewayListPaymentProfile[];
}

export class GatewayListPaymentProfile implements IGatewayListPaymentProfile {
    paymentProfile!: PaymentProfile;
    useForSubMerchants!: boolean;

    constructor(data?: IGatewayListPaymentProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.paymentProfile = new PaymentProfile();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentProfile = _data["paymentProfile"] ? PaymentProfile.fromJS(_data["paymentProfile"]) : new PaymentProfile();
            this.useForSubMerchants = _data["useForSubMerchants"] !== undefined ? _data["useForSubMerchants"] : <any>null;
        }
    }

    static fromJS(data: any): GatewayListPaymentProfile {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayListPaymentProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentProfile"] = this.paymentProfile ? this.paymentProfile.toJSON() : <any>null;
        data["useForSubMerchants"] = this.useForSubMerchants !== undefined ? this.useForSubMerchants : <any>null;
        return data;
    }
}

export interface IGatewayListPaymentProfile {
    paymentProfile: PaymentProfile;
    useForSubMerchants: boolean;
}

export class PaymentProfile implements IPaymentProfile {
    paymentProfileId!: number;
    providerProfileId!: number;
    description!: string;
    name!: string;
    currency!: Currency;
    minAmount!: number;
    maxAmount!: number;
    imageUri1?: string | null;
    imageUri2?: string | null;
    hasAutoPayment!: boolean;

    constructor(data?: IPaymentProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentProfileId = _data["paymentProfileId"] !== undefined ? _data["paymentProfileId"] : <any>null;
            this.providerProfileId = _data["providerProfileId"] !== undefined ? _data["providerProfileId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.minAmount = _data["minAmount"] !== undefined ? _data["minAmount"] : <any>null;
            this.maxAmount = _data["maxAmount"] !== undefined ? _data["maxAmount"] : <any>null;
            this.imageUri1 = _data["imageUri1"] !== undefined ? _data["imageUri1"] : <any>null;
            this.imageUri2 = _data["imageUri2"] !== undefined ? _data["imageUri2"] : <any>null;
            this.hasAutoPayment = _data["hasAutoPayment"] !== undefined ? _data["hasAutoPayment"] : <any>null;
        }
    }

    static fromJS(data: any): PaymentProfile {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentProfileId"] = this.paymentProfileId !== undefined ? this.paymentProfileId : <any>null;
        data["providerProfileId"] = this.providerProfileId !== undefined ? this.providerProfileId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["minAmount"] = this.minAmount !== undefined ? this.minAmount : <any>null;
        data["maxAmount"] = this.maxAmount !== undefined ? this.maxAmount : <any>null;
        data["imageUri1"] = this.imageUri1 !== undefined ? this.imageUri1 : <any>null;
        data["imageUri2"] = this.imageUri2 !== undefined ? this.imageUri2 : <any>null;
        data["hasAutoPayment"] = this.hasAutoPayment !== undefined ? this.hasAutoPayment : <any>null;
        return data;
    }
}

export interface IPaymentProfile {
    paymentProfileId: number;
    providerProfileId: number;
    description: string;
    name: string;
    currency: Currency;
    minAmount: number;
    maxAmount: number;
    imageUri1?: string | null;
    imageUri2?: string | null;
    hasAutoPayment: boolean;
}

export class CreateGatewayListRequest implements ICreateGatewayListRequest {
    name!: string;
    paymentProfiles!: PaymentProfileCreateRequest[];

    constructor(data?: ICreateGatewayListRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.paymentProfiles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["paymentProfiles"])) {
                this.paymentProfiles = [] as any;
                for (let item of _data["paymentProfiles"])
                    this.paymentProfiles!.push(PaymentProfileCreateRequest.fromJS(item));
            }
            else {
                this.paymentProfiles = <any>null;
            }
        }
    }

    static fromJS(data: any): CreateGatewayListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGatewayListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.paymentProfiles)) {
            data["paymentProfiles"] = [];
            for (let item of this.paymentProfiles)
                data["paymentProfiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateGatewayListRequest {
    name: string;
    paymentProfiles: PaymentProfileCreateRequest[];
}

export class PaymentProfileCreateRequest implements IPaymentProfileCreateRequest {
    paymentProfileId!: number;
    useForSubMerchants!: boolean;

    constructor(data?: IPaymentProfileCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentProfileId = _data["paymentProfileId"] !== undefined ? _data["paymentProfileId"] : <any>null;
            this.useForSubMerchants = _data["useForSubMerchants"] !== undefined ? _data["useForSubMerchants"] : <any>null;
        }
    }

    static fromJS(data: any): PaymentProfileCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentProfileCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentProfileId"] = this.paymentProfileId !== undefined ? this.paymentProfileId : <any>null;
        data["useForSubMerchants"] = this.useForSubMerchants !== undefined ? this.useForSubMerchants : <any>null;
        return data;
    }
}

export interface IPaymentProfileCreateRequest {
    paymentProfileId: number;
    useForSubMerchants: boolean;
}

export class PutGatewayListRequest implements IPutGatewayListRequest {
    name!: string;
    paymentProfiles!: PaymentProfileCreateRequest[];

    constructor(data?: IPutGatewayListRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.paymentProfiles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["paymentProfiles"])) {
                this.paymentProfiles = [] as any;
                for (let item of _data["paymentProfiles"])
                    this.paymentProfiles!.push(PaymentProfileCreateRequest.fromJS(item));
            }
            else {
                this.paymentProfiles = <any>null;
            }
        }
    }

    static fromJS(data: any): PutGatewayListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutGatewayListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.paymentProfiles)) {
            data["paymentProfiles"] = [];
            for (let item of this.paymentProfiles)
                data["paymentProfiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPutGatewayListRequest {
    name: string;
    paymentProfiles: PaymentProfileCreateRequest[];
}

export class InvoiceSummary implements IInvoiceSummary {
    invoiceId!: number;
    merchant!: MerchantSummary;
    createdTime!: Date;
    beginTime!: Date;
    endTime!: Date;

    constructor(data?: IInvoiceSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.merchant = new MerchantSummary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"] !== undefined ? _data["invoiceId"] : <any>null;
            this.merchant = _data["merchant"] ? MerchantSummary.fromJS(_data["merchant"]) : new MerchantSummary();
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>null;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): InvoiceSummary {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId !== undefined ? this.invoiceId : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>null;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
        return data;
    }
}

export interface IInvoiceSummary {
    invoiceId: number;
    merchant: MerchantSummary;
    createdTime: Date;
    beginTime: Date;
    endTime: Date;
}

export class Invoice implements IInvoice {
    invoiceId!: number;
    merchant!: Merchant;
    createdTime!: Date;
    beginTime!: Date;
    endTime!: Date;
    invoiceDetails!: InvoiceDetail[];

    constructor(data?: IInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.merchant = new Merchant();
            this.invoiceDetails = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"] !== undefined ? _data["invoiceId"] : <any>null;
            this.merchant = _data["merchant"] ? Merchant.fromJS(_data["merchant"]) : new Merchant();
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>null;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>null;
            if (Array.isArray(_data["invoiceDetails"])) {
                this.invoiceDetails = [] as any;
                for (let item of _data["invoiceDetails"])
                    this.invoiceDetails!.push(InvoiceDetail.fromJS(item));
            }
            else {
                this.invoiceDetails = <any>null;
            }
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId !== undefined ? this.invoiceId : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>null;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
        if (Array.isArray(this.invoiceDetails)) {
            data["invoiceDetails"] = [];
            for (let item of this.invoiceDetails)
                data["invoiceDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInvoice {
    invoiceId: number;
    merchant: Merchant;
    createdTime: Date;
    beginTime: Date;
    endTime: Date;
    invoiceDetails: InvoiceDetail[];
}

export class InvoiceDetail implements IInvoiceDetail {
    invoiceDetailId!: number;
    buyOrder?: BuyOrder | null;

    constructor(data?: IInvoiceDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceDetailId = _data["invoiceDetailId"] !== undefined ? _data["invoiceDetailId"] : <any>null;
            this.buyOrder = _data["buyOrder"] ? BuyOrder.fromJS(_data["buyOrder"]) : <any>null;
        }
    }

    static fromJS(data: any): InvoiceDetail {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceDetailId"] = this.invoiceDetailId !== undefined ? this.invoiceDetailId : <any>null;
        data["buyOrder"] = this.buyOrder ? this.buyOrder.toJSON() : <any>null;
        return data;
    }
}

export interface IInvoiceDetail {
    invoiceDetailId: number;
    buyOrder?: BuyOrder | null;
}

export class MerchantCurrencyLimit implements IMerchantCurrencyLimit {
    currencyLimitId!: number;
    merchantId!: number;
    amount!: number;
    currency!: Currency;

    constructor(data?: IMerchantCurrencyLimit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyLimitId = _data["currencyLimitId"] !== undefined ? _data["currencyLimitId"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
        }
    }

    static fromJS(data: any): MerchantCurrencyLimit {
        data = typeof data === 'object' ? data : {};
        let result = new MerchantCurrencyLimit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyLimitId"] = this.currencyLimitId !== undefined ? this.currencyLimitId : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        return data;
    }
}

export interface IMerchantCurrencyLimit {
    currencyLimitId: number;
    merchantId: number;
    amount: number;
    currency: Currency;
}

export class CreateMerchantCurrencyLimitRequest implements ICreateMerchantCurrencyLimitRequest {
    currencyId!: number;
    amount!: number;

    constructor(data?: ICreateMerchantCurrencyLimitRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
        }
    }

    static fromJS(data: any): CreateMerchantCurrencyLimitRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMerchantCurrencyLimitRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        return data;
    }
}

export interface ICreateMerchantCurrencyLimitRequest {
    currencyId: number;
    amount: number;
}

export class CreateMerchantRequest implements ICreateMerchantRequest {
    parentBranchId!: number;
    merchantName!: string;
    email!: string;
    externalReference!: string;
    priceListId?: number | null;
    saleManagerId?: number | null;
    gatewayListId?: number | null;
    description?: string | null;
    address?: MerchantAddress | null;
    timeZone?: string | null;
    website?: string | null;
    phoneNumber?: Phone | null;
    whatsappNumber?: Phone | null;

    constructor(data?: ICreateMerchantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentBranchId = _data["parentBranchId"] !== undefined ? _data["parentBranchId"] : <any>null;
            this.merchantName = _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.externalReference = _data["externalReference"] !== undefined ? _data["externalReference"] : <any>null;
            this.priceListId = _data["priceListId"] !== undefined ? _data["priceListId"] : <any>null;
            this.saleManagerId = _data["saleManagerId"] !== undefined ? _data["saleManagerId"] : <any>null;
            this.gatewayListId = _data["gatewayListId"] !== undefined ? _data["gatewayListId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.address = _data["address"] ? MerchantAddress.fromJS(_data["address"]) : <any>null;
            this.timeZone = _data["timeZone"] !== undefined ? _data["timeZone"] : <any>null;
            this.website = _data["website"] !== undefined ? _data["website"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] ? Phone.fromJS(_data["phoneNumber"]) : <any>null;
            this.whatsappNumber = _data["whatsappNumber"] ? Phone.fromJS(_data["whatsappNumber"]) : <any>null;
        }
    }

    static fromJS(data: any): CreateMerchantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMerchantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentBranchId"] = this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
        data["merchantName"] = this.merchantName !== undefined ? this.merchantName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["externalReference"] = this.externalReference !== undefined ? this.externalReference : <any>null;
        data["priceListId"] = this.priceListId !== undefined ? this.priceListId : <any>null;
        data["saleManagerId"] = this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
        data["gatewayListId"] = this.gatewayListId !== undefined ? this.gatewayListId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["timeZone"] = this.timeZone !== undefined ? this.timeZone : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>null;
        data["whatsappNumber"] = this.whatsappNumber ? this.whatsappNumber.toJSON() : <any>null;
        return data;
    }
}

export interface ICreateMerchantRequest {
    parentBranchId: number;
    merchantName: string;
    email: string;
    externalReference: string;
    priceListId?: number | null;
    saleManagerId?: number | null;
    gatewayListId?: number | null;
    description?: string | null;
    address?: MerchantAddress | null;
    timeZone?: string | null;
    website?: string | null;
    phoneNumber?: Phone | null;
    whatsappNumber?: Phone | null;
}

export class UpdateMerchantRequest implements IUpdateMerchantRequest {
    postPayAchPaymentMethodProviderProfileId?: PatchOfInteger | null;
    otpCodeToActivate2Fa?: PatchOfString | null;
    inactivate2Fa?: PatchOfBoolean | null;
    activatePin?: PatchOfBoolean | null;

    constructor(data?: IUpdateMerchantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postPayAchPaymentMethodProviderProfileId = _data["postPayAchPaymentMethodProviderProfileId"] ? PatchOfInteger.fromJS(_data["postPayAchPaymentMethodProviderProfileId"]) : <any>null;
            this.otpCodeToActivate2Fa = _data["otpCodeToActivate2Fa"] ? PatchOfString.fromJS(_data["otpCodeToActivate2Fa"]) : <any>null;
            this.inactivate2Fa = _data["inactivate2Fa"] ? PatchOfBoolean.fromJS(_data["inactivate2Fa"]) : <any>null;
            this.activatePin = _data["activatePin"] ? PatchOfBoolean.fromJS(_data["activatePin"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateMerchantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMerchantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postPayAchPaymentMethodProviderProfileId"] = this.postPayAchPaymentMethodProviderProfileId ? this.postPayAchPaymentMethodProviderProfileId.toJSON() : <any>null;
        data["otpCodeToActivate2Fa"] = this.otpCodeToActivate2Fa ? this.otpCodeToActivate2Fa.toJSON() : <any>null;
        data["inactivate2Fa"] = this.inactivate2Fa ? this.inactivate2Fa.toJSON() : <any>null;
        data["activatePin"] = this.activatePin ? this.activatePin.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateMerchantRequest {
    postPayAchPaymentMethodProviderProfileId?: PatchOfInteger | null;
    otpCodeToActivate2Fa?: PatchOfString | null;
    inactivate2Fa?: PatchOfBoolean | null;
    activatePin?: PatchOfBoolean | null;
}

export class PatchOfInteger implements IPatchOfInteger {
    value!: number;

    constructor(data?: IPatchOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfInteger {
    value: number;
}

export class PatchOfBoolean implements IPatchOfBoolean {
    value!: boolean;

    constructor(data?: IPatchOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfBoolean {
    value: boolean;
}

export class UpdateSubMerchantRequest implements IUpdateSubMerchantRequest {
    exchangeTargetCurrencyId?: PatchOfInteger | null;
    invoiceThresholdDay?: PatchOfNullableInteger | null;
    address?: MerchantAddress | null;
    website?: PatchOfUri | null;
    phoneNumber?: PatchOfPhone | null;
    whatsappNumber?: PatchOfPhone | null;
    email?: PatchOfString | null;
    timeZone?: PatchOfString | null;
    isActive?: PatchOfNullableBoolean | null;
    isActivePostPay?: PatchOfBoolean | null;

    constructor(data?: IUpdateSubMerchantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exchangeTargetCurrencyId = _data["exchangeTargetCurrencyId"] ? PatchOfInteger.fromJS(_data["exchangeTargetCurrencyId"]) : <any>null;
            this.invoiceThresholdDay = _data["invoiceThresholdDay"] ? PatchOfNullableInteger.fromJS(_data["invoiceThresholdDay"]) : <any>null;
            this.address = _data["address"] ? MerchantAddress.fromJS(_data["address"]) : <any>null;
            this.website = _data["website"] ? PatchOfUri.fromJS(_data["website"]) : <any>null;
            this.phoneNumber = _data["phoneNumber"] ? PatchOfPhone.fromJS(_data["phoneNumber"]) : <any>null;
            this.whatsappNumber = _data["whatsappNumber"] ? PatchOfPhone.fromJS(_data["whatsappNumber"]) : <any>null;
            this.email = _data["email"] ? PatchOfString.fromJS(_data["email"]) : <any>null;
            this.timeZone = _data["timeZone"] ? PatchOfString.fromJS(_data["timeZone"]) : <any>null;
            this.isActive = _data["isActive"] ? PatchOfNullableBoolean.fromJS(_data["isActive"]) : <any>null;
            this.isActivePostPay = _data["isActivePostPay"] ? PatchOfBoolean.fromJS(_data["isActivePostPay"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateSubMerchantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubMerchantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exchangeTargetCurrencyId"] = this.exchangeTargetCurrencyId ? this.exchangeTargetCurrencyId.toJSON() : <any>null;
        data["invoiceThresholdDay"] = this.invoiceThresholdDay ? this.invoiceThresholdDay.toJSON() : <any>null;
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["website"] = this.website ? this.website.toJSON() : <any>null;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>null;
        data["whatsappNumber"] = this.whatsappNumber ? this.whatsappNumber.toJSON() : <any>null;
        data["email"] = this.email ? this.email.toJSON() : <any>null;
        data["timeZone"] = this.timeZone ? this.timeZone.toJSON() : <any>null;
        data["isActive"] = this.isActive ? this.isActive.toJSON() : <any>null;
        data["isActivePostPay"] = this.isActivePostPay ? this.isActivePostPay.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateSubMerchantRequest {
    exchangeTargetCurrencyId?: PatchOfInteger | null;
    invoiceThresholdDay?: PatchOfNullableInteger | null;
    address?: MerchantAddress | null;
    website?: PatchOfUri | null;
    phoneNumber?: PatchOfPhone | null;
    whatsappNumber?: PatchOfPhone | null;
    email?: PatchOfString | null;
    timeZone?: PatchOfString | null;
    isActive?: PatchOfNullableBoolean | null;
    isActivePostPay?: PatchOfBoolean | null;
}

export class PatchOfNullableInteger implements IPatchOfNullableInteger {
    value?: number | null;

    constructor(data?: IPatchOfNullableInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfNullableInteger {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfNullableInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfNullableInteger {
    value?: number | null;
}

export class PatchOfPhone implements IPatchOfPhone {
    value?: Phone | null;

    constructor(data?: IPatchOfPhone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? Phone.fromJS(_data["value"]) : <any>null;
        }
    }

    static fromJS(data: any): PatchOfPhone {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfPhone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>null;
        return data;
    }
}

export interface IPatchOfPhone {
    value?: Phone | null;
}

export class PatchOfNullableBoolean implements IPatchOfNullableBoolean {
    value?: boolean | null;

    constructor(data?: IPatchOfNullableBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfNullableBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfNullableBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfNullableBoolean {
    value?: boolean | null;
}

export class UpdateMerchantSettingRequest implements IUpdateMerchantSettingRequest {
    canCreatePaymentOrder?: PatchOfNullableBoolean | null;

    constructor(data?: IUpdateMerchantSettingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canCreatePaymentOrder = _data["canCreatePaymentOrder"] ? PatchOfNullableBoolean.fromJS(_data["canCreatePaymentOrder"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateMerchantSettingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMerchantSettingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canCreatePaymentOrder"] = this.canCreatePaymentOrder ? this.canCreatePaymentOrder.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateMerchantSettingRequest {
    canCreatePaymentOrder?: PatchOfNullableBoolean | null;
}

export class PaymentOrder implements IPaymentOrder {
    paymentOrderId!: number;
    providerPaymentId?: number | null;
    merchant!: MerchantSummary;
    paymentUrl?: string | null;
    amount!: number;
    lastError?: string | null;
    currency!: Currency;
    paymentOrderState!: PaymentOrderState;
    type!: PaymentOrderType;
    createdTime!: Date;
    modifiedTime!: Date;

    constructor(data?: IPaymentOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.merchant = new MerchantSummary();
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentOrderId = _data["paymentOrderId"] !== undefined ? _data["paymentOrderId"] : <any>null;
            this.providerPaymentId = _data["providerPaymentId"] !== undefined ? _data["providerPaymentId"] : <any>null;
            this.merchant = _data["merchant"] ? MerchantSummary.fromJS(_data["merchant"]) : new MerchantSummary();
            this.paymentUrl = _data["paymentUrl"] !== undefined ? _data["paymentUrl"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.lastError = _data["lastError"] !== undefined ? _data["lastError"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.paymentOrderState = _data["paymentOrderState"] !== undefined ? _data["paymentOrderState"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PaymentOrder {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentOrderId"] = this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
        data["providerPaymentId"] = this.providerPaymentId !== undefined ? this.providerPaymentId : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["paymentUrl"] = this.paymentUrl !== undefined ? this.paymentUrl : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["lastError"] = this.lastError !== undefined ? this.lastError : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["paymentOrderState"] = this.paymentOrderState !== undefined ? this.paymentOrderState : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        return data;
    }
}

export interface IPaymentOrder {
    paymentOrderId: number;
    providerPaymentId?: number | null;
    merchant: MerchantSummary;
    paymentUrl?: string | null;
    amount: number;
    lastError?: string | null;
    currency: Currency;
    paymentOrderState: PaymentOrderState;
    type: PaymentOrderType;
    createdTime: Date;
    modifiedTime: Date;
}

export enum PaymentOrderState {
    Reserved = "Reserved",
    PaymentProviderCreated = "PaymentProviderCreated",
    PaymentProviderCaptured = "PaymentProviderCaptured",
    PaymentProviderDisputed = "PaymentProviderDisputed",
    Captured = "Captured",
    Disputed = "Disputed",
    Failed = "Failed",
    InProgress = "InProgress",
    Created = "Created",
}

export enum PaymentOrderType {
    DirectCharge = "DirectCharge",
    ChargeByPosOrder = "ChargeByPosOrder",
    ChargeByPostPay = "ChargeByPostPay",
}

export class CreateChargeOrdinaryPaymentOrderRequest implements ICreateChargeOrdinaryPaymentOrderRequest {
    amount!: number;
    returnUrl!: string;
    paymentProfileId!: number;

    constructor(data?: ICreateChargeOrdinaryPaymentOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.returnUrl = _data["returnUrl"] !== undefined ? _data["returnUrl"] : <any>null;
            this.paymentProfileId = _data["paymentProfileId"] !== undefined ? _data["paymentProfileId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateChargeOrdinaryPaymentOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChargeOrdinaryPaymentOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["returnUrl"] = this.returnUrl !== undefined ? this.returnUrl : <any>null;
        data["paymentProfileId"] = this.paymentProfileId !== undefined ? this.paymentProfileId : <any>null;
        return data;
    }
}

export interface ICreateChargeOrdinaryPaymentOrderRequest {
    amount: number;
    returnUrl: string;
    paymentProfileId: number;
}

export class CreateChargeAutoPaymentOrderRequest implements ICreateChargeAutoPaymentOrderRequest {
    amount!: number;
    paymentMethodProviderProfileId!: number;

    constructor(data?: ICreateChargeAutoPaymentOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.paymentMethodProviderProfileId = _data["paymentMethodProviderProfileId"] !== undefined ? _data["paymentMethodProviderProfileId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateChargeAutoPaymentOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChargeAutoPaymentOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["paymentMethodProviderProfileId"] = this.paymentMethodProviderProfileId !== undefined ? this.paymentMethodProviderProfileId : <any>null;
        return data;
    }
}

export interface ICreateChargeAutoPaymentOrderRequest {
    amount: number;
    paymentMethodProviderProfileId: number;
}

export class PaymentOrderSummary implements IPaymentOrderSummary {
    paymentOrderId!: number;
    amount!: number;
    currency!: Currency;
    paymentOrderState!: PaymentOrderState;
    stateId!: number;
    autoPayment!: boolean;
    type!: PaymentOrderType;
    createdTime!: Date;

    constructor(data?: IPaymentOrderSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentOrderId = _data["paymentOrderId"] !== undefined ? _data["paymentOrderId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.paymentOrderState = _data["paymentOrderState"] !== undefined ? _data["paymentOrderState"] : <any>null;
            this.stateId = _data["stateId"] !== undefined ? _data["stateId"] : <any>null;
            this.autoPayment = _data["autoPayment"] !== undefined ? _data["autoPayment"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PaymentOrderSummary {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentOrderSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentOrderId"] = this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["paymentOrderState"] = this.paymentOrderState !== undefined ? this.paymentOrderState : <any>null;
        data["stateId"] = this.stateId !== undefined ? this.stateId : <any>null;
        data["autoPayment"] = this.autoPayment !== undefined ? this.autoPayment : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        return data;
    }
}

export interface IPaymentOrderSummary {
    paymentOrderId: number;
    amount: number;
    currency: Currency;
    paymentOrderState: PaymentOrderState;
    stateId: number;
    autoPayment: boolean;
    type: PaymentOrderType;
    createdTime: Date;
}

export class PaymentOrderStateLog implements IPaymentOrderStateLog {
    paymentOrderStateLogId!: number;
    state!: PaymentOrderState;
    stateId!: number;
    error?: string | null;
    createdTime!: Date;

    constructor(data?: IPaymentOrderStateLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentOrderStateLogId = _data["paymentOrderStateLogId"] !== undefined ? _data["paymentOrderStateLogId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.stateId = _data["stateId"] !== undefined ? _data["stateId"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PaymentOrderStateLog {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentOrderStateLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentOrderStateLogId"] = this.paymentOrderStateLogId !== undefined ? this.paymentOrderStateLogId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["stateId"] = this.stateId !== undefined ? this.stateId : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        return data;
    }
}

export interface IPaymentOrderStateLog {
    paymentOrderStateLogId: number;
    state: PaymentOrderState;
    stateId: number;
    error?: string | null;
    createdTime: Date;
}

export enum PaymentProviderCustomerPanelLinkAccessType {
    CreditCard = "CreditCard",
    ElectronicCheck = "ElectronicCheck",
}

export class PaymentProviderPaymentMethod implements IPaymentProviderPaymentMethod {
    paymentMethodId!: number;
    paymentMethodType!: PaymentProviderPaymentMethodType;
    paymentMethodTypeId!: number;
    paymentMethodNumber!: string;
    providerProfiles?: PaymentProviderProfile[] | null;

    constructor(data?: IPaymentProviderPaymentMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodId = _data["paymentMethodId"] !== undefined ? _data["paymentMethodId"] : <any>null;
            this.paymentMethodType = _data["paymentMethodType"] !== undefined ? _data["paymentMethodType"] : <any>null;
            this.paymentMethodTypeId = _data["paymentMethodTypeId"] !== undefined ? _data["paymentMethodTypeId"] : <any>null;
            this.paymentMethodNumber = _data["paymentMethodNumber"] !== undefined ? _data["paymentMethodNumber"] : <any>null;
            if (Array.isArray(_data["providerProfiles"])) {
                this.providerProfiles = [] as any;
                for (let item of _data["providerProfiles"])
                    this.providerProfiles!.push(PaymentProviderProfile.fromJS(item));
            }
            else {
                this.providerProfiles = <any>null;
            }
        }
    }

    static fromJS(data: any): PaymentProviderPaymentMethod {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentProviderPaymentMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodId"] = this.paymentMethodId !== undefined ? this.paymentMethodId : <any>null;
        data["paymentMethodType"] = this.paymentMethodType !== undefined ? this.paymentMethodType : <any>null;
        data["paymentMethodTypeId"] = this.paymentMethodTypeId !== undefined ? this.paymentMethodTypeId : <any>null;
        data["paymentMethodNumber"] = this.paymentMethodNumber !== undefined ? this.paymentMethodNumber : <any>null;
        if (Array.isArray(this.providerProfiles)) {
            data["providerProfiles"] = [];
            for (let item of this.providerProfiles)
                data["providerProfiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaymentProviderPaymentMethod {
    paymentMethodId: number;
    paymentMethodType: PaymentProviderPaymentMethodType;
    paymentMethodTypeId: number;
    paymentMethodNumber: string;
    providerProfiles?: PaymentProviderProfile[] | null;
}

export enum PaymentProviderPaymentMethodType {
    CreditCard = "CreditCard",
    ElectronicCheck = "ElectronicCheck",
}

export class PaymentProviderProfile implements IPaymentProviderProfile {
    paymentMethodProviderProfileId!: number;
    profileId!: number;
    paymentMethodId!: number;
    profileName!: string;

    constructor(data?: IPaymentProviderProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodProviderProfileId = _data["paymentMethodProviderProfileId"] !== undefined ? _data["paymentMethodProviderProfileId"] : <any>null;
            this.profileId = _data["profileId"] !== undefined ? _data["profileId"] : <any>null;
            this.paymentMethodId = _data["paymentMethodId"] !== undefined ? _data["paymentMethodId"] : <any>null;
            this.profileName = _data["profileName"] !== undefined ? _data["profileName"] : <any>null;
        }
    }

    static fromJS(data: any): PaymentProviderProfile {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentProviderProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodProviderProfileId"] = this.paymentMethodProviderProfileId !== undefined ? this.paymentMethodProviderProfileId : <any>null;
        data["profileId"] = this.profileId !== undefined ? this.profileId : <any>null;
        data["paymentMethodId"] = this.paymentMethodId !== undefined ? this.paymentMethodId : <any>null;
        data["profileName"] = this.profileName !== undefined ? this.profileName : <any>null;
        return data;
    }
}

export interface IPaymentProviderProfile {
    paymentMethodProviderProfileId: number;
    profileId: number;
    paymentMethodId: number;
    profileName: string;
}

export class PlacePhysicalCardOrderRequest implements IPlacePhysicalCardOrderRequest {
    physicalCardOrderItems!: PhysicalCardOrderItem[];
    shipping!: Shipping;

    constructor(data?: IPlacePhysicalCardOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.physicalCardOrderItems = [];
            this.shipping = new Shipping();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["physicalCardOrderItems"])) {
                this.physicalCardOrderItems = [] as any;
                for (let item of _data["physicalCardOrderItems"])
                    this.physicalCardOrderItems!.push(PhysicalCardOrderItem.fromJS(item));
            }
            else {
                this.physicalCardOrderItems = <any>null;
            }
            this.shipping = _data["shipping"] ? Shipping.fromJS(_data["shipping"]) : new Shipping();
        }
    }

    static fromJS(data: any): PlacePhysicalCardOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PlacePhysicalCardOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.physicalCardOrderItems)) {
            data["physicalCardOrderItems"] = [];
            for (let item of this.physicalCardOrderItems)
                data["physicalCardOrderItems"].push(item.toJSON());
        }
        data["shipping"] = this.shipping ? this.shipping.toJSON() : <any>null;
        return data;
    }
}

export interface IPlacePhysicalCardOrderRequest {
    physicalCardOrderItems: PhysicalCardOrderItem[];
    shipping: Shipping;
}

export class PhysicalCardOrderItem implements IPhysicalCardOrderItem {
    productId!: number;
    quantity!: number;
    productPrice?: number | null;

    constructor(data?: IPhysicalCardOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.productPrice = _data["productPrice"] !== undefined ? _data["productPrice"] : <any>null;
        }
    }

    static fromJS(data: any): PhysicalCardOrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new PhysicalCardOrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["productPrice"] = this.productPrice !== undefined ? this.productPrice : <any>null;
        return data;
    }
}

export interface IPhysicalCardOrderItem {
    productId: number;
    quantity: number;
    productPrice?: number | null;
}

export class Shipping implements IShipping {
    fullName!: string;
    phoneNumber!: Phone;
    address!: Address;

    constructor(data?: IShipping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.phoneNumber = new Phone();
            this.address = new Address();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] ? Phone.fromJS(_data["phoneNumber"]) : new Phone();
            this.address = _data["address"] ? Address.fromJS(_data["address"]) : new Address();
        }
    }

    static fromJS(data: any): Shipping {
        data = typeof data === 'object' ? data : {};
        let result = new Shipping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>null;
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        return data;
    }
}

export interface IShipping {
    fullName: string;
    phoneNumber: Phone;
    address: Address;
}

export class Address implements IAddress {
    country!: string;
    state!: string;
    city!: string;
    rawAddress!: string;
    zipCode!: string;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.country = _data["country"] !== undefined ? _data["country"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.rawAddress = _data["rawAddress"] !== undefined ? _data["rawAddress"] : <any>null;
            this.zipCode = _data["zipCode"] !== undefined ? _data["zipCode"] : <any>null;
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["rawAddress"] = this.rawAddress !== undefined ? this.rawAddress : <any>null;
        data["zipCode"] = this.zipCode !== undefined ? this.zipCode : <any>null;
        return data;
    }
}

export interface IAddress {
    country: string;
    state: string;
    city: string;
    rawAddress: string;
    zipCode: string;
}

export class PhysicalCardOrder implements IPhysicalCardOrder {
    physicalCardOrderId!: number;
    physicalCardOrderDetails!: PhysicalCardOrderDetail[];
    state!: PhysicalCardOrderState;
    shipping!: Shipping;
    merchant!: MerchantSummary;
    createdTime!: Date;

    constructor(data?: IPhysicalCardOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.physicalCardOrderDetails = [];
            this.shipping = new Shipping();
            this.merchant = new MerchantSummary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.physicalCardOrderId = _data["physicalCardOrderId"] !== undefined ? _data["physicalCardOrderId"] : <any>null;
            if (Array.isArray(_data["physicalCardOrderDetails"])) {
                this.physicalCardOrderDetails = [] as any;
                for (let item of _data["physicalCardOrderDetails"])
                    this.physicalCardOrderDetails!.push(PhysicalCardOrderDetail.fromJS(item));
            }
            else {
                this.physicalCardOrderDetails = <any>null;
            }
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.shipping = _data["shipping"] ? Shipping.fromJS(_data["shipping"]) : new Shipping();
            this.merchant = _data["merchant"] ? MerchantSummary.fromJS(_data["merchant"]) : new MerchantSummary();
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PhysicalCardOrder {
        data = typeof data === 'object' ? data : {};
        let result = new PhysicalCardOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["physicalCardOrderId"] = this.physicalCardOrderId !== undefined ? this.physicalCardOrderId : <any>null;
        if (Array.isArray(this.physicalCardOrderDetails)) {
            data["physicalCardOrderDetails"] = [];
            for (let item of this.physicalCardOrderDetails)
                data["physicalCardOrderDetails"].push(item.toJSON());
        }
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["shipping"] = this.shipping ? this.shipping.toJSON() : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        return data;
    }
}

export interface IPhysicalCardOrder {
    physicalCardOrderId: number;
    physicalCardOrderDetails: PhysicalCardOrderDetail[];
    state: PhysicalCardOrderState;
    shipping: Shipping;
    merchant: MerchantSummary;
    createdTime: Date;
}

export class PhysicalCardOrderDetail implements IPhysicalCardOrderDetail {
    product!: ProductLight;
    quantity!: number;
    productPrice?: number | null;

    constructor(data?: IPhysicalCardOrderDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.product = new ProductLight();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? ProductLight.fromJS(_data["product"]) : new ProductLight();
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.productPrice = _data["productPrice"] !== undefined ? _data["productPrice"] : <any>null;
        }
    }

    static fromJS(data: any): PhysicalCardOrderDetail {
        data = typeof data === 'object' ? data : {};
        let result = new PhysicalCardOrderDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["productPrice"] = this.productPrice !== undefined ? this.productPrice : <any>null;
        return data;
    }
}

export interface IPhysicalCardOrderDetail {
    product: ProductLight;
    quantity: number;
    productPrice?: number | null;
}

export class ProductLight implements IProductLight {
    productId!: number;
    productName!: string;
    currency!: Currency;

    constructor(data?: IProductLight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
            this.productName = _data["productName"] !== undefined ? _data["productName"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
        }
    }

    static fromJS(data: any): ProductLight {
        data = typeof data === 'object' ? data : {};
        let result = new ProductLight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        data["productName"] = this.productName !== undefined ? this.productName : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        return data;
    }
}

export interface IProductLight {
    productId: number;
    productName: string;
    currency: Currency;
}

export enum PhysicalCardOrderState {
    Reserved = "Reserved",
    Created = "Created",
    Delivered = "Delivered",
    Shipping = "Shipping",
    Failed = "Failed",
}

export class PhysicalCardOrderStateLog implements IPhysicalCardOrderStateLog {
    physicalCardOrderStateLogId!: number;
    state!: PhysicalCardOrderState;
    description?: string | null;
    createdTime!: Date;

    constructor(data?: IPhysicalCardOrderStateLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.physicalCardOrderStateLogId = _data["physicalCardOrderStateLogId"] !== undefined ? _data["physicalCardOrderStateLogId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PhysicalCardOrderStateLog {
        data = typeof data === 'object' ? data : {};
        let result = new PhysicalCardOrderStateLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["physicalCardOrderStateLogId"] = this.physicalCardOrderStateLogId !== undefined ? this.physicalCardOrderStateLogId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        return data;
    }
}

export interface IPhysicalCardOrderStateLog {
    physicalCardOrderStateLogId: number;
    state: PhysicalCardOrderState;
    description?: string | null;
    createdTime: Date;
}

export class Pos implements IPos {
    posId!: number;
    name!: string;
    description?: string | null;
    isSubscriptive!: boolean;
    installmentCount?: number | null;
    imageUri?: string | null;
    price!: number;
    currency!: Currency;

    constructor(data?: IPos) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posId = _data["posId"] !== undefined ? _data["posId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.isSubscriptive = _data["isSubscriptive"] !== undefined ? _data["isSubscriptive"] : <any>null;
            this.installmentCount = _data["installmentCount"] !== undefined ? _data["installmentCount"] : <any>null;
            this.imageUri = _data["imageUri"] !== undefined ? _data["imageUri"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
        }
    }

    static fromJS(data: any): Pos {
        data = typeof data === 'object' ? data : {};
        let result = new Pos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posId"] = this.posId !== undefined ? this.posId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["isSubscriptive"] = this.isSubscriptive !== undefined ? this.isSubscriptive : <any>null;
        data["installmentCount"] = this.installmentCount !== undefined ? this.installmentCount : <any>null;
        data["imageUri"] = this.imageUri !== undefined ? this.imageUri : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        return data;
    }
}

export interface IPos {
    posId: number;
    name: string;
    description?: string | null;
    isSubscriptive: boolean;
    installmentCount?: number | null;
    imageUri?: string | null;
    price: number;
    currency: Currency;
}

export class CreatePosRequest implements ICreatePosRequest {
    name!: string;
    description?: string | null;
    imageUri?: string | null;
    isSubscriptive!: boolean;
    installmentCount?: number | null;
    price!: number;
    currencyId!: number;

    constructor(data?: ICreatePosRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.imageUri = _data["imageUri"] !== undefined ? _data["imageUri"] : <any>null;
            this.isSubscriptive = _data["isSubscriptive"] !== undefined ? _data["isSubscriptive"] : <any>null;
            this.installmentCount = _data["installmentCount"] !== undefined ? _data["installmentCount"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
        }
    }

    static fromJS(data: any): CreatePosRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePosRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["imageUri"] = this.imageUri !== undefined ? this.imageUri : <any>null;
        data["isSubscriptive"] = this.isSubscriptive !== undefined ? this.isSubscriptive : <any>null;
        data["installmentCount"] = this.installmentCount !== undefined ? this.installmentCount : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        return data;
    }
}

export interface ICreatePosRequest {
    name: string;
    description?: string | null;
    imageUri?: string | null;
    isSubscriptive: boolean;
    installmentCount?: number | null;
    price: number;
    currencyId: number;
}

export class UpdatePosRequest implements IUpdatePosRequest {
    name?: PatchOfString | null;
    description?: PatchOfString | null;
    imageUri?: PatchOfUri | null;
    price?: PatchOfDecimal | null;

    constructor(data?: IUpdatePosRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? PatchOfString.fromJS(_data["name"]) : <any>null;
            this.description = _data["description"] ? PatchOfString.fromJS(_data["description"]) : <any>null;
            this.imageUri = _data["imageUri"] ? PatchOfUri.fromJS(_data["imageUri"]) : <any>null;
            this.price = _data["price"] ? PatchOfDecimal.fromJS(_data["price"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdatePosRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePosRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>null;
        data["description"] = this.description ? this.description.toJSON() : <any>null;
        data["imageUri"] = this.imageUri ? this.imageUri.toJSON() : <any>null;
        data["price"] = this.price ? this.price.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdatePosRequest {
    name?: PatchOfString | null;
    description?: PatchOfString | null;
    imageUri?: PatchOfUri | null;
    price?: PatchOfDecimal | null;
}

export class PatchOfDecimal implements IPatchOfDecimal {
    value!: number;

    constructor(data?: IPatchOfDecimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfDecimal {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfDecimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfDecimal {
    value: number;
}

export class CreatePosOrderResponse implements ICreatePosOrderResponse {
    posOrderId!: number;
    paymentOrderRedirectUri?: string | null;

    constructor(data?: ICreatePosOrderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posOrderId = _data["posOrderId"] !== undefined ? _data["posOrderId"] : <any>null;
            this.paymentOrderRedirectUri = _data["paymentOrderRedirectUri"] !== undefined ? _data["paymentOrderRedirectUri"] : <any>null;
        }
    }

    static fromJS(data: any): CreatePosOrderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePosOrderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posOrderId"] = this.posOrderId !== undefined ? this.posOrderId : <any>null;
        data["paymentOrderRedirectUri"] = this.paymentOrderRedirectUri !== undefined ? this.paymentOrderRedirectUri : <any>null;
        return data;
    }
}

export interface ICreatePosOrderResponse {
    posOrderId: number;
    paymentOrderRedirectUri?: string | null;
}

export class CreatePosOrderRequest implements ICreatePosOrderRequest {
    posId!: number;
    quantity!: number;
    paymentMethodProviderProfileId?: number | null;
    returnUri?: string | null;
    shipping!: Shipping;
    paymentMethod!: PosOrderPaymentMethod;

    constructor(data?: ICreatePosOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.shipping = new Shipping();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posId = _data["posId"] !== undefined ? _data["posId"] : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.paymentMethodProviderProfileId = _data["paymentMethodProviderProfileId"] !== undefined ? _data["paymentMethodProviderProfileId"] : <any>null;
            this.returnUri = _data["returnUri"] !== undefined ? _data["returnUri"] : <any>null;
            this.shipping = _data["shipping"] ? Shipping.fromJS(_data["shipping"]) : new Shipping();
            this.paymentMethod = _data["paymentMethod"] !== undefined ? _data["paymentMethod"] : <any>null;
        }
    }

    static fromJS(data: any): CreatePosOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePosOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posId"] = this.posId !== undefined ? this.posId : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["paymentMethodProviderProfileId"] = this.paymentMethodProviderProfileId !== undefined ? this.paymentMethodProviderProfileId : <any>null;
        data["returnUri"] = this.returnUri !== undefined ? this.returnUri : <any>null;
        data["shipping"] = this.shipping ? this.shipping.toJSON() : <any>null;
        data["paymentMethod"] = this.paymentMethod !== undefined ? this.paymentMethod : <any>null;
        return data;
    }
}

export interface ICreatePosOrderRequest {
    posId: number;
    quantity: number;
    paymentMethodProviderProfileId?: number | null;
    returnUri?: string | null;
    shipping: Shipping;
    paymentMethod: PosOrderPaymentMethod;
}

export enum PosOrderPaymentMethod {
    Wallet = "Wallet",
    CreditCard = "CreditCard",
    Ach = "Ach",
}

export class PosOrder implements IPosOrder {
    posOrderId!: number;
    quantity!: number;
    posPrice!: number;
    description?: string | null;
    paymentMethod!: PosOrderPaymentMethod;
    state!: PosOrderState;
    paymentInstallmentCacheState?: PosOrderPaymentInstallmentCacheState | null;
    paymentItems?: PosOrderPaymentItem[] | null;
    pos!: Pos;
    shipping!: Shipping;
    merchant!: MerchantSummary;
    createdTime!: Date;
    deliveredTime?: Date | null;

    constructor(data?: IPosOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.pos = new Pos();
            this.shipping = new Shipping();
            this.merchant = new MerchantSummary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posOrderId = _data["posOrderId"] !== undefined ? _data["posOrderId"] : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.posPrice = _data["posPrice"] !== undefined ? _data["posPrice"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.paymentMethod = _data["paymentMethod"] !== undefined ? _data["paymentMethod"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.paymentInstallmentCacheState = _data["paymentInstallmentCacheState"] !== undefined ? _data["paymentInstallmentCacheState"] : <any>null;
            if (Array.isArray(_data["paymentItems"])) {
                this.paymentItems = [] as any;
                for (let item of _data["paymentItems"])
                    this.paymentItems!.push(PosOrderPaymentItem.fromJS(item));
            }
            else {
                this.paymentItems = <any>null;
            }
            this.pos = _data["pos"] ? Pos.fromJS(_data["pos"]) : new Pos();
            this.shipping = _data["shipping"] ? Shipping.fromJS(_data["shipping"]) : new Shipping();
            this.merchant = _data["merchant"] ? MerchantSummary.fromJS(_data["merchant"]) : new MerchantSummary();
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.deliveredTime = _data["deliveredTime"] ? new Date(_data["deliveredTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PosOrder {
        data = typeof data === 'object' ? data : {};
        let result = new PosOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posOrderId"] = this.posOrderId !== undefined ? this.posOrderId : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["posPrice"] = this.posPrice !== undefined ? this.posPrice : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["paymentMethod"] = this.paymentMethod !== undefined ? this.paymentMethod : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["paymentInstallmentCacheState"] = this.paymentInstallmentCacheState !== undefined ? this.paymentInstallmentCacheState : <any>null;
        if (Array.isArray(this.paymentItems)) {
            data["paymentItems"] = [];
            for (let item of this.paymentItems)
                data["paymentItems"].push(item.toJSON());
        }
        data["pos"] = this.pos ? this.pos.toJSON() : <any>null;
        data["shipping"] = this.shipping ? this.shipping.toJSON() : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["deliveredTime"] = this.deliveredTime ? this.deliveredTime.toISOString() : <any>null;
        return data;
    }
}

export interface IPosOrder {
    posOrderId: number;
    quantity: number;
    posPrice: number;
    description?: string | null;
    paymentMethod: PosOrderPaymentMethod;
    state: PosOrderState;
    paymentInstallmentCacheState?: PosOrderPaymentInstallmentCacheState | null;
    paymentItems?: PosOrderPaymentItem[] | null;
    pos: Pos;
    shipping: Shipping;
    merchant: MerchantSummary;
    createdTime: Date;
    deliveredTime?: Date | null;
}

export enum PosOrderState {
    Reserved = "Reserved",
    Created = "Created",
    Paid = "Paid",
    WaitingForPay = "WaitingForPay",
    PaymentOrderCaptured = "PaymentOrderCaptured",
    Delivered = "Delivered",
    Shipping = "Shipping",
    Failed = "Failed",
    WaitingForAutoPay = "WaitingForAutoPay",
    Paying = "Paying",
}

export enum PosOrderPaymentInstallmentCacheState {
    Completed = "Completed",
    Payable = "Payable",
    Failed = "Failed",
    Paying = "Paying",
    ReadyToRetry = "ReadyToRetry",
}

export class PosOrderPaymentItem implements IPosOrderPaymentItem {
    posOrderPaymentItemId!: number;
    error?: string | null;
    paymentOrderId?: number | null;
    amount?: number | null;
    state?: PaymentOrderState | null;
    modifiedTime!: Date;

    constructor(data?: IPosOrderPaymentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posOrderPaymentItemId = _data["posOrderPaymentItemId"] !== undefined ? _data["posOrderPaymentItemId"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.paymentOrderId = _data["paymentOrderId"] !== undefined ? _data["paymentOrderId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PosOrderPaymentItem {
        data = typeof data === 'object' ? data : {};
        let result = new PosOrderPaymentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posOrderPaymentItemId"] = this.posOrderPaymentItemId !== undefined ? this.posOrderPaymentItemId : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["paymentOrderId"] = this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        return data;
    }
}

export interface IPosOrderPaymentItem {
    posOrderPaymentItemId: number;
    error?: string | null;
    paymentOrderId?: number | null;
    amount?: number | null;
    state?: PaymentOrderState | null;
    modifiedTime: Date;
}

export class PosOrderStateLog implements IPosOrderStateLog {
    posOrderStateLogId!: number;
    state!: PosOrderState;
    description?: string | null;
    createdTime!: Date;

    constructor(data?: IPosOrderStateLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posOrderStateLogId = _data["posOrderStateLogId"] !== undefined ? _data["posOrderStateLogId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PosOrderStateLog {
        data = typeof data === 'object' ? data : {};
        let result = new PosOrderStateLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posOrderStateLogId"] = this.posOrderStateLogId !== undefined ? this.posOrderStateLogId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        return data;
    }
}

export interface IPosOrderStateLog {
    posOrderStateLogId: number;
    state: PosOrderState;
    description?: string | null;
    createdTime: Date;
}

export class PostPayInvoiceItem implements IPostPayInvoiceItem {
    postPayInvoiceItemId!: number;
    postPayInvoiceId!: number;
    merchant!: MerchantSummary;
    amount!: number;
    currency!: Currency;
    paymentOrder?: PaymentOrder | null;
    createdTime!: Date;
    description?: string | null;

    constructor(data?: IPostPayInvoiceItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.merchant = new MerchantSummary();
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postPayInvoiceItemId = _data["postPayInvoiceItemId"] !== undefined ? _data["postPayInvoiceItemId"] : <any>null;
            this.postPayInvoiceId = _data["postPayInvoiceId"] !== undefined ? _data["postPayInvoiceId"] : <any>null;
            this.merchant = _data["merchant"] ? MerchantSummary.fromJS(_data["merchant"]) : new MerchantSummary();
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.paymentOrder = _data["paymentOrder"] ? PaymentOrder.fromJS(_data["paymentOrder"]) : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): PostPayInvoiceItem {
        data = typeof data === 'object' ? data : {};
        let result = new PostPayInvoiceItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postPayInvoiceItemId"] = this.postPayInvoiceItemId !== undefined ? this.postPayInvoiceItemId : <any>null;
        data["postPayInvoiceId"] = this.postPayInvoiceId !== undefined ? this.postPayInvoiceId : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["paymentOrder"] = this.paymentOrder ? this.paymentOrder.toJSON() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IPostPayInvoiceItem {
    postPayInvoiceItemId: number;
    postPayInvoiceId: number;
    merchant: MerchantSummary;
    amount: number;
    currency: Currency;
    paymentOrder?: PaymentOrder | null;
    createdTime: Date;
    description?: string | null;
}

export class PriceList implements IPriceList {
    priceListId!: number;
    branchId!: number;
    merchantId!: number;
    priceListName?: string | null;
    parentPriceList?: PriceListSummary | null;
    assignedBranchId?: number | null;
    priceLists?: PriceList[] | null;

    constructor(data?: IPriceList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.priceListId = _data["priceListId"] !== undefined ? _data["priceListId"] : <any>null;
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.priceListName = _data["priceListName"] !== undefined ? _data["priceListName"] : <any>null;
            this.parentPriceList = _data["parentPriceList"] ? PriceListSummary.fromJS(_data["parentPriceList"]) : <any>null;
            this.assignedBranchId = _data["assignedBranchId"] !== undefined ? _data["assignedBranchId"] : <any>null;
            if (Array.isArray(_data["priceLists"])) {
                this.priceLists = [] as any;
                for (let item of _data["priceLists"])
                    this.priceLists!.push(PriceList.fromJS(item));
            }
            else {
                this.priceLists = <any>null;
            }
        }
    }

    static fromJS(data: any): PriceList {
        data = typeof data === 'object' ? data : {};
        let result = new PriceList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceListId"] = this.priceListId !== undefined ? this.priceListId : <any>null;
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["priceListName"] = this.priceListName !== undefined ? this.priceListName : <any>null;
        data["parentPriceList"] = this.parentPriceList ? this.parentPriceList.toJSON() : <any>null;
        data["assignedBranchId"] = this.assignedBranchId !== undefined ? this.assignedBranchId : <any>null;
        if (Array.isArray(this.priceLists)) {
            data["priceLists"] = [];
            for (let item of this.priceLists)
                data["priceLists"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPriceList {
    priceListId: number;
    branchId: number;
    merchantId: number;
    priceListName?: string | null;
    parentPriceList?: PriceListSummary | null;
    assignedBranchId?: number | null;
    priceLists?: PriceList[] | null;
}

export class CreatePriceListRequest implements ICreatePriceListRequest {
    priceListName!: string;
    parentPriceListId?: number | null;

    constructor(data?: ICreatePriceListRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.priceListName = _data["priceListName"] !== undefined ? _data["priceListName"] : <any>null;
            this.parentPriceListId = _data["parentPriceListId"] !== undefined ? _data["parentPriceListId"] : <any>null;
        }
    }

    static fromJS(data: any): CreatePriceListRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePriceListRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceListName"] = this.priceListName !== undefined ? this.priceListName : <any>null;
        data["parentPriceListId"] = this.parentPriceListId !== undefined ? this.parentPriceListId : <any>null;
        return data;
    }
}

export interface ICreatePriceListRequest {
    priceListName: string;
    parentPriceListId?: number | null;
}

export class BuyPrice implements IBuyPrice {
    product!: ProductSummary;
    regions?: Region[] | null;
    rules!: BuyPriceRule[];

    constructor(data?: IBuyPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.product = new ProductSummary();
            this.rules = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? ProductSummary.fromJS(_data["product"]) : new ProductSummary();
            if (Array.isArray(_data["regions"])) {
                this.regions = [] as any;
                for (let item of _data["regions"])
                    this.regions!.push(Region.fromJS(item));
            }
            else {
                this.regions = <any>null;
            }
            if (Array.isArray(_data["rules"])) {
                this.rules = [] as any;
                for (let item of _data["rules"])
                    this.rules!.push(BuyPriceRule.fromJS(item));
            }
            else {
                this.rules = <any>null;
            }
        }
    }

    static fromJS(data: any): BuyPrice {
        data = typeof data === 'object' ? data : {};
        let result = new BuyPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>null;
        if (Array.isArray(this.regions)) {
            data["regions"] = [];
            for (let item of this.regions)
                data["regions"].push(item.toJSON());
        }
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBuyPrice {
    product: ProductSummary;
    regions?: Region[] | null;
    rules: BuyPriceRule[];
}

export class ProductSummary implements IProductSummary {
    productId!: number;
    productName!: string;
    imageUrl?: string | null;
    providerSku!: string;
    upc?: string | null;
    isPhysical!: boolean;
    hasDescription!: boolean;
    category!: CategorySummary;
    currency!: Currency;

    constructor(data?: IProductSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.category = new CategorySummary();
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
            this.productName = _data["productName"] !== undefined ? _data["productName"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.providerSku = _data["providerSku"] !== undefined ? _data["providerSku"] : <any>null;
            this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
            this.isPhysical = _data["isPhysical"] !== undefined ? _data["isPhysical"] : <any>null;
            this.hasDescription = _data["hasDescription"] !== undefined ? _data["hasDescription"] : <any>null;
            this.category = _data["category"] ? CategorySummary.fromJS(_data["category"]) : new CategorySummary();
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
        }
    }

    static fromJS(data: any): ProductSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        data["productName"] = this.productName !== undefined ? this.productName : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["providerSku"] = this.providerSku !== undefined ? this.providerSku : <any>null;
        data["upc"] = this.upc !== undefined ? this.upc : <any>null;
        data["isPhysical"] = this.isPhysical !== undefined ? this.isPhysical : <any>null;
        data["hasDescription"] = this.hasDescription !== undefined ? this.hasDescription : <any>null;
        data["category"] = this.category ? this.category.toJSON() : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        return data;
    }
}

export interface IProductSummary {
    productId: number;
    productName: string;
    imageUrl?: string | null;
    providerSku: string;
    upc?: string | null;
    isPhysical: boolean;
    hasDescription: boolean;
    category: CategorySummary;
    currency: Currency;
}

export class CategorySummary implements ICategorySummary {
    categoryId!: number;
    categoryName!: string;

    constructor(data?: ICategorySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
        }
    }

    static fromJS(data: any): CategorySummary {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        return data;
    }
}

export interface ICategorySummary {
    categoryId: number;
    categoryName: string;
}

export class Region implements IRegion {
    regionId!: number;
    name!: string;
    code!: string;
    imageUrl?: string | null;

    constructor(data?: IRegion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): Region {
        data = typeof data === 'object' ? data : {};
        let result = new Region();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export interface IRegion {
    regionId: number;
    name: string;
    code: string;
    imageUrl?: string | null;
}

export class BuyPriceRule implements IBuyPriceRule {
    faceValue!: PriceRange;
    priceValue!: number;
    consumerTax!: number;
    consumerFee!: number;
    resellPriceAmount!: PriceRange;
    consumerPriceAmount!: PriceRange;
    buyingPriceAmount!: PriceRange;

    constructor(data?: IBuyPriceRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.faceValue = new PriceRange();
            this.resellPriceAmount = new PriceRange();
            this.consumerPriceAmount = new PriceRange();
            this.buyingPriceAmount = new PriceRange();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.faceValue = _data["faceValue"] ? PriceRange.fromJS(_data["faceValue"]) : new PriceRange();
            this.priceValue = _data["priceValue"] !== undefined ? _data["priceValue"] : <any>null;
            this.consumerTax = _data["consumerTax"] !== undefined ? _data["consumerTax"] : <any>null;
            this.consumerFee = _data["consumerFee"] !== undefined ? _data["consumerFee"] : <any>null;
            this.resellPriceAmount = _data["resellPriceAmount"] ? PriceRange.fromJS(_data["resellPriceAmount"]) : new PriceRange();
            this.consumerPriceAmount = _data["consumerPriceAmount"] ? PriceRange.fromJS(_data["consumerPriceAmount"]) : new PriceRange();
            this.buyingPriceAmount = _data["buyingPriceAmount"] ? PriceRange.fromJS(_data["buyingPriceAmount"]) : new PriceRange();
        }
    }

    static fromJS(data: any): BuyPriceRule {
        data = typeof data === 'object' ? data : {};
        let result = new BuyPriceRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["faceValue"] = this.faceValue ? this.faceValue.toJSON() : <any>null;
        data["priceValue"] = this.priceValue !== undefined ? this.priceValue : <any>null;
        data["consumerTax"] = this.consumerTax !== undefined ? this.consumerTax : <any>null;
        data["consumerFee"] = this.consumerFee !== undefined ? this.consumerFee : <any>null;
        data["resellPriceAmount"] = this.resellPriceAmount ? this.resellPriceAmount.toJSON() : <any>null;
        data["consumerPriceAmount"] = this.consumerPriceAmount ? this.consumerPriceAmount.toJSON() : <any>null;
        data["buyingPriceAmount"] = this.buyingPriceAmount ? this.buyingPriceAmount.toJSON() : <any>null;
        return data;
    }
}

export interface IBuyPriceRule {
    faceValue: PriceRange;
    priceValue: number;
    consumerTax: number;
    consumerFee: number;
    resellPriceAmount: PriceRange;
    consumerPriceAmount: PriceRange;
    buyingPriceAmount: PriceRange;
}

export class PriceRange implements IPriceRange {
    start!: number;
    end?: number | null;
    endValue!: number;
    isEndless!: boolean;

    constructor(data?: IPriceRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.start = _data["start"] !== undefined ? _data["start"] : <any>null;
            this.end = _data["end"] !== undefined ? _data["end"] : <any>null;
            this.endValue = _data["endValue"] !== undefined ? _data["endValue"] : <any>null;
            this.isEndless = _data["isEndless"] !== undefined ? _data["isEndless"] : <any>null;
        }
    }

    static fromJS(data: any): PriceRange {
        data = typeof data === 'object' ? data : {};
        let result = new PriceRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["start"] = this.start !== undefined ? this.start : <any>null;
        data["end"] = this.end !== undefined ? this.end : <any>null;
        data["endValue"] = this.endValue !== undefined ? this.endValue : <any>null;
        data["isEndless"] = this.isEndless !== undefined ? this.isEndless : <any>null;
        return data;
    }
}

export interface IPriceRange {
    start: number;
    end?: number | null;
    endValue: number;
    isEndless: boolean;
}

export class PriceView implements IPriceView {
    price!: Price;
    priceResults!: PriceResult[];

    constructor(data?: IPriceView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.price = new Price();
            this.priceResults = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.price = _data["price"] ? Price.fromJS(_data["price"]) : new Price();
            if (Array.isArray(_data["priceResults"])) {
                this.priceResults = [] as any;
                for (let item of _data["priceResults"])
                    this.priceResults!.push(PriceResult.fromJS(item));
            }
            else {
                this.priceResults = <any>null;
            }
        }
    }

    static fromJS(data: any): PriceView {
        data = typeof data === 'object' ? data : {};
        let result = new PriceView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["price"] = this.price ? this.price.toJSON() : <any>null;
        if (Array.isArray(this.priceResults)) {
            data["priceResults"] = [];
            for (let item of this.priceResults)
                data["priceResults"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPriceView {
    price: Price;
    priceResults: PriceResult[];
}

export class Price implements IPrice {
    product!: ProductSummary;
    currency!: Currency;
    regions?: Region[] | null;
    isRoot!: boolean;
    rules!: PriceRule[];

    constructor(data?: IPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.product = new ProductSummary();
            this.currency = new Currency();
            this.rules = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? ProductSummary.fromJS(_data["product"]) : new ProductSummary();
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            if (Array.isArray(_data["regions"])) {
                this.regions = [] as any;
                for (let item of _data["regions"])
                    this.regions!.push(Region.fromJS(item));
            }
            else {
                this.regions = <any>null;
            }
            this.isRoot = _data["isRoot"] !== undefined ? _data["isRoot"] : <any>null;
            if (Array.isArray(_data["rules"])) {
                this.rules = [] as any;
                for (let item of _data["rules"])
                    this.rules!.push(PriceRule.fromJS(item));
            }
            else {
                this.rules = <any>null;
            }
        }
    }

    static fromJS(data: any): Price {
        data = typeof data === 'object' ? data : {};
        let result = new Price();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        if (Array.isArray(this.regions)) {
            data["regions"] = [];
            for (let item of this.regions)
                data["regions"].push(item.toJSON());
        }
        data["isRoot"] = this.isRoot !== undefined ? this.isRoot : <any>null;
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPrice {
    product: ProductSummary;
    currency: Currency;
    regions?: Region[] | null;
    isRoot: boolean;
    rules: PriceRule[];
}

export class PriceRule implements IPriceRule {
    faceValue!: PriceRange;
    priceValueMode?: PriceValueMode | null;
    priceValue?: number | null;
    step?: number | null;
    minBenefit?: number | null;
    consumerTax?: number | null;
    consumerFee?: number | null;
    isActive?: boolean | null;
    permission!: PriceRulePermission;

    constructor(data?: IPriceRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.faceValue = new PriceRange();
            this.permission = new PriceRulePermission();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.faceValue = _data["faceValue"] ? PriceRange.fromJS(_data["faceValue"]) : new PriceRange();
            this.priceValueMode = _data["priceValueMode"] !== undefined ? _data["priceValueMode"] : <any>null;
            this.priceValue = _data["priceValue"] !== undefined ? _data["priceValue"] : <any>null;
            this.step = _data["step"] !== undefined ? _data["step"] : <any>null;
            this.minBenefit = _data["minBenefit"] !== undefined ? _data["minBenefit"] : <any>null;
            this.consumerTax = _data["consumerTax"] !== undefined ? _data["consumerTax"] : <any>null;
            this.consumerFee = _data["consumerFee"] !== undefined ? _data["consumerFee"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.permission = _data["permission"] ? PriceRulePermission.fromJS(_data["permission"]) : new PriceRulePermission();
        }
    }

    static fromJS(data: any): PriceRule {
        data = typeof data === 'object' ? data : {};
        let result = new PriceRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["faceValue"] = this.faceValue ? this.faceValue.toJSON() : <any>null;
        data["priceValueMode"] = this.priceValueMode !== undefined ? this.priceValueMode : <any>null;
        data["priceValue"] = this.priceValue !== undefined ? this.priceValue : <any>null;
        data["step"] = this.step !== undefined ? this.step : <any>null;
        data["minBenefit"] = this.minBenefit !== undefined ? this.minBenefit : <any>null;
        data["consumerTax"] = this.consumerTax !== undefined ? this.consumerTax : <any>null;
        data["consumerFee"] = this.consumerFee !== undefined ? this.consumerFee : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>null;
        return data;
    }
}

export interface IPriceRule {
    faceValue: PriceRange;
    priceValueMode?: PriceValueMode | null;
    priceValue?: number | null;
    step?: number | null;
    minBenefit?: number | null;
    consumerTax?: number | null;
    consumerFee?: number | null;
    isActive?: boolean | null;
    permission: PriceRulePermission;
}

export enum PriceValueMode {
    FaceValue = 0,
    BuyValue = 1,
}

export class PriceRulePermission implements IPriceRulePermission {
    canSetPriceModeToFaceValue?: boolean | null;
    minMinBenefit?: number | null;
    maxConsumerFee?: number | null;
    maxConsumerTax?: number | null;

    constructor(data?: IPriceRulePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canSetPriceModeToFaceValue = _data["canSetPriceModeToFaceValue"] !== undefined ? _data["canSetPriceModeToFaceValue"] : <any>null;
            this.minMinBenefit = _data["minMinBenefit"] !== undefined ? _data["minMinBenefit"] : <any>null;
            this.maxConsumerFee = _data["maxConsumerFee"] !== undefined ? _data["maxConsumerFee"] : <any>null;
            this.maxConsumerTax = _data["maxConsumerTax"] !== undefined ? _data["maxConsumerTax"] : <any>null;
        }
    }

    static fromJS(data: any): PriceRulePermission {
        data = typeof data === 'object' ? data : {};
        let result = new PriceRulePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canSetPriceModeToFaceValue"] = this.canSetPriceModeToFaceValue !== undefined ? this.canSetPriceModeToFaceValue : <any>null;
        data["minMinBenefit"] = this.minMinBenefit !== undefined ? this.minMinBenefit : <any>null;
        data["maxConsumerFee"] = this.maxConsumerFee !== undefined ? this.maxConsumerFee : <any>null;
        data["maxConsumerTax"] = this.maxConsumerTax !== undefined ? this.maxConsumerTax : <any>null;
        return data;
    }
}

export interface IPriceRulePermission {
    canSetPriceModeToFaceValue?: boolean | null;
    minMinBenefit?: number | null;
    maxConsumerFee?: number | null;
    maxConsumerTax?: number | null;
}

export class PriceResult implements IPriceResult {
    buyingRule?: PriceRule | null;
    masterRule?: PriceRule | null;
    rule!: PriceRule;
    buyingPriceAmount?: PriceRange | null;
    resellPriceAmount?: PriceRange | null;
    consumerPriceAmount?: PriceRange | null;
    benefit?: number | null;
    errors!: PriceRuleError[];

    constructor(data?: IPriceResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.rule = new PriceRule();
            this.errors = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.buyingRule = _data["buyingRule"] ? PriceRule.fromJS(_data["buyingRule"]) : <any>null;
            this.masterRule = _data["masterRule"] ? PriceRule.fromJS(_data["masterRule"]) : <any>null;
            this.rule = _data["rule"] ? PriceRule.fromJS(_data["rule"]) : new PriceRule();
            this.buyingPriceAmount = _data["buyingPriceAmount"] ? PriceRange.fromJS(_data["buyingPriceAmount"]) : <any>null;
            this.resellPriceAmount = _data["resellPriceAmount"] ? PriceRange.fromJS(_data["resellPriceAmount"]) : <any>null;
            this.consumerPriceAmount = _data["consumerPriceAmount"] ? PriceRange.fromJS(_data["consumerPriceAmount"]) : <any>null;
            this.benefit = _data["benefit"] !== undefined ? _data["benefit"] : <any>null;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(PriceRuleError.fromJS(item));
            }
            else {
                this.errors = <any>null;
            }
        }
    }

    static fromJS(data: any): PriceResult {
        data = typeof data === 'object' ? data : {};
        let result = new PriceResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buyingRule"] = this.buyingRule ? this.buyingRule.toJSON() : <any>null;
        data["masterRule"] = this.masterRule ? this.masterRule.toJSON() : <any>null;
        data["rule"] = this.rule ? this.rule.toJSON() : <any>null;
        data["buyingPriceAmount"] = this.buyingPriceAmount ? this.buyingPriceAmount.toJSON() : <any>null;
        data["resellPriceAmount"] = this.resellPriceAmount ? this.resellPriceAmount.toJSON() : <any>null;
        data["consumerPriceAmount"] = this.consumerPriceAmount ? this.consumerPriceAmount.toJSON() : <any>null;
        data["benefit"] = this.benefit !== undefined ? this.benefit : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPriceResult {
    buyingRule?: PriceRule | null;
    masterRule?: PriceRule | null;
    rule: PriceRule;
    buyingPriceAmount?: PriceRange | null;
    resellPriceAmount?: PriceRange | null;
    consumerPriceAmount?: PriceRange | null;
    benefit?: number | null;
    errors: PriceRuleError[];
}

export class PriceRuleError implements IPriceRuleError {
    propertyName!: string;
    message!: string;

    constructor(data?: IPriceRuleError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"] !== undefined ? _data["propertyName"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): PriceRuleError {
        data = typeof data === 'object' ? data : {};
        let result = new PriceRuleError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName !== undefined ? this.propertyName : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export interface IPriceRuleError {
    propertyName: string;
    message: string;
}

export class ProductPriceRule implements IProductPriceRule {
    productId!: number;
    rules!: PriceRule[];

    constructor(data?: IProductPriceRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.rules = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
            if (Array.isArray(_data["rules"])) {
                this.rules = [] as any;
                for (let item of _data["rules"])
                    this.rules!.push(PriceRule.fromJS(item));
            }
            else {
                this.rules = <any>null;
            }
        }
    }

    static fromJS(data: any): ProductPriceRule {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPriceRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        if (Array.isArray(this.rules)) {
            data["rules"] = [];
            for (let item of this.rules)
                data["rules"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductPriceRule {
    productId: number;
    rules: PriceRule[];
}

export class Product implements IProduct {
    productId!: number;
    productName!: string;
    regions?: Region[] | null;
    providerSku!: string;
    canPreOrder?: boolean | null;
    canImmediate?: boolean | null;
    isActive?: boolean | null;
    upc?: string | null;
    isPhysical!: boolean;
    description?: string | null;
    categoryId!: number;
    imageUrl?: string | null;
    currency!: Currency;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
            this.productName = _data["productName"] !== undefined ? _data["productName"] : <any>null;
            if (Array.isArray(_data["regions"])) {
                this.regions = [] as any;
                for (let item of _data["regions"])
                    this.regions!.push(Region.fromJS(item));
            }
            else {
                this.regions = <any>null;
            }
            this.providerSku = _data["providerSku"] !== undefined ? _data["providerSku"] : <any>null;
            this.canPreOrder = _data["canPreOrder"] !== undefined ? _data["canPreOrder"] : <any>null;
            this.canImmediate = _data["canImmediate"] !== undefined ? _data["canImmediate"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
            this.isPhysical = _data["isPhysical"] !== undefined ? _data["isPhysical"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        data["productName"] = this.productName !== undefined ? this.productName : <any>null;
        if (Array.isArray(this.regions)) {
            data["regions"] = [];
            for (let item of this.regions)
                data["regions"].push(item.toJSON());
        }
        data["providerSku"] = this.providerSku !== undefined ? this.providerSku : <any>null;
        data["canPreOrder"] = this.canPreOrder !== undefined ? this.canPreOrder : <any>null;
        data["canImmediate"] = this.canImmediate !== undefined ? this.canImmediate : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["upc"] = this.upc !== undefined ? this.upc : <any>null;
        data["isPhysical"] = this.isPhysical !== undefined ? this.isPhysical : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        return data;
    }
}

export interface IProduct {
    productId: number;
    productName: string;
    regions?: Region[] | null;
    providerSku: string;
    canPreOrder?: boolean | null;
    canImmediate?: boolean | null;
    isActive?: boolean | null;
    upc?: string | null;
    isPhysical: boolean;
    description?: string | null;
    categoryId: number;
    imageUrl?: string | null;
    currency: Currency;
}

export class CreateProductRequest implements ICreateProductRequest {
    productName!: string;
    providerSku!: string;
    currencyId!: number;
    description?: string | null;
    upc?: string | null;
    categoryId!: number;
    imageUrl?: string | null;

    constructor(data?: ICreateProductRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["productName"] !== undefined ? _data["productName"] : <any>null;
            this.providerSku = _data["providerSku"] !== undefined ? _data["providerSku"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): CreateProductRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName !== undefined ? this.productName : <any>null;
        data["providerSku"] = this.providerSku !== undefined ? this.providerSku : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["upc"] = this.upc !== undefined ? this.upc : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export interface ICreateProductRequest {
    productName: string;
    providerSku: string;
    currencyId: number;
    description?: string | null;
    upc?: string | null;
    categoryId: number;
    imageUrl?: string | null;
}

export class UpdateProductRequest implements IUpdateProductRequest {
    regionIds?: PatchOfInt32Of | null;
    categoryId?: PatchOfInteger | null;
    imageUrl?: PatchOfUri | null;
    productName?: PatchOfString | null;
    description?: PatchOfString | null;

    constructor(data?: IUpdateProductRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regionIds = _data["regionIds"] ? PatchOfInt32Of.fromJS(_data["regionIds"]) : <any>null;
            this.categoryId = _data["categoryId"] ? PatchOfInteger.fromJS(_data["categoryId"]) : <any>null;
            this.imageUrl = _data["imageUrl"] ? PatchOfUri.fromJS(_data["imageUrl"]) : <any>null;
            this.productName = _data["productName"] ? PatchOfString.fromJS(_data["productName"]) : <any>null;
            this.description = _data["description"] ? PatchOfString.fromJS(_data["description"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateProductRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionIds"] = this.regionIds ? this.regionIds.toJSON() : <any>null;
        data["categoryId"] = this.categoryId ? this.categoryId.toJSON() : <any>null;
        data["imageUrl"] = this.imageUrl ? this.imageUrl.toJSON() : <any>null;
        data["productName"] = this.productName ? this.productName.toJSON() : <any>null;
        data["description"] = this.description ? this.description.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateProductRequest {
    regionIds?: PatchOfInt32Of | null;
    categoryId?: PatchOfInteger | null;
    imageUrl?: PatchOfUri | null;
    productName?: PatchOfString | null;
    description?: PatchOfString | null;
}

export class PatchOfInt32Of implements IPatchOfInt32Of {
    value?: number[] | null;

    constructor(data?: IPatchOfInt32Of) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            else {
                this.value = <any>null;
            }
        }
    }

    static fromJS(data: any): PatchOfInt32Of {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfInt32Of();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export interface IPatchOfInt32Of {
    value?: number[] | null;
}

export class ProductItem implements IProductItem {
    productId!: number;
    productName!: string;
    faceValue!: number;
    currency!: Currency;
    availableCount!: number;

    constructor(data?: IProductItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
            this.productName = _data["productName"] !== undefined ? _data["productName"] : <any>null;
            this.faceValue = _data["faceValue"] !== undefined ? _data["faceValue"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.availableCount = _data["availableCount"] !== undefined ? _data["availableCount"] : <any>null;
        }
    }

    static fromJS(data: any): ProductItem {
        data = typeof data === 'object' ? data : {};
        let result = new ProductItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        data["productName"] = this.productName !== undefined ? this.productName : <any>null;
        data["faceValue"] = this.faceValue !== undefined ? this.faceValue : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["availableCount"] = this.availableCount !== undefined ? this.availableCount : <any>null;
        return data;
    }
}

export interface IProductItem {
    productId: number;
    productName: string;
    faceValue: number;
    currency: Currency;
    availableCount: number;
}

export class CreateRegionRequest implements ICreateRegionRequest {
    name!: string;
    code!: string;
    imageUrl?: string | null;

    constructor(data?: ICreateRegionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
        }
    }

    static fromJS(data: any): CreateRegionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRegionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        return data;
    }
}

export interface ICreateRegionRequest {
    name: string;
    code: string;
    imageUrl?: string | null;
}

export class UpdateRegionRequest implements IUpdateRegionRequest {
    name?: PatchOfString | null;
    code?: PatchOfString | null;
    imageUrl?: PatchOfUri | null;

    constructor(data?: IUpdateRegionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? PatchOfString.fromJS(_data["name"]) : <any>null;
            this.code = _data["code"] ? PatchOfString.fromJS(_data["code"]) : <any>null;
            this.imageUrl = _data["imageUrl"] ? PatchOfUri.fromJS(_data["imageUrl"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateRegionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRegionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>null;
        data["code"] = this.code ? this.code.toJSON() : <any>null;
        data["imageUrl"] = this.imageUrl ? this.imageUrl.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateRegionRequest {
    name?: PatchOfString | null;
    code?: PatchOfString | null;
    imageUrl?: PatchOfUri | null;
}

export class Report implements IReport {
    wallet!: Wallet;
    credit?: Wallet | null;
    customersCreditsAndWallets?: CustomerCreditAndWallet | null;
    customersAccounting!: CustomerAccountingReport[];
    officesAccounting!: OfficeAccountingReport[];
    saleManagersAccounting!: SaleManagerAccountingReport[];
    topProducts!: ProductReport[];

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.wallet = new Wallet();
            this.customersAccounting = [];
            this.officesAccounting = [];
            this.saleManagersAccounting = [];
            this.topProducts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wallet = _data["wallet"] ? Wallet.fromJS(_data["wallet"]) : new Wallet();
            this.credit = _data["credit"] ? Wallet.fromJS(_data["credit"]) : <any>null;
            this.customersCreditsAndWallets = _data["customersCreditsAndWallets"] ? CustomerCreditAndWallet.fromJS(_data["customersCreditsAndWallets"]) : <any>null;
            if (Array.isArray(_data["customersAccounting"])) {
                this.customersAccounting = [] as any;
                for (let item of _data["customersAccounting"])
                    this.customersAccounting!.push(CustomerAccountingReport.fromJS(item));
            }
            else {
                this.customersAccounting = <any>null;
            }
            if (Array.isArray(_data["officesAccounting"])) {
                this.officesAccounting = [] as any;
                for (let item of _data["officesAccounting"])
                    this.officesAccounting!.push(OfficeAccountingReport.fromJS(item));
            }
            else {
                this.officesAccounting = <any>null;
            }
            if (Array.isArray(_data["saleManagersAccounting"])) {
                this.saleManagersAccounting = [] as any;
                for (let item of _data["saleManagersAccounting"])
                    this.saleManagersAccounting!.push(SaleManagerAccountingReport.fromJS(item));
            }
            else {
                this.saleManagersAccounting = <any>null;
            }
            if (Array.isArray(_data["topProducts"])) {
                this.topProducts = [] as any;
                for (let item of _data["topProducts"])
                    this.topProducts!.push(ProductReport.fromJS(item));
            }
            else {
                this.topProducts = <any>null;
            }
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>null;
        data["credit"] = this.credit ? this.credit.toJSON() : <any>null;
        data["customersCreditsAndWallets"] = this.customersCreditsAndWallets ? this.customersCreditsAndWallets.toJSON() : <any>null;
        if (Array.isArray(this.customersAccounting)) {
            data["customersAccounting"] = [];
            for (let item of this.customersAccounting)
                data["customersAccounting"].push(item.toJSON());
        }
        if (Array.isArray(this.officesAccounting)) {
            data["officesAccounting"] = [];
            for (let item of this.officesAccounting)
                data["officesAccounting"].push(item.toJSON());
        }
        if (Array.isArray(this.saleManagersAccounting)) {
            data["saleManagersAccounting"] = [];
            for (let item of this.saleManagersAccounting)
                data["saleManagersAccounting"].push(item.toJSON());
        }
        if (Array.isArray(this.topProducts)) {
            data["topProducts"] = [];
            for (let item of this.topProducts)
                data["topProducts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReport {
    wallet: Wallet;
    credit?: Wallet | null;
    customersCreditsAndWallets?: CustomerCreditAndWallet | null;
    customersAccounting: CustomerAccountingReport[];
    officesAccounting: OfficeAccountingReport[];
    saleManagersAccounting: SaleManagerAccountingReport[];
    topProducts: ProductReport[];
}

export class CustomerCreditAndWallet implements ICustomerCreditAndWallet {
    wallet?: CurrencyBalance[] | null;
    credit?: CurrencyBalance[] | null;

    constructor(data?: ICustomerCreditAndWallet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["wallet"])) {
                this.wallet = [] as any;
                for (let item of _data["wallet"])
                    this.wallet!.push(CurrencyBalance.fromJS(item));
            }
            else {
                this.wallet = <any>null;
            }
            if (Array.isArray(_data["credit"])) {
                this.credit = [] as any;
                for (let item of _data["credit"])
                    this.credit!.push(CurrencyBalance.fromJS(item));
            }
            else {
                this.credit = <any>null;
            }
        }
    }

    static fromJS(data: any): CustomerCreditAndWallet {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerCreditAndWallet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.wallet)) {
            data["wallet"] = [];
            for (let item of this.wallet)
                data["wallet"].push(item.toJSON());
        }
        if (Array.isArray(this.credit)) {
            data["credit"] = [];
            for (let item of this.credit)
                data["credit"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomerCreditAndWallet {
    wallet?: CurrencyBalance[] | null;
    credit?: CurrencyBalance[] | null;
}

export class CustomerAccountingReport implements ICustomerAccountingReport {
    saleAmount!: number;
    profit!: number;
    currency!: Currency;
    customer!: MerchantSummary;
    date!: Date;

    constructor(data?: ICustomerAccountingReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
            this.customer = new MerchantSummary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saleAmount = _data["saleAmount"] !== undefined ? _data["saleAmount"] : <any>null;
            this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.customer = _data["customer"] ? MerchantSummary.fromJS(_data["customer"]) : new MerchantSummary();
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): CustomerAccountingReport {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAccountingReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleAmount"] = this.saleAmount !== undefined ? this.saleAmount : <any>null;
        data["profit"] = this.profit !== undefined ? this.profit : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>null;
        data["date"] = this.date ? formatDate(this.date) : <any>null;
        return data;
    }
}

export interface ICustomerAccountingReport {
    saleAmount: number;
    profit: number;
    currency: Currency;
    customer: MerchantSummary;
    date: Date;
}

export class OfficeAccountingReport implements IOfficeAccountingReport {
    saleAmount!: number;
    profit!: number;
    currency!: Currency;
    branch!: BranchSummary;
    date!: Date;

    constructor(data?: IOfficeAccountingReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
            this.branch = new BranchSummary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saleAmount = _data["saleAmount"] !== undefined ? _data["saleAmount"] : <any>null;
            this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.branch = _data["branch"] ? BranchSummary.fromJS(_data["branch"]) : new BranchSummary();
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): OfficeAccountingReport {
        data = typeof data === 'object' ? data : {};
        let result = new OfficeAccountingReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleAmount"] = this.saleAmount !== undefined ? this.saleAmount : <any>null;
        data["profit"] = this.profit !== undefined ? this.profit : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>null;
        data["date"] = this.date ? formatDate(this.date) : <any>null;
        return data;
    }
}

export interface IOfficeAccountingReport {
    saleAmount: number;
    profit: number;
    currency: Currency;
    branch: BranchSummary;
    date: Date;
}

export class BranchSummary implements IBranchSummary {
    branchId!: number;
    branchName!: string;

    constructor(data?: IBranchSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.branchName = _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
        }
    }

    static fromJS(data: any): BranchSummary {
        data = typeof data === 'object' ? data : {};
        let result = new BranchSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["branchName"] = this.branchName !== undefined ? this.branchName : <any>null;
        return data;
    }
}

export interface IBranchSummary {
    branchId: number;
    branchName: string;
}

export class SaleManagerAccountingReport implements ISaleManagerAccountingReport {
    saleAmount!: number;
    profit!: number;
    currency!: Currency;
    saleManager?: SaleManagerSummary | null;
    date!: Date;

    constructor(data?: ISaleManagerAccountingReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saleAmount = _data["saleAmount"] !== undefined ? _data["saleAmount"] : <any>null;
            this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.saleManager = _data["saleManager"] ? SaleManagerSummary.fromJS(_data["saleManager"]) : <any>null;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): SaleManagerAccountingReport {
        data = typeof data === 'object' ? data : {};
        let result = new SaleManagerAccountingReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleAmount"] = this.saleAmount !== undefined ? this.saleAmount : <any>null;
        data["profit"] = this.profit !== undefined ? this.profit : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["saleManager"] = this.saleManager ? this.saleManager.toJSON() : <any>null;
        data["date"] = this.date ? formatDate(this.date) : <any>null;
        return data;
    }
}

export interface ISaleManagerAccountingReport {
    saleAmount: number;
    profit: number;
    currency: Currency;
    saleManager?: SaleManagerSummary | null;
    date: Date;
}

export class ProductReport implements IProductReport {
    product!: ProductSummary;
    saleCounts!: number;
    profit!: number;

    constructor(data?: IProductReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.product = new ProductSummary();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? ProductSummary.fromJS(_data["product"]) : new ProductSummary();
            this.saleCounts = _data["saleCounts"] !== undefined ? _data["saleCounts"] : <any>null;
            this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
        }
    }

    static fromJS(data: any): ProductReport {
        data = typeof data === 'object' ? data : {};
        let result = new ProductReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>null;
        data["saleCounts"] = this.saleCounts !== undefined ? this.saleCounts : <any>null;
        data["profit"] = this.profit !== undefined ? this.profit : <any>null;
        return data;
    }
}

export interface IProductReport {
    product: ProductSummary;
    saleCounts: number;
    profit: number;
}

export class ReportSummary implements IReportSummary {
    currency!: Currency;
    saleAmount!: number;
    count!: number;

    constructor(data?: IReportSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.saleAmount = _data["saleAmount"] !== undefined ? _data["saleAmount"] : <any>null;
            this.count = _data["count"] !== undefined ? _data["count"] : <any>null;
        }
    }

    static fromJS(data: any): ReportSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ReportSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["saleAmount"] = this.saleAmount !== undefined ? this.saleAmount : <any>null;
        data["count"] = this.count !== undefined ? this.count : <any>null;
        return data;
    }
}

export interface IReportSummary {
    currency: Currency;
    saleAmount: number;
    count: number;
}

export class SaleManager implements ISaleManager {
    saleManagerId!: number;
    name!: string;
    email!: string;
    phoneNumber?: Phone | null;
    isActive!: boolean;

    constructor(data?: ISaleManager) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saleManagerId = _data["saleManagerId"] !== undefined ? _data["saleManagerId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] ? Phone.fromJS(_data["phoneNumber"]) : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
        }
    }

    static fromJS(data: any): SaleManager {
        data = typeof data === 'object' ? data : {};
        let result = new SaleManager();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleManagerId"] = this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        return data;
    }
}

export interface ISaleManager {
    saleManagerId: number;
    name: string;
    email: string;
    phoneNumber?: Phone | null;
    isActive: boolean;
}

export class CreateSaleManagerRequest implements ICreateSaleManagerRequest {
    name!: string;
    email!: string;
    userId!: string;
    phoneNumber?: Phone | null;

    constructor(data?: ICreateSaleManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] ? Phone.fromJS(_data["phoneNumber"]) : <any>null;
        }
    }

    static fromJS(data: any): CreateSaleManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSaleManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>null;
        return data;
    }
}

export interface ICreateSaleManagerRequest {
    name: string;
    email: string;
    userId: string;
    phoneNumber?: Phone | null;
}

export class UpdateSaleManagerRequest implements IUpdateSaleManagerRequest {
    name?: PatchOfString | null;
    email?: PatchOfString | null;
    phoneNumber?: PatchOfPhone | null;
    isActive?: PatchOfNullableBoolean | null;

    constructor(data?: IUpdateSaleManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? PatchOfString.fromJS(_data["name"]) : <any>null;
            this.email = _data["email"] ? PatchOfString.fromJS(_data["email"]) : <any>null;
            this.phoneNumber = _data["phoneNumber"] ? PatchOfPhone.fromJS(_data["phoneNumber"]) : <any>null;
            this.isActive = _data["isActive"] ? PatchOfNullableBoolean.fromJS(_data["isActive"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateSaleManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSaleManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>null;
        data["email"] = this.email ? this.email.toJSON() : <any>null;
        data["phoneNumber"] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>null;
        data["isActive"] = this.isActive ? this.isActive.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateSaleManagerRequest {
    name?: PatchOfString | null;
    email?: PatchOfString | null;
    phoneNumber?: PatchOfPhone | null;
    isActive?: PatchOfNullableBoolean | null;
}

export class SettingModel implements ISettingModel {
    settingId!: number;
    startInvoiceDate?: Date | null;
    invoiceDailyTime?: Date | null;
    postPayCurrencyId?: number | null;
    defaultExchangeTargetCurrencyId?: number | null;
    defaultExchangeTargetCurrency?: CurrencyModel | null;

    constructor(data?: ISettingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settingId = _data["settingId"] !== undefined ? _data["settingId"] : <any>null;
            this.startInvoiceDate = _data["startInvoiceDate"] ? new Date(_data["startInvoiceDate"].toString()) : <any>null;
            this.invoiceDailyTime = _data["invoiceDailyTime"] ? new Date(_data["invoiceDailyTime"].toString()) : <any>null;
            this.postPayCurrencyId = _data["postPayCurrencyId"] !== undefined ? _data["postPayCurrencyId"] : <any>null;
            this.defaultExchangeTargetCurrencyId = _data["defaultExchangeTargetCurrencyId"] !== undefined ? _data["defaultExchangeTargetCurrencyId"] : <any>null;
            this.defaultExchangeTargetCurrency = _data["defaultExchangeTargetCurrency"] ? CurrencyModel.fromJS(_data["defaultExchangeTargetCurrency"]) : <any>null;
        }
    }

    static fromJS(data: any): SettingModel {
        data = typeof data === 'object' ? data : {};
        let result = new SettingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settingId"] = this.settingId !== undefined ? this.settingId : <any>null;
        data["startInvoiceDate"] = this.startInvoiceDate ? this.startInvoiceDate.toISOString() : <any>null;
        data["invoiceDailyTime"] = this.invoiceDailyTime ? this.invoiceDailyTime.toISOString() : <any>null;
        data["postPayCurrencyId"] = this.postPayCurrencyId !== undefined ? this.postPayCurrencyId : <any>null;
        data["defaultExchangeTargetCurrencyId"] = this.defaultExchangeTargetCurrencyId !== undefined ? this.defaultExchangeTargetCurrencyId : <any>null;
        data["defaultExchangeTargetCurrency"] = this.defaultExchangeTargetCurrency ? this.defaultExchangeTargetCurrency.toJSON() : <any>null;
        return data;
    }
}

export interface ISettingModel {
    settingId: number;
    startInvoiceDate?: Date | null;
    invoiceDailyTime?: Date | null;
    postPayCurrencyId?: number | null;
    defaultExchangeTargetCurrencyId?: number | null;
    defaultExchangeTargetCurrency?: CurrencyModel | null;
}

export class CurrencyModel implements ICurrencyModel {
    currencyId!: number;
    currencyName!: string;
    isForTest!: boolean;
    symbol?: string | null;
    payments?: PaymentOrderModel[] | null;
    ordinaryOrders?: OrdinaryOrderModel[] | null;
    currencyLimits?: MerchantCurrencyLimitModel[] | null;
    paymentProfiles?: PaymentProfileModel[] | null;
    poses?: PosModel[] | null;

    constructor(data?: ICurrencyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.currencyName = _data["currencyName"] !== undefined ? _data["currencyName"] : <any>null;
            this.isForTest = _data["isForTest"] !== undefined ? _data["isForTest"] : <any>null;
            this.symbol = _data["symbol"] !== undefined ? _data["symbol"] : <any>null;
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments!.push(PaymentOrderModel.fromJS(item));
            }
            else {
                this.payments = <any>null;
            }
            if (Array.isArray(_data["ordinaryOrders"])) {
                this.ordinaryOrders = [] as any;
                for (let item of _data["ordinaryOrders"])
                    this.ordinaryOrders!.push(OrdinaryOrderModel.fromJS(item));
            }
            else {
                this.ordinaryOrders = <any>null;
            }
            if (Array.isArray(_data["currencyLimits"])) {
                this.currencyLimits = [] as any;
                for (let item of _data["currencyLimits"])
                    this.currencyLimits!.push(MerchantCurrencyLimitModel.fromJS(item));
            }
            else {
                this.currencyLimits = <any>null;
            }
            if (Array.isArray(_data["paymentProfiles"])) {
                this.paymentProfiles = [] as any;
                for (let item of _data["paymentProfiles"])
                    this.paymentProfiles!.push(PaymentProfileModel.fromJS(item));
            }
            else {
                this.paymentProfiles = <any>null;
            }
            if (Array.isArray(_data["poses"])) {
                this.poses = [] as any;
                for (let item of _data["poses"])
                    this.poses!.push(PosModel.fromJS(item));
            }
            else {
                this.poses = <any>null;
            }
        }
    }

    static fromJS(data: any): CurrencyModel {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["currencyName"] = this.currencyName !== undefined ? this.currencyName : <any>null;
        data["isForTest"] = this.isForTest !== undefined ? this.isForTest : <any>null;
        data["symbol"] = this.symbol !== undefined ? this.symbol : <any>null;
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        if (Array.isArray(this.ordinaryOrders)) {
            data["ordinaryOrders"] = [];
            for (let item of this.ordinaryOrders)
                data["ordinaryOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.currencyLimits)) {
            data["currencyLimits"] = [];
            for (let item of this.currencyLimits)
                data["currencyLimits"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentProfiles)) {
            data["paymentProfiles"] = [];
            for (let item of this.paymentProfiles)
                data["paymentProfiles"].push(item.toJSON());
        }
        if (Array.isArray(this.poses)) {
            data["poses"] = [];
            for (let item of this.poses)
                data["poses"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICurrencyModel {
    currencyId: number;
    currencyName: string;
    isForTest: boolean;
    symbol?: string | null;
    payments?: PaymentOrderModel[] | null;
    ordinaryOrders?: OrdinaryOrderModel[] | null;
    currencyLimits?: MerchantCurrencyLimitModel[] | null;
    paymentProfiles?: PaymentProfileModel[] | null;
    poses?: PosModel[] | null;
}

export class PaymentOrderModel implements IPaymentOrderModel {
    paymentOrderId!: number;
    paymentOrderKey!: string;
    providerPaymentId?: number | null;
    amount!: number;
    autoPayment!: boolean;
    paymentMethodProviderProfileId?: number | null;
    currencyId!: number;
    lastError?: string | null;
    referenceNumber?: string | null;
    paymentOrderType!: PaymentOrderType;
    merchantId!: number;
    createdTime!: Date;
    modifiedTime!: Date;
    paymentOrderState!: PaymentOrderState;
    captureWalletOrderReferenceNumber?: string | null;
    disputeWalletOrderReferenceNumber?: string | null;
    merchant?: MerchantModel | null;
    currency?: CurrencyModel | null;
    postPayInvoiceItem?: PostPayInvoiceItemModel | null;
    paymentOrderStateLogs?: PaymentOrderStateLogModel[] | null;

    constructor(data?: IPaymentOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentOrderId = _data["paymentOrderId"] !== undefined ? _data["paymentOrderId"] : <any>null;
            this.paymentOrderKey = _data["paymentOrderKey"] !== undefined ? _data["paymentOrderKey"] : <any>null;
            this.providerPaymentId = _data["providerPaymentId"] !== undefined ? _data["providerPaymentId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.autoPayment = _data["autoPayment"] !== undefined ? _data["autoPayment"] : <any>null;
            this.paymentMethodProviderProfileId = _data["paymentMethodProviderProfileId"] !== undefined ? _data["paymentMethodProviderProfileId"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.lastError = _data["lastError"] !== undefined ? _data["lastError"] : <any>null;
            this.referenceNumber = _data["referenceNumber"] !== undefined ? _data["referenceNumber"] : <any>null;
            this.paymentOrderType = _data["paymentOrderType"] !== undefined ? _data["paymentOrderType"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.paymentOrderState = _data["paymentOrderState"] !== undefined ? _data["paymentOrderState"] : <any>null;
            this.captureWalletOrderReferenceNumber = _data["captureWalletOrderReferenceNumber"] !== undefined ? _data["captureWalletOrderReferenceNumber"] : <any>null;
            this.disputeWalletOrderReferenceNumber = _data["disputeWalletOrderReferenceNumber"] !== undefined ? _data["disputeWalletOrderReferenceNumber"] : <any>null;
            this.merchant = _data["merchant"] ? MerchantModel.fromJS(_data["merchant"]) : <any>null;
            this.currency = _data["currency"] ? CurrencyModel.fromJS(_data["currency"]) : <any>null;
            this.postPayInvoiceItem = _data["postPayInvoiceItem"] ? PostPayInvoiceItemModel.fromJS(_data["postPayInvoiceItem"]) : <any>null;
            if (Array.isArray(_data["paymentOrderStateLogs"])) {
                this.paymentOrderStateLogs = [] as any;
                for (let item of _data["paymentOrderStateLogs"])
                    this.paymentOrderStateLogs!.push(PaymentOrderStateLogModel.fromJS(item));
            }
            else {
                this.paymentOrderStateLogs = <any>null;
            }
        }
    }

    static fromJS(data: any): PaymentOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentOrderId"] = this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
        data["paymentOrderKey"] = this.paymentOrderKey !== undefined ? this.paymentOrderKey : <any>null;
        data["providerPaymentId"] = this.providerPaymentId !== undefined ? this.providerPaymentId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["autoPayment"] = this.autoPayment !== undefined ? this.autoPayment : <any>null;
        data["paymentMethodProviderProfileId"] = this.paymentMethodProviderProfileId !== undefined ? this.paymentMethodProviderProfileId : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["lastError"] = this.lastError !== undefined ? this.lastError : <any>null;
        data["referenceNumber"] = this.referenceNumber !== undefined ? this.referenceNumber : <any>null;
        data["paymentOrderType"] = this.paymentOrderType !== undefined ? this.paymentOrderType : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["paymentOrderState"] = this.paymentOrderState !== undefined ? this.paymentOrderState : <any>null;
        data["captureWalletOrderReferenceNumber"] = this.captureWalletOrderReferenceNumber !== undefined ? this.captureWalletOrderReferenceNumber : <any>null;
        data["disputeWalletOrderReferenceNumber"] = this.disputeWalletOrderReferenceNumber !== undefined ? this.disputeWalletOrderReferenceNumber : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["postPayInvoiceItem"] = this.postPayInvoiceItem ? this.postPayInvoiceItem.toJSON() : <any>null;
        if (Array.isArray(this.paymentOrderStateLogs)) {
            data["paymentOrderStateLogs"] = [];
            for (let item of this.paymentOrderStateLogs)
                data["paymentOrderStateLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaymentOrderModel {
    paymentOrderId: number;
    paymentOrderKey: string;
    providerPaymentId?: number | null;
    amount: number;
    autoPayment: boolean;
    paymentMethodProviderProfileId?: number | null;
    currencyId: number;
    lastError?: string | null;
    referenceNumber?: string | null;
    paymentOrderType: PaymentOrderType;
    merchantId: number;
    createdTime: Date;
    modifiedTime: Date;
    paymentOrderState: PaymentOrderState;
    captureWalletOrderReferenceNumber?: string | null;
    disputeWalletOrderReferenceNumber?: string | null;
    merchant?: MerchantModel | null;
    currency?: CurrencyModel | null;
    postPayInvoiceItem?: PostPayInvoiceItemModel | null;
    paymentOrderStateLogs?: PaymentOrderStateLogModel[] | null;
}

export class MerchantModel implements IMerchantModel {
    merchantId!: number;
    merchantName!: string;
    parentBranchId?: number | null;
    saleManagerId?: number | null;
    rootBranchId?: number | null;
    description?: string | null;
    email!: string;
    isActive!: boolean;
    externalReference!: string;
    walletId!: number;
    postPayAchPaymentMethodProviderProfileId?: number | null;
    creditWalletId?: number | null;
    invoiceThresholdDay?: number | null;
    website?: string | null;
    phoneNumberCountryCode?: string | null;
    phoneNumber?: string | null;
    whatsappNumberCountryCode?: string | null;
    whatsappNumber?: string | null;
    exchangeTargetCurrencyId!: number;
    assignedGatewayListId?: number | null;
    financialActivitiesTwoPhaseVerification!: boolean;
    isActivePostPay!: boolean;
    isActivePin!: boolean;
    timeZone?: string | null;
    activated2FaModifiedTime?: Date | null;
    createdTime!: Date;
    modifiedTime!: Date;
    address?: MerchantAddressModel | null;
    exchangeTargetCurrency?: CurrencyModel | null;
    rootBranch?: BranchModel | null;
    saleManager?: SaleManagerModel | null;
    assignedGatewayList?: GatewayListModel | null;
    merchantCredits?: CreditWalletModel[] | null;
    customerMerchantCredits?: CreditWalletModel[] | null;
    senderMerchantSettleOrders?: SettleOrderModel[] | null;
    receiverMerchantSettleOrders?: SettleOrderModel[] | null;
    payments?: PaymentOrderModel[] | null;
    senderMerchantOrdinaryOrders?: OrdinaryOrderModel[] | null;
    receiverMerchantOrdinaryOrders?: OrdinaryOrderModel[] | null;
    invoices?: InvoiceModel[] | null;
    currencyLimits?: MerchantCurrencyLimitModel[] | null;
    receivingPosOrderPoses?: PosModel[] | null;
    postPayInvoiceItems?: PostPayInvoiceItemModel[] | null;

    constructor(data?: IMerchantModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.merchantName = _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
            this.parentBranchId = _data["parentBranchId"] !== undefined ? _data["parentBranchId"] : <any>null;
            this.saleManagerId = _data["saleManagerId"] !== undefined ? _data["saleManagerId"] : <any>null;
            this.rootBranchId = _data["rootBranchId"] !== undefined ? _data["rootBranchId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.externalReference = _data["externalReference"] !== undefined ? _data["externalReference"] : <any>null;
            this.walletId = _data["walletId"] !== undefined ? _data["walletId"] : <any>null;
            this.postPayAchPaymentMethodProviderProfileId = _data["postPayAchPaymentMethodProviderProfileId"] !== undefined ? _data["postPayAchPaymentMethodProviderProfileId"] : <any>null;
            this.creditWalletId = _data["creditWalletId"] !== undefined ? _data["creditWalletId"] : <any>null;
            this.invoiceThresholdDay = _data["invoiceThresholdDay"] !== undefined ? _data["invoiceThresholdDay"] : <any>null;
            this.website = _data["website"] !== undefined ? _data["website"] : <any>null;
            this.phoneNumberCountryCode = _data["phoneNumberCountryCode"] !== undefined ? _data["phoneNumberCountryCode"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.whatsappNumberCountryCode = _data["whatsappNumberCountryCode"] !== undefined ? _data["whatsappNumberCountryCode"] : <any>null;
            this.whatsappNumber = _data["whatsappNumber"] !== undefined ? _data["whatsappNumber"] : <any>null;
            this.exchangeTargetCurrencyId = _data["exchangeTargetCurrencyId"] !== undefined ? _data["exchangeTargetCurrencyId"] : <any>null;
            this.assignedGatewayListId = _data["assignedGatewayListId"] !== undefined ? _data["assignedGatewayListId"] : <any>null;
            this.financialActivitiesTwoPhaseVerification = _data["financialActivitiesTwoPhaseVerification"] !== undefined ? _data["financialActivitiesTwoPhaseVerification"] : <any>null;
            this.isActivePostPay = _data["isActivePostPay"] !== undefined ? _data["isActivePostPay"] : <any>null;
            this.isActivePin = _data["isActivePin"] !== undefined ? _data["isActivePin"] : <any>null;
            this.timeZone = _data["timeZone"] !== undefined ? _data["timeZone"] : <any>null;
            this.activated2FaModifiedTime = _data["activated2FaModifiedTime"] ? new Date(_data["activated2FaModifiedTime"].toString()) : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.address = _data["address"] ? MerchantAddressModel.fromJS(_data["address"]) : <any>null;
            this.exchangeTargetCurrency = _data["exchangeTargetCurrency"] ? CurrencyModel.fromJS(_data["exchangeTargetCurrency"]) : <any>null;
            this.rootBranch = _data["rootBranch"] ? BranchModel.fromJS(_data["rootBranch"]) : <any>null;
            this.saleManager = _data["saleManager"] ? SaleManagerModel.fromJS(_data["saleManager"]) : <any>null;
            this.assignedGatewayList = _data["assignedGatewayList"] ? GatewayListModel.fromJS(_data["assignedGatewayList"]) : <any>null;
            if (Array.isArray(_data["merchantCredits"])) {
                this.merchantCredits = [] as any;
                for (let item of _data["merchantCredits"])
                    this.merchantCredits!.push(CreditWalletModel.fromJS(item));
            }
            else {
                this.merchantCredits = <any>null;
            }
            if (Array.isArray(_data["customerMerchantCredits"])) {
                this.customerMerchantCredits = [] as any;
                for (let item of _data["customerMerchantCredits"])
                    this.customerMerchantCredits!.push(CreditWalletModel.fromJS(item));
            }
            else {
                this.customerMerchantCredits = <any>null;
            }
            if (Array.isArray(_data["senderMerchantSettleOrders"])) {
                this.senderMerchantSettleOrders = [] as any;
                for (let item of _data["senderMerchantSettleOrders"])
                    this.senderMerchantSettleOrders!.push(SettleOrderModel.fromJS(item));
            }
            else {
                this.senderMerchantSettleOrders = <any>null;
            }
            if (Array.isArray(_data["receiverMerchantSettleOrders"])) {
                this.receiverMerchantSettleOrders = [] as any;
                for (let item of _data["receiverMerchantSettleOrders"])
                    this.receiverMerchantSettleOrders!.push(SettleOrderModel.fromJS(item));
            }
            else {
                this.receiverMerchantSettleOrders = <any>null;
            }
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments!.push(PaymentOrderModel.fromJS(item));
            }
            else {
                this.payments = <any>null;
            }
            if (Array.isArray(_data["senderMerchantOrdinaryOrders"])) {
                this.senderMerchantOrdinaryOrders = [] as any;
                for (let item of _data["senderMerchantOrdinaryOrders"])
                    this.senderMerchantOrdinaryOrders!.push(OrdinaryOrderModel.fromJS(item));
            }
            else {
                this.senderMerchantOrdinaryOrders = <any>null;
            }
            if (Array.isArray(_data["receiverMerchantOrdinaryOrders"])) {
                this.receiverMerchantOrdinaryOrders = [] as any;
                for (let item of _data["receiverMerchantOrdinaryOrders"])
                    this.receiverMerchantOrdinaryOrders!.push(OrdinaryOrderModel.fromJS(item));
            }
            else {
                this.receiverMerchantOrdinaryOrders = <any>null;
            }
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(InvoiceModel.fromJS(item));
            }
            else {
                this.invoices = <any>null;
            }
            if (Array.isArray(_data["currencyLimits"])) {
                this.currencyLimits = [] as any;
                for (let item of _data["currencyLimits"])
                    this.currencyLimits!.push(MerchantCurrencyLimitModel.fromJS(item));
            }
            else {
                this.currencyLimits = <any>null;
            }
            if (Array.isArray(_data["receivingPosOrderPoses"])) {
                this.receivingPosOrderPoses = [] as any;
                for (let item of _data["receivingPosOrderPoses"])
                    this.receivingPosOrderPoses!.push(PosModel.fromJS(item));
            }
            else {
                this.receivingPosOrderPoses = <any>null;
            }
            if (Array.isArray(_data["postPayInvoiceItems"])) {
                this.postPayInvoiceItems = [] as any;
                for (let item of _data["postPayInvoiceItems"])
                    this.postPayInvoiceItems!.push(PostPayInvoiceItemModel.fromJS(item));
            }
            else {
                this.postPayInvoiceItems = <any>null;
            }
        }
    }

    static fromJS(data: any): MerchantModel {
        data = typeof data === 'object' ? data : {};
        let result = new MerchantModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["merchantName"] = this.merchantName !== undefined ? this.merchantName : <any>null;
        data["parentBranchId"] = this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
        data["saleManagerId"] = this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
        data["rootBranchId"] = this.rootBranchId !== undefined ? this.rootBranchId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["externalReference"] = this.externalReference !== undefined ? this.externalReference : <any>null;
        data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
        data["postPayAchPaymentMethodProviderProfileId"] = this.postPayAchPaymentMethodProviderProfileId !== undefined ? this.postPayAchPaymentMethodProviderProfileId : <any>null;
        data["creditWalletId"] = this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
        data["invoiceThresholdDay"] = this.invoiceThresholdDay !== undefined ? this.invoiceThresholdDay : <any>null;
        data["website"] = this.website !== undefined ? this.website : <any>null;
        data["phoneNumberCountryCode"] = this.phoneNumberCountryCode !== undefined ? this.phoneNumberCountryCode : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["whatsappNumberCountryCode"] = this.whatsappNumberCountryCode !== undefined ? this.whatsappNumberCountryCode : <any>null;
        data["whatsappNumber"] = this.whatsappNumber !== undefined ? this.whatsappNumber : <any>null;
        data["exchangeTargetCurrencyId"] = this.exchangeTargetCurrencyId !== undefined ? this.exchangeTargetCurrencyId : <any>null;
        data["assignedGatewayListId"] = this.assignedGatewayListId !== undefined ? this.assignedGatewayListId : <any>null;
        data["financialActivitiesTwoPhaseVerification"] = this.financialActivitiesTwoPhaseVerification !== undefined ? this.financialActivitiesTwoPhaseVerification : <any>null;
        data["isActivePostPay"] = this.isActivePostPay !== undefined ? this.isActivePostPay : <any>null;
        data["isActivePin"] = this.isActivePin !== undefined ? this.isActivePin : <any>null;
        data["timeZone"] = this.timeZone !== undefined ? this.timeZone : <any>null;
        data["activated2FaModifiedTime"] = this.activated2FaModifiedTime ? this.activated2FaModifiedTime.toISOString() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["address"] = this.address ? this.address.toJSON() : <any>null;
        data["exchangeTargetCurrency"] = this.exchangeTargetCurrency ? this.exchangeTargetCurrency.toJSON() : <any>null;
        data["rootBranch"] = this.rootBranch ? this.rootBranch.toJSON() : <any>null;
        data["saleManager"] = this.saleManager ? this.saleManager.toJSON() : <any>null;
        data["assignedGatewayList"] = this.assignedGatewayList ? this.assignedGatewayList.toJSON() : <any>null;
        if (Array.isArray(this.merchantCredits)) {
            data["merchantCredits"] = [];
            for (let item of this.merchantCredits)
                data["merchantCredits"].push(item.toJSON());
        }
        if (Array.isArray(this.customerMerchantCredits)) {
            data["customerMerchantCredits"] = [];
            for (let item of this.customerMerchantCredits)
                data["customerMerchantCredits"].push(item.toJSON());
        }
        if (Array.isArray(this.senderMerchantSettleOrders)) {
            data["senderMerchantSettleOrders"] = [];
            for (let item of this.senderMerchantSettleOrders)
                data["senderMerchantSettleOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.receiverMerchantSettleOrders)) {
            data["receiverMerchantSettleOrders"] = [];
            for (let item of this.receiverMerchantSettleOrders)
                data["receiverMerchantSettleOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        if (Array.isArray(this.senderMerchantOrdinaryOrders)) {
            data["senderMerchantOrdinaryOrders"] = [];
            for (let item of this.senderMerchantOrdinaryOrders)
                data["senderMerchantOrdinaryOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.receiverMerchantOrdinaryOrders)) {
            data["receiverMerchantOrdinaryOrders"] = [];
            for (let item of this.receiverMerchantOrdinaryOrders)
                data["receiverMerchantOrdinaryOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        if (Array.isArray(this.currencyLimits)) {
            data["currencyLimits"] = [];
            for (let item of this.currencyLimits)
                data["currencyLimits"].push(item.toJSON());
        }
        if (Array.isArray(this.receivingPosOrderPoses)) {
            data["receivingPosOrderPoses"] = [];
            for (let item of this.receivingPosOrderPoses)
                data["receivingPosOrderPoses"].push(item.toJSON());
        }
        if (Array.isArray(this.postPayInvoiceItems)) {
            data["postPayInvoiceItems"] = [];
            for (let item of this.postPayInvoiceItems)
                data["postPayInvoiceItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMerchantModel {
    merchantId: number;
    merchantName: string;
    parentBranchId?: number | null;
    saleManagerId?: number | null;
    rootBranchId?: number | null;
    description?: string | null;
    email: string;
    isActive: boolean;
    externalReference: string;
    walletId: number;
    postPayAchPaymentMethodProviderProfileId?: number | null;
    creditWalletId?: number | null;
    invoiceThresholdDay?: number | null;
    website?: string | null;
    phoneNumberCountryCode?: string | null;
    phoneNumber?: string | null;
    whatsappNumberCountryCode?: string | null;
    whatsappNumber?: string | null;
    exchangeTargetCurrencyId: number;
    assignedGatewayListId?: number | null;
    financialActivitiesTwoPhaseVerification: boolean;
    isActivePostPay: boolean;
    isActivePin: boolean;
    timeZone?: string | null;
    activated2FaModifiedTime?: Date | null;
    createdTime: Date;
    modifiedTime: Date;
    address?: MerchantAddressModel | null;
    exchangeTargetCurrency?: CurrencyModel | null;
    rootBranch?: BranchModel | null;
    saleManager?: SaleManagerModel | null;
    assignedGatewayList?: GatewayListModel | null;
    merchantCredits?: CreditWalletModel[] | null;
    customerMerchantCredits?: CreditWalletModel[] | null;
    senderMerchantSettleOrders?: SettleOrderModel[] | null;
    receiverMerchantSettleOrders?: SettleOrderModel[] | null;
    payments?: PaymentOrderModel[] | null;
    senderMerchantOrdinaryOrders?: OrdinaryOrderModel[] | null;
    receiverMerchantOrdinaryOrders?: OrdinaryOrderModel[] | null;
    invoices?: InvoiceModel[] | null;
    currencyLimits?: MerchantCurrencyLimitModel[] | null;
    receivingPosOrderPoses?: PosModel[] | null;
    postPayInvoiceItems?: PostPayInvoiceItemModel[] | null;
}

export class MerchantAddressModel implements IMerchantAddressModel {
    merchantId!: number;
    country?: string | null;
    state?: string | null;
    city?: string | null;
    rawAddress?: string | null;
    postalCode?: string | null;
    merchant?: MerchantModel | null;

    constructor(data?: IMerchantAddressModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.country = _data["country"] !== undefined ? _data["country"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.rawAddress = _data["rawAddress"] !== undefined ? _data["rawAddress"] : <any>null;
            this.postalCode = _data["postalCode"] !== undefined ? _data["postalCode"] : <any>null;
            this.merchant = _data["merchant"] ? MerchantModel.fromJS(_data["merchant"]) : <any>null;
        }
    }

    static fromJS(data: any): MerchantAddressModel {
        data = typeof data === 'object' ? data : {};
        let result = new MerchantAddressModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["rawAddress"] = this.rawAddress !== undefined ? this.rawAddress : <any>null;
        data["postalCode"] = this.postalCode !== undefined ? this.postalCode : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        return data;
    }
}

export interface IMerchantAddressModel {
    merchantId: number;
    country?: string | null;
    state?: string | null;
    city?: string | null;
    rawAddress?: string | null;
    postalCode?: string | null;
    merchant?: MerchantModel | null;
}

export class BranchModel implements IBranchModel {
    branchId!: number;
    branchName!: string;
    parentBranchId?: number | null;
    description?: string | null;
    isActive!: boolean;
    rootPriceListId?: number | null;
    merchantId!: number;
    canSetFaceValue!: boolean;
    canSetBuyValue!: boolean;
    canPlaceOrder!: boolean;
    canCreateGatewayList!: boolean;
    canCreatePaymentOrder!: boolean;
    canActivatePostPayForSubMerchant!: boolean;
    calculateProfitByStockTotalBuyPrice!: boolean;
    createdTime!: Date;
    modifiedTime!: Date;
    subBranches?: BranchModel[] | null;
    saleManagers?: SaleManagerModel[] | null;
    merchant!: MerchantModel;
    parentBranch?: BranchModel | null;
    gatewayLists?: GatewayListModel[] | null;
    posOrders?: PosOrderModel[] | null;
    physicalCardOrders?: PhysicalCardOrderModel[] | null;

    constructor(data?: IBranchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.merchant = new MerchantModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.branchName = _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
            this.parentBranchId = _data["parentBranchId"] !== undefined ? _data["parentBranchId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.rootPriceListId = _data["rootPriceListId"] !== undefined ? _data["rootPriceListId"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.canSetFaceValue = _data["canSetFaceValue"] !== undefined ? _data["canSetFaceValue"] : <any>null;
            this.canSetBuyValue = _data["canSetBuyValue"] !== undefined ? _data["canSetBuyValue"] : <any>null;
            this.canPlaceOrder = _data["canPlaceOrder"] !== undefined ? _data["canPlaceOrder"] : <any>null;
            this.canCreateGatewayList = _data["canCreateGatewayList"] !== undefined ? _data["canCreateGatewayList"] : <any>null;
            this.canCreatePaymentOrder = _data["canCreatePaymentOrder"] !== undefined ? _data["canCreatePaymentOrder"] : <any>null;
            this.canActivatePostPayForSubMerchant = _data["canActivatePostPayForSubMerchant"] !== undefined ? _data["canActivatePostPayForSubMerchant"] : <any>null;
            this.calculateProfitByStockTotalBuyPrice = _data["calculateProfitByStockTotalBuyPrice"] !== undefined ? _data["calculateProfitByStockTotalBuyPrice"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            if (Array.isArray(_data["subBranches"])) {
                this.subBranches = [] as any;
                for (let item of _data["subBranches"])
                    this.subBranches!.push(BranchModel.fromJS(item));
            }
            else {
                this.subBranches = <any>null;
            }
            if (Array.isArray(_data["saleManagers"])) {
                this.saleManagers = [] as any;
                for (let item of _data["saleManagers"])
                    this.saleManagers!.push(SaleManagerModel.fromJS(item));
            }
            else {
                this.saleManagers = <any>null;
            }
            this.merchant = _data["merchant"] ? MerchantModel.fromJS(_data["merchant"]) : new MerchantModel();
            this.parentBranch = _data["parentBranch"] ? BranchModel.fromJS(_data["parentBranch"]) : <any>null;
            if (Array.isArray(_data["gatewayLists"])) {
                this.gatewayLists = [] as any;
                for (let item of _data["gatewayLists"])
                    this.gatewayLists!.push(GatewayListModel.fromJS(item));
            }
            else {
                this.gatewayLists = <any>null;
            }
            if (Array.isArray(_data["posOrders"])) {
                this.posOrders = [] as any;
                for (let item of _data["posOrders"])
                    this.posOrders!.push(PosOrderModel.fromJS(item));
            }
            else {
                this.posOrders = <any>null;
            }
            if (Array.isArray(_data["physicalCardOrders"])) {
                this.physicalCardOrders = [] as any;
                for (let item of _data["physicalCardOrders"])
                    this.physicalCardOrders!.push(PhysicalCardOrderModel.fromJS(item));
            }
            else {
                this.physicalCardOrders = <any>null;
            }
        }
    }

    static fromJS(data: any): BranchModel {
        data = typeof data === 'object' ? data : {};
        let result = new BranchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["branchName"] = this.branchName !== undefined ? this.branchName : <any>null;
        data["parentBranchId"] = this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["rootPriceListId"] = this.rootPriceListId !== undefined ? this.rootPriceListId : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["canSetFaceValue"] = this.canSetFaceValue !== undefined ? this.canSetFaceValue : <any>null;
        data["canSetBuyValue"] = this.canSetBuyValue !== undefined ? this.canSetBuyValue : <any>null;
        data["canPlaceOrder"] = this.canPlaceOrder !== undefined ? this.canPlaceOrder : <any>null;
        data["canCreateGatewayList"] = this.canCreateGatewayList !== undefined ? this.canCreateGatewayList : <any>null;
        data["canCreatePaymentOrder"] = this.canCreatePaymentOrder !== undefined ? this.canCreatePaymentOrder : <any>null;
        data["canActivatePostPayForSubMerchant"] = this.canActivatePostPayForSubMerchant !== undefined ? this.canActivatePostPayForSubMerchant : <any>null;
        data["calculateProfitByStockTotalBuyPrice"] = this.calculateProfitByStockTotalBuyPrice !== undefined ? this.calculateProfitByStockTotalBuyPrice : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        if (Array.isArray(this.subBranches)) {
            data["subBranches"] = [];
            for (let item of this.subBranches)
                data["subBranches"].push(item.toJSON());
        }
        if (Array.isArray(this.saleManagers)) {
            data["saleManagers"] = [];
            for (let item of this.saleManagers)
                data["saleManagers"].push(item.toJSON());
        }
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["parentBranch"] = this.parentBranch ? this.parentBranch.toJSON() : <any>null;
        if (Array.isArray(this.gatewayLists)) {
            data["gatewayLists"] = [];
            for (let item of this.gatewayLists)
                data["gatewayLists"].push(item.toJSON());
        }
        if (Array.isArray(this.posOrders)) {
            data["posOrders"] = [];
            for (let item of this.posOrders)
                data["posOrders"].push(item.toJSON());
        }
        if (Array.isArray(this.physicalCardOrders)) {
            data["physicalCardOrders"] = [];
            for (let item of this.physicalCardOrders)
                data["physicalCardOrders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBranchModel {
    branchId: number;
    branchName: string;
    parentBranchId?: number | null;
    description?: string | null;
    isActive: boolean;
    rootPriceListId?: number | null;
    merchantId: number;
    canSetFaceValue: boolean;
    canSetBuyValue: boolean;
    canPlaceOrder: boolean;
    canCreateGatewayList: boolean;
    canCreatePaymentOrder: boolean;
    canActivatePostPayForSubMerchant: boolean;
    calculateProfitByStockTotalBuyPrice: boolean;
    createdTime: Date;
    modifiedTime: Date;
    subBranches?: BranchModel[] | null;
    saleManagers?: SaleManagerModel[] | null;
    merchant: MerchantModel;
    parentBranch?: BranchModel | null;
    gatewayLists?: GatewayListModel[] | null;
    posOrders?: PosOrderModel[] | null;
    physicalCardOrders?: PhysicalCardOrderModel[] | null;
}

export class SaleManagerModel implements ISaleManagerModel {
    saleManagerId!: number;
    userId!: string;
    name!: string;
    email!: string;
    phoneNumberCountryCode?: string | null;
    phoneNumber?: string | null;
    isActive!: boolean;
    branchId!: number;
    createdTime!: Date;
    modifiedTime!: Date;
    branch?: BranchModel | null;
    customers?: MerchantModel[] | null;

    constructor(data?: ISaleManagerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saleManagerId = _data["saleManagerId"] !== undefined ? _data["saleManagerId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.phoneNumberCountryCode = _data["phoneNumberCountryCode"] !== undefined ? _data["phoneNumberCountryCode"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.branch = _data["branch"] ? BranchModel.fromJS(_data["branch"]) : <any>null;
            if (Array.isArray(_data["customers"])) {
                this.customers = [] as any;
                for (let item of _data["customers"])
                    this.customers!.push(MerchantModel.fromJS(item));
            }
            else {
                this.customers = <any>null;
            }
        }
    }

    static fromJS(data: any): SaleManagerModel {
        data = typeof data === 'object' ? data : {};
        let result = new SaleManagerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleManagerId"] = this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["phoneNumberCountryCode"] = this.phoneNumberCountryCode !== undefined ? this.phoneNumberCountryCode : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>null;
        if (Array.isArray(this.customers)) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISaleManagerModel {
    saleManagerId: number;
    userId: string;
    name: string;
    email: string;
    phoneNumberCountryCode?: string | null;
    phoneNumber?: string | null;
    isActive: boolean;
    branchId: number;
    createdTime: Date;
    modifiedTime: Date;
    branch?: BranchModel | null;
    customers?: MerchantModel[] | null;
}

export class GatewayListModel implements IGatewayListModel {
    gatewayListId!: number;
    name!: string;
    branchId!: number;
    createdTime!: Date;
    modifiedTime!: Date;
    branch?: BranchModel | null;
    paymentProfiles?: GatewayListPaymentProfileModel[] | null;

    constructor(data?: IGatewayListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayListId = _data["gatewayListId"] !== undefined ? _data["gatewayListId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.branch = _data["branch"] ? BranchModel.fromJS(_data["branch"]) : <any>null;
            if (Array.isArray(_data["paymentProfiles"])) {
                this.paymentProfiles = [] as any;
                for (let item of _data["paymentProfiles"])
                    this.paymentProfiles!.push(GatewayListPaymentProfileModel.fromJS(item));
            }
            else {
                this.paymentProfiles = <any>null;
            }
        }
    }

    static fromJS(data: any): GatewayListModel {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayListId"] = this.gatewayListId !== undefined ? this.gatewayListId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>null;
        if (Array.isArray(this.paymentProfiles)) {
            data["paymentProfiles"] = [];
            for (let item of this.paymentProfiles)
                data["paymentProfiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGatewayListModel {
    gatewayListId: number;
    name: string;
    branchId: number;
    createdTime: Date;
    modifiedTime: Date;
    branch?: BranchModel | null;
    paymentProfiles?: GatewayListPaymentProfileModel[] | null;
}

export class GatewayListPaymentProfileModel implements IGatewayListPaymentProfileModel {
    gatewayListPaymentProfileId!: number;
    gatewayListId!: number;
    paymentProfileId!: number;
    useForSubMerchants!: boolean;
    gatewayList?: GatewayListModel | null;
    paymentProfile?: PaymentProfileModel | null;

    constructor(data?: IGatewayListPaymentProfileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayListPaymentProfileId = _data["gatewayListPaymentProfileId"] !== undefined ? _data["gatewayListPaymentProfileId"] : <any>null;
            this.gatewayListId = _data["gatewayListId"] !== undefined ? _data["gatewayListId"] : <any>null;
            this.paymentProfileId = _data["paymentProfileId"] !== undefined ? _data["paymentProfileId"] : <any>null;
            this.useForSubMerchants = _data["useForSubMerchants"] !== undefined ? _data["useForSubMerchants"] : <any>null;
            this.gatewayList = _data["gatewayList"] ? GatewayListModel.fromJS(_data["gatewayList"]) : <any>null;
            this.paymentProfile = _data["paymentProfile"] ? PaymentProfileModel.fromJS(_data["paymentProfile"]) : <any>null;
        }
    }

    static fromJS(data: any): GatewayListPaymentProfileModel {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayListPaymentProfileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayListPaymentProfileId"] = this.gatewayListPaymentProfileId !== undefined ? this.gatewayListPaymentProfileId : <any>null;
        data["gatewayListId"] = this.gatewayListId !== undefined ? this.gatewayListId : <any>null;
        data["paymentProfileId"] = this.paymentProfileId !== undefined ? this.paymentProfileId : <any>null;
        data["useForSubMerchants"] = this.useForSubMerchants !== undefined ? this.useForSubMerchants : <any>null;
        data["gatewayList"] = this.gatewayList ? this.gatewayList.toJSON() : <any>null;
        data["paymentProfile"] = this.paymentProfile ? this.paymentProfile.toJSON() : <any>null;
        return data;
    }
}

export interface IGatewayListPaymentProfileModel {
    gatewayListPaymentProfileId: number;
    gatewayListId: number;
    paymentProfileId: number;
    useForSubMerchants: boolean;
    gatewayList?: GatewayListModel | null;
    paymentProfile?: PaymentProfileModel | null;
}

export class PaymentProfileModel implements IPaymentProfileModel {
    paymentProfileId!: number;
    providerProfileId!: number;
    description!: string;
    name!: string;
    minAmount!: number;
    maxAmount!: number;
    hasAutoPayment!: boolean;
    paymentProfileType!: PaymentProfileType;
    imageUri1!: string;
    imageUri2!: string;
    createdTime!: Date;
    modifiedTime!: Date;
    currencyId!: number;
    currency?: CurrencyModel | null;
    gatewayListPaymentProfiles?: GatewayListPaymentProfileModel[] | null;

    constructor(data?: IPaymentProfileModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentProfileId = _data["paymentProfileId"] !== undefined ? _data["paymentProfileId"] : <any>null;
            this.providerProfileId = _data["providerProfileId"] !== undefined ? _data["providerProfileId"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.minAmount = _data["minAmount"] !== undefined ? _data["minAmount"] : <any>null;
            this.maxAmount = _data["maxAmount"] !== undefined ? _data["maxAmount"] : <any>null;
            this.hasAutoPayment = _data["hasAutoPayment"] !== undefined ? _data["hasAutoPayment"] : <any>null;
            this.paymentProfileType = _data["paymentProfileType"] !== undefined ? _data["paymentProfileType"] : <any>null;
            this.imageUri1 = _data["imageUri1"] !== undefined ? _data["imageUri1"] : <any>null;
            this.imageUri2 = _data["imageUri2"] !== undefined ? _data["imageUri2"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.currency = _data["currency"] ? CurrencyModel.fromJS(_data["currency"]) : <any>null;
            if (Array.isArray(_data["gatewayListPaymentProfiles"])) {
                this.gatewayListPaymentProfiles = [] as any;
                for (let item of _data["gatewayListPaymentProfiles"])
                    this.gatewayListPaymentProfiles!.push(GatewayListPaymentProfileModel.fromJS(item));
            }
            else {
                this.gatewayListPaymentProfiles = <any>null;
            }
        }
    }

    static fromJS(data: any): PaymentProfileModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentProfileModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentProfileId"] = this.paymentProfileId !== undefined ? this.paymentProfileId : <any>null;
        data["providerProfileId"] = this.providerProfileId !== undefined ? this.providerProfileId : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["minAmount"] = this.minAmount !== undefined ? this.minAmount : <any>null;
        data["maxAmount"] = this.maxAmount !== undefined ? this.maxAmount : <any>null;
        data["hasAutoPayment"] = this.hasAutoPayment !== undefined ? this.hasAutoPayment : <any>null;
        data["paymentProfileType"] = this.paymentProfileType !== undefined ? this.paymentProfileType : <any>null;
        data["imageUri1"] = this.imageUri1 !== undefined ? this.imageUri1 : <any>null;
        data["imageUri2"] = this.imageUri2 !== undefined ? this.imageUri2 : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        if (Array.isArray(this.gatewayListPaymentProfiles)) {
            data["gatewayListPaymentProfiles"] = [];
            for (let item of this.gatewayListPaymentProfiles)
                data["gatewayListPaymentProfiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaymentProfileModel {
    paymentProfileId: number;
    providerProfileId: number;
    description: string;
    name: string;
    minAmount: number;
    maxAmount: number;
    hasAutoPayment: boolean;
    paymentProfileType: PaymentProfileType;
    imageUri1: string;
    imageUri2: string;
    createdTime: Date;
    modifiedTime: Date;
    currencyId: number;
    currency?: CurrencyModel | null;
    gatewayListPaymentProfiles?: GatewayListPaymentProfileModel[] | null;
}

export enum PaymentProfileType {
    PaymentProvider = "PaymentProvider",
}

export class PosOrderModel implements IPosOrderModel {
    posOrderId!: number;
    quantity!: number;
    posPrice!: number;
    paymentMethod!: PosOrderPaymentMethod;
    state!: PosOrderState;
    posOrderPaymentInstallmentCacheState?: PosOrderPaymentInstallmentCacheState | null;
    walletOrderId!: string;
    posId!: number;
    branchId!: number;
    paymentMethodProviderProfileId?: number | null;
    createdByUserId!: string;
    createdTime!: Date;
    modifiedTime!: Date;
    modifiedByUserId?: string | null;
    deliveredTime?: Date | null;
    description?: string | null;
    pos?: PosModel | null;
    branch?: BranchModel | null;
    shipping?: PosOrderShippingModel | null;
    stateLogs?: PosOrderStateLogModel[] | null;
    paymentItems?: PosOrderPaymentItemModel[] | null;

    constructor(data?: IPosOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posOrderId = _data["posOrderId"] !== undefined ? _data["posOrderId"] : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.posPrice = _data["posPrice"] !== undefined ? _data["posPrice"] : <any>null;
            this.paymentMethod = _data["paymentMethod"] !== undefined ? _data["paymentMethod"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.posOrderPaymentInstallmentCacheState = _data["posOrderPaymentInstallmentCacheState"] !== undefined ? _data["posOrderPaymentInstallmentCacheState"] : <any>null;
            this.walletOrderId = _data["walletOrderId"] !== undefined ? _data["walletOrderId"] : <any>null;
            this.posId = _data["posId"] !== undefined ? _data["posId"] : <any>null;
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.paymentMethodProviderProfileId = _data["paymentMethodProviderProfileId"] !== undefined ? _data["paymentMethodProviderProfileId"] : <any>null;
            this.createdByUserId = _data["createdByUserId"] !== undefined ? _data["createdByUserId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.modifiedByUserId = _data["modifiedByUserId"] !== undefined ? _data["modifiedByUserId"] : <any>null;
            this.deliveredTime = _data["deliveredTime"] ? new Date(_data["deliveredTime"].toString()) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.pos = _data["pos"] ? PosModel.fromJS(_data["pos"]) : <any>null;
            this.branch = _data["branch"] ? BranchModel.fromJS(_data["branch"]) : <any>null;
            this.shipping = _data["shipping"] ? PosOrderShippingModel.fromJS(_data["shipping"]) : <any>null;
            if (Array.isArray(_data["stateLogs"])) {
                this.stateLogs = [] as any;
                for (let item of _data["stateLogs"])
                    this.stateLogs!.push(PosOrderStateLogModel.fromJS(item));
            }
            else {
                this.stateLogs = <any>null;
            }
            if (Array.isArray(_data["paymentItems"])) {
                this.paymentItems = [] as any;
                for (let item of _data["paymentItems"])
                    this.paymentItems!.push(PosOrderPaymentItemModel.fromJS(item));
            }
            else {
                this.paymentItems = <any>null;
            }
        }
    }

    static fromJS(data: any): PosOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new PosOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posOrderId"] = this.posOrderId !== undefined ? this.posOrderId : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["posPrice"] = this.posPrice !== undefined ? this.posPrice : <any>null;
        data["paymentMethod"] = this.paymentMethod !== undefined ? this.paymentMethod : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["posOrderPaymentInstallmentCacheState"] = this.posOrderPaymentInstallmentCacheState !== undefined ? this.posOrderPaymentInstallmentCacheState : <any>null;
        data["walletOrderId"] = this.walletOrderId !== undefined ? this.walletOrderId : <any>null;
        data["posId"] = this.posId !== undefined ? this.posId : <any>null;
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["paymentMethodProviderProfileId"] = this.paymentMethodProviderProfileId !== undefined ? this.paymentMethodProviderProfileId : <any>null;
        data["createdByUserId"] = this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["modifiedByUserId"] = this.modifiedByUserId !== undefined ? this.modifiedByUserId : <any>null;
        data["deliveredTime"] = this.deliveredTime ? this.deliveredTime.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["pos"] = this.pos ? this.pos.toJSON() : <any>null;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>null;
        data["shipping"] = this.shipping ? this.shipping.toJSON() : <any>null;
        if (Array.isArray(this.stateLogs)) {
            data["stateLogs"] = [];
            for (let item of this.stateLogs)
                data["stateLogs"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentItems)) {
            data["paymentItems"] = [];
            for (let item of this.paymentItems)
                data["paymentItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPosOrderModel {
    posOrderId: number;
    quantity: number;
    posPrice: number;
    paymentMethod: PosOrderPaymentMethod;
    state: PosOrderState;
    posOrderPaymentInstallmentCacheState?: PosOrderPaymentInstallmentCacheState | null;
    walletOrderId: string;
    posId: number;
    branchId: number;
    paymentMethodProviderProfileId?: number | null;
    createdByUserId: string;
    createdTime: Date;
    modifiedTime: Date;
    modifiedByUserId?: string | null;
    deliveredTime?: Date | null;
    description?: string | null;
    pos?: PosModel | null;
    branch?: BranchModel | null;
    shipping?: PosOrderShippingModel | null;
    stateLogs?: PosOrderStateLogModel[] | null;
    paymentItems?: PosOrderPaymentItemModel[] | null;
}

export class PosModel implements IPosModel {
    posId!: number;
    name!: string;
    description?: string | null;
    imageUri?: string | null;
    price!: number;
    isSubscriptive!: boolean;
    installmentCount?: number | null;
    posOrderReceiverMerchantId?: number | null;
    creditCardPaymentProfileId?: number | null;
    currencyId!: number;
    createdTime!: Date;
    modifiedTime!: Date;
    currency?: CurrencyModel | null;
    posOrderReceiverMerchant?: MerchantModel | null;
    posOrders?: PosOrderModel[] | null;

    constructor(data?: IPosModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posId = _data["posId"] !== undefined ? _data["posId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.imageUri = _data["imageUri"] !== undefined ? _data["imageUri"] : <any>null;
            this.price = _data["price"] !== undefined ? _data["price"] : <any>null;
            this.isSubscriptive = _data["isSubscriptive"] !== undefined ? _data["isSubscriptive"] : <any>null;
            this.installmentCount = _data["installmentCount"] !== undefined ? _data["installmentCount"] : <any>null;
            this.posOrderReceiverMerchantId = _data["posOrderReceiverMerchantId"] !== undefined ? _data["posOrderReceiverMerchantId"] : <any>null;
            this.creditCardPaymentProfileId = _data["creditCardPaymentProfileId"] !== undefined ? _data["creditCardPaymentProfileId"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.currency = _data["currency"] ? CurrencyModel.fromJS(_data["currency"]) : <any>null;
            this.posOrderReceiverMerchant = _data["posOrderReceiverMerchant"] ? MerchantModel.fromJS(_data["posOrderReceiverMerchant"]) : <any>null;
            if (Array.isArray(_data["posOrders"])) {
                this.posOrders = [] as any;
                for (let item of _data["posOrders"])
                    this.posOrders!.push(PosOrderModel.fromJS(item));
            }
            else {
                this.posOrders = <any>null;
            }
        }
    }

    static fromJS(data: any): PosModel {
        data = typeof data === 'object' ? data : {};
        let result = new PosModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posId"] = this.posId !== undefined ? this.posId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["imageUri"] = this.imageUri !== undefined ? this.imageUri : <any>null;
        data["price"] = this.price !== undefined ? this.price : <any>null;
        data["isSubscriptive"] = this.isSubscriptive !== undefined ? this.isSubscriptive : <any>null;
        data["installmentCount"] = this.installmentCount !== undefined ? this.installmentCount : <any>null;
        data["posOrderReceiverMerchantId"] = this.posOrderReceiverMerchantId !== undefined ? this.posOrderReceiverMerchantId : <any>null;
        data["creditCardPaymentProfileId"] = this.creditCardPaymentProfileId !== undefined ? this.creditCardPaymentProfileId : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["posOrderReceiverMerchant"] = this.posOrderReceiverMerchant ? this.posOrderReceiverMerchant.toJSON() : <any>null;
        if (Array.isArray(this.posOrders)) {
            data["posOrders"] = [];
            for (let item of this.posOrders)
                data["posOrders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPosModel {
    posId: number;
    name: string;
    description?: string | null;
    imageUri?: string | null;
    price: number;
    isSubscriptive: boolean;
    installmentCount?: number | null;
    posOrderReceiverMerchantId?: number | null;
    creditCardPaymentProfileId?: number | null;
    currencyId: number;
    createdTime: Date;
    modifiedTime: Date;
    currency?: CurrencyModel | null;
    posOrderReceiverMerchant?: MerchantModel | null;
    posOrders?: PosOrderModel[] | null;
}

export class PosOrderShippingModel implements IPosOrderShippingModel {
    posOrderId!: number;
    fullName!: string;
    phoneNumberCountryCode!: string;
    phoneNumber!: string;
    country!: string;
    state!: string;
    city!: string;
    rawAddress!: string;
    zipCode!: string;
    posOrder?: PosOrderModel | null;

    constructor(data?: IPosOrderShippingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posOrderId = _data["posOrderId"] !== undefined ? _data["posOrderId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.phoneNumberCountryCode = _data["phoneNumberCountryCode"] !== undefined ? _data["phoneNumberCountryCode"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.country = _data["country"] !== undefined ? _data["country"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.rawAddress = _data["rawAddress"] !== undefined ? _data["rawAddress"] : <any>null;
            this.zipCode = _data["zipCode"] !== undefined ? _data["zipCode"] : <any>null;
            this.posOrder = _data["posOrder"] ? PosOrderModel.fromJS(_data["posOrder"]) : <any>null;
        }
    }

    static fromJS(data: any): PosOrderShippingModel {
        data = typeof data === 'object' ? data : {};
        let result = new PosOrderShippingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posOrderId"] = this.posOrderId !== undefined ? this.posOrderId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["phoneNumberCountryCode"] = this.phoneNumberCountryCode !== undefined ? this.phoneNumberCountryCode : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["rawAddress"] = this.rawAddress !== undefined ? this.rawAddress : <any>null;
        data["zipCode"] = this.zipCode !== undefined ? this.zipCode : <any>null;
        data["posOrder"] = this.posOrder ? this.posOrder.toJSON() : <any>null;
        return data;
    }
}

export interface IPosOrderShippingModel {
    posOrderId: number;
    fullName: string;
    phoneNumberCountryCode: string;
    phoneNumber: string;
    country: string;
    state: string;
    city: string;
    rawAddress: string;
    zipCode: string;
    posOrder?: PosOrderModel | null;
}

export class PosOrderStateLogModel implements IPosOrderStateLogModel {
    posOrderStateLogId!: number;
    state!: PosOrderState;
    description?: string | null;
    posOrderId!: number;
    createdTime!: Date;
    posOrder?: PosOrderModel | null;

    constructor(data?: IPosOrderStateLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posOrderStateLogId = _data["posOrderStateLogId"] !== undefined ? _data["posOrderStateLogId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.posOrderId = _data["posOrderId"] !== undefined ? _data["posOrderId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.posOrder = _data["posOrder"] ? PosOrderModel.fromJS(_data["posOrder"]) : <any>null;
        }
    }

    static fromJS(data: any): PosOrderStateLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new PosOrderStateLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posOrderStateLogId"] = this.posOrderStateLogId !== undefined ? this.posOrderStateLogId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["posOrderId"] = this.posOrderId !== undefined ? this.posOrderId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["posOrder"] = this.posOrder ? this.posOrder.toJSON() : <any>null;
        return data;
    }
}

export interface IPosOrderStateLogModel {
    posOrderStateLogId: number;
    state: PosOrderState;
    description?: string | null;
    posOrderId: number;
    createdTime: Date;
    posOrder?: PosOrderModel | null;
}

export class PosOrderPaymentItemModel implements IPosOrderPaymentItemModel {
    posOrderPaymentItemId!: number;
    error?: string | null;
    posOrderId!: number;
    amount!: number;
    paymentOrderId?: number | null;
    walletOrderId!: string;
    paymentOrderReferenceNumber!: string;
    modifiedByUserId?: string | null;
    createdTime!: Date;
    modifiedTime!: Date;
    posOrder?: PosOrderModel | null;
    paymentOrder?: PaymentOrderModel | null;
    retryPosOrderPaymentItemLogs?: RetryPosOrderPaymentItemLogModel[] | null;

    constructor(data?: IPosOrderPaymentItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.posOrderPaymentItemId = _data["posOrderPaymentItemId"] !== undefined ? _data["posOrderPaymentItemId"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.posOrderId = _data["posOrderId"] !== undefined ? _data["posOrderId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.paymentOrderId = _data["paymentOrderId"] !== undefined ? _data["paymentOrderId"] : <any>null;
            this.walletOrderId = _data["walletOrderId"] !== undefined ? _data["walletOrderId"] : <any>null;
            this.paymentOrderReferenceNumber = _data["paymentOrderReferenceNumber"] !== undefined ? _data["paymentOrderReferenceNumber"] : <any>null;
            this.modifiedByUserId = _data["modifiedByUserId"] !== undefined ? _data["modifiedByUserId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.posOrder = _data["posOrder"] ? PosOrderModel.fromJS(_data["posOrder"]) : <any>null;
            this.paymentOrder = _data["paymentOrder"] ? PaymentOrderModel.fromJS(_data["paymentOrder"]) : <any>null;
            if (Array.isArray(_data["retryPosOrderPaymentItemLogs"])) {
                this.retryPosOrderPaymentItemLogs = [] as any;
                for (let item of _data["retryPosOrderPaymentItemLogs"])
                    this.retryPosOrderPaymentItemLogs!.push(RetryPosOrderPaymentItemLogModel.fromJS(item));
            }
            else {
                this.retryPosOrderPaymentItemLogs = <any>null;
            }
        }
    }

    static fromJS(data: any): PosOrderPaymentItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new PosOrderPaymentItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["posOrderPaymentItemId"] = this.posOrderPaymentItemId !== undefined ? this.posOrderPaymentItemId : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["posOrderId"] = this.posOrderId !== undefined ? this.posOrderId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["paymentOrderId"] = this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
        data["walletOrderId"] = this.walletOrderId !== undefined ? this.walletOrderId : <any>null;
        data["paymentOrderReferenceNumber"] = this.paymentOrderReferenceNumber !== undefined ? this.paymentOrderReferenceNumber : <any>null;
        data["modifiedByUserId"] = this.modifiedByUserId !== undefined ? this.modifiedByUserId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["posOrder"] = this.posOrder ? this.posOrder.toJSON() : <any>null;
        data["paymentOrder"] = this.paymentOrder ? this.paymentOrder.toJSON() : <any>null;
        if (Array.isArray(this.retryPosOrderPaymentItemLogs)) {
            data["retryPosOrderPaymentItemLogs"] = [];
            for (let item of this.retryPosOrderPaymentItemLogs)
                data["retryPosOrderPaymentItemLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPosOrderPaymentItemModel {
    posOrderPaymentItemId: number;
    error?: string | null;
    posOrderId: number;
    amount: number;
    paymentOrderId?: number | null;
    walletOrderId: string;
    paymentOrderReferenceNumber: string;
    modifiedByUserId?: string | null;
    createdTime: Date;
    modifiedTime: Date;
    posOrder?: PosOrderModel | null;
    paymentOrder?: PaymentOrderModel | null;
    retryPosOrderPaymentItemLogs?: RetryPosOrderPaymentItemLogModel[] | null;
}

export class RetryPosOrderPaymentItemLogModel implements IRetryPosOrderPaymentItemLogModel {
    retryPosOrderPaymentItemLogId!: number;
    posOrderPaymentItemId!: number;
    posOrderPaymentItemPaymentOrderId?: number | null;
    posOrderPaymentItemPaymentOrderReferenceNumber!: string;
    createdTime!: Date;
    posOrderPaymentItem?: PosOrderPaymentItemModel | null;

    constructor(data?: IRetryPosOrderPaymentItemLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.retryPosOrderPaymentItemLogId = _data["retryPosOrderPaymentItemLogId"] !== undefined ? _data["retryPosOrderPaymentItemLogId"] : <any>null;
            this.posOrderPaymentItemId = _data["posOrderPaymentItemId"] !== undefined ? _data["posOrderPaymentItemId"] : <any>null;
            this.posOrderPaymentItemPaymentOrderId = _data["posOrderPaymentItemPaymentOrderId"] !== undefined ? _data["posOrderPaymentItemPaymentOrderId"] : <any>null;
            this.posOrderPaymentItemPaymentOrderReferenceNumber = _data["posOrderPaymentItemPaymentOrderReferenceNumber"] !== undefined ? _data["posOrderPaymentItemPaymentOrderReferenceNumber"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.posOrderPaymentItem = _data["posOrderPaymentItem"] ? PosOrderPaymentItemModel.fromJS(_data["posOrderPaymentItem"]) : <any>null;
        }
    }

    static fromJS(data: any): RetryPosOrderPaymentItemLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new RetryPosOrderPaymentItemLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retryPosOrderPaymentItemLogId"] = this.retryPosOrderPaymentItemLogId !== undefined ? this.retryPosOrderPaymentItemLogId : <any>null;
        data["posOrderPaymentItemId"] = this.posOrderPaymentItemId !== undefined ? this.posOrderPaymentItemId : <any>null;
        data["posOrderPaymentItemPaymentOrderId"] = this.posOrderPaymentItemPaymentOrderId !== undefined ? this.posOrderPaymentItemPaymentOrderId : <any>null;
        data["posOrderPaymentItemPaymentOrderReferenceNumber"] = this.posOrderPaymentItemPaymentOrderReferenceNumber !== undefined ? this.posOrderPaymentItemPaymentOrderReferenceNumber : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["posOrderPaymentItem"] = this.posOrderPaymentItem ? this.posOrderPaymentItem.toJSON() : <any>null;
        return data;
    }
}

export interface IRetryPosOrderPaymentItemLogModel {
    retryPosOrderPaymentItemLogId: number;
    posOrderPaymentItemId: number;
    posOrderPaymentItemPaymentOrderId?: number | null;
    posOrderPaymentItemPaymentOrderReferenceNumber: string;
    createdTime: Date;
    posOrderPaymentItem?: PosOrderPaymentItemModel | null;
}

export class PhysicalCardOrderModel implements IPhysicalCardOrderModel {
    physicalCardOrderId!: number;
    branchId!: number;
    state!: PhysicalCardOrderState;
    description?: string | null;
    createdTime!: Date;
    createdByUserId!: string;
    modifiedTime!: Date;
    modifiedByUserId!: string;
    deliveredTime?: Date | null;
    branch?: BranchModel | null;
    shipping?: PhysicalCardOrderShippingModel | null;
    physicalCardOrderDetails?: PhysicalCardOrderDetailModel[] | null;
    physicalCardOrderStateLogs?: PhysicalCardOrderStateLogModel[] | null;

    constructor(data?: IPhysicalCardOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.physicalCardOrderId = _data["physicalCardOrderId"] !== undefined ? _data["physicalCardOrderId"] : <any>null;
            this.branchId = _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.createdByUserId = _data["createdByUserId"] !== undefined ? _data["createdByUserId"] : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.modifiedByUserId = _data["modifiedByUserId"] !== undefined ? _data["modifiedByUserId"] : <any>null;
            this.deliveredTime = _data["deliveredTime"] ? new Date(_data["deliveredTime"].toString()) : <any>null;
            this.branch = _data["branch"] ? BranchModel.fromJS(_data["branch"]) : <any>null;
            this.shipping = _data["shipping"] ? PhysicalCardOrderShippingModel.fromJS(_data["shipping"]) : <any>null;
            if (Array.isArray(_data["physicalCardOrderDetails"])) {
                this.physicalCardOrderDetails = [] as any;
                for (let item of _data["physicalCardOrderDetails"])
                    this.physicalCardOrderDetails!.push(PhysicalCardOrderDetailModel.fromJS(item));
            }
            else {
                this.physicalCardOrderDetails = <any>null;
            }
            if (Array.isArray(_data["physicalCardOrderStateLogs"])) {
                this.physicalCardOrderStateLogs = [] as any;
                for (let item of _data["physicalCardOrderStateLogs"])
                    this.physicalCardOrderStateLogs!.push(PhysicalCardOrderStateLogModel.fromJS(item));
            }
            else {
                this.physicalCardOrderStateLogs = <any>null;
            }
        }
    }

    static fromJS(data: any): PhysicalCardOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new PhysicalCardOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["physicalCardOrderId"] = this.physicalCardOrderId !== undefined ? this.physicalCardOrderId : <any>null;
        data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["createdByUserId"] = this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["modifiedByUserId"] = this.modifiedByUserId !== undefined ? this.modifiedByUserId : <any>null;
        data["deliveredTime"] = this.deliveredTime ? this.deliveredTime.toISOString() : <any>null;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>null;
        data["shipping"] = this.shipping ? this.shipping.toJSON() : <any>null;
        if (Array.isArray(this.physicalCardOrderDetails)) {
            data["physicalCardOrderDetails"] = [];
            for (let item of this.physicalCardOrderDetails)
                data["physicalCardOrderDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.physicalCardOrderStateLogs)) {
            data["physicalCardOrderStateLogs"] = [];
            for (let item of this.physicalCardOrderStateLogs)
                data["physicalCardOrderStateLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPhysicalCardOrderModel {
    physicalCardOrderId: number;
    branchId: number;
    state: PhysicalCardOrderState;
    description?: string | null;
    createdTime: Date;
    createdByUserId: string;
    modifiedTime: Date;
    modifiedByUserId: string;
    deliveredTime?: Date | null;
    branch?: BranchModel | null;
    shipping?: PhysicalCardOrderShippingModel | null;
    physicalCardOrderDetails?: PhysicalCardOrderDetailModel[] | null;
    physicalCardOrderStateLogs?: PhysicalCardOrderStateLogModel[] | null;
}

export class PhysicalCardOrderShippingModel implements IPhysicalCardOrderShippingModel {
    physicalCardOrderId!: number;
    fullName!: string;
    phoneNumberCountryCode!: string;
    phoneNumber!: string;
    country!: string;
    state!: string;
    city!: string;
    rawAddress!: string;
    zipCode!: string;
    physicalCardOrder?: PhysicalCardOrderModel | null;

    constructor(data?: IPhysicalCardOrderShippingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.physicalCardOrderId = _data["physicalCardOrderId"] !== undefined ? _data["physicalCardOrderId"] : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.phoneNumberCountryCode = _data["phoneNumberCountryCode"] !== undefined ? _data["phoneNumberCountryCode"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.country = _data["country"] !== undefined ? _data["country"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.city = _data["city"] !== undefined ? _data["city"] : <any>null;
            this.rawAddress = _data["rawAddress"] !== undefined ? _data["rawAddress"] : <any>null;
            this.zipCode = _data["zipCode"] !== undefined ? _data["zipCode"] : <any>null;
            this.physicalCardOrder = _data["physicalCardOrder"] ? PhysicalCardOrderModel.fromJS(_data["physicalCardOrder"]) : <any>null;
        }
    }

    static fromJS(data: any): PhysicalCardOrderShippingModel {
        data = typeof data === 'object' ? data : {};
        let result = new PhysicalCardOrderShippingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["physicalCardOrderId"] = this.physicalCardOrderId !== undefined ? this.physicalCardOrderId : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["phoneNumberCountryCode"] = this.phoneNumberCountryCode !== undefined ? this.phoneNumberCountryCode : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["city"] = this.city !== undefined ? this.city : <any>null;
        data["rawAddress"] = this.rawAddress !== undefined ? this.rawAddress : <any>null;
        data["zipCode"] = this.zipCode !== undefined ? this.zipCode : <any>null;
        data["physicalCardOrder"] = this.physicalCardOrder ? this.physicalCardOrder.toJSON() : <any>null;
        return data;
    }
}

export interface IPhysicalCardOrderShippingModel {
    physicalCardOrderId: number;
    fullName: string;
    phoneNumberCountryCode: string;
    phoneNumber: string;
    country: string;
    state: string;
    city: string;
    rawAddress: string;
    zipCode: string;
    physicalCardOrder?: PhysicalCardOrderModel | null;
}

export class PhysicalCardOrderDetailModel implements IPhysicalCardOrderDetailModel {
    physicalCardOrderDetailId!: number;
    physicalCardOrderId!: number;
    productId!: number;
    quantity!: number;
    productPrice?: number | null;
    physicalCardOrder?: PhysicalCardOrderModel | null;
    product?: ProductModel | null;

    constructor(data?: IPhysicalCardOrderDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.physicalCardOrderDetailId = _data["physicalCardOrderDetailId"] !== undefined ? _data["physicalCardOrderDetailId"] : <any>null;
            this.physicalCardOrderId = _data["physicalCardOrderId"] !== undefined ? _data["physicalCardOrderId"] : <any>null;
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
            this.productPrice = _data["productPrice"] !== undefined ? _data["productPrice"] : <any>null;
            this.physicalCardOrder = _data["physicalCardOrder"] ? PhysicalCardOrderModel.fromJS(_data["physicalCardOrder"]) : <any>null;
            this.product = _data["product"] ? ProductModel.fromJS(_data["product"]) : <any>null;
        }
    }

    static fromJS(data: any): PhysicalCardOrderDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new PhysicalCardOrderDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["physicalCardOrderDetailId"] = this.physicalCardOrderDetailId !== undefined ? this.physicalCardOrderDetailId : <any>null;
        data["physicalCardOrderId"] = this.physicalCardOrderId !== undefined ? this.physicalCardOrderId : <any>null;
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
        data["productPrice"] = this.productPrice !== undefined ? this.productPrice : <any>null;
        data["physicalCardOrder"] = this.physicalCardOrder ? this.physicalCardOrder.toJSON() : <any>null;
        data["product"] = this.product ? this.product.toJSON() : <any>null;
        return data;
    }
}

export interface IPhysicalCardOrderDetailModel {
    physicalCardOrderDetailId: number;
    physicalCardOrderId: number;
    productId: number;
    quantity: number;
    productPrice?: number | null;
    physicalCardOrder?: PhysicalCardOrderModel | null;
    product?: ProductModel | null;
}

export class ProductModel implements IProductModel {
    productId!: number;
    productName!: string;
    categoryId!: number;
    isActive!: boolean;
    currencyId!: number;
    upc?: string | null;
    sku!: string;
    canPreOrder!: boolean;
    canImmediate!: boolean;
    setInRootPriceList!: boolean;
    imageUrl?: string | null;
    description?: string | null;
    isDefault!: boolean;
    isPhysical!: boolean;
    createdTime!: Date;
    modifiedTime!: Date;
    category?: CategoryModel | null;
    currency?: CurrencyModel | null;
    productRegions?: ProductRegionModel[] | null;
    physicalCardOrderDetails?: PhysicalCardOrderDetailModel[] | null;

    constructor(data?: IProductModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
            this.productName = _data["productName"] !== undefined ? _data["productName"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
            this.sku = _data["sku"] !== undefined ? _data["sku"] : <any>null;
            this.canPreOrder = _data["canPreOrder"] !== undefined ? _data["canPreOrder"] : <any>null;
            this.canImmediate = _data["canImmediate"] !== undefined ? _data["canImmediate"] : <any>null;
            this.setInRootPriceList = _data["setInRootPriceList"] !== undefined ? _data["setInRootPriceList"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : <any>null;
            this.isPhysical = _data["isPhysical"] !== undefined ? _data["isPhysical"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.category = _data["category"] ? CategoryModel.fromJS(_data["category"]) : <any>null;
            this.currency = _data["currency"] ? CurrencyModel.fromJS(_data["currency"]) : <any>null;
            if (Array.isArray(_data["productRegions"])) {
                this.productRegions = [] as any;
                for (let item of _data["productRegions"])
                    this.productRegions!.push(ProductRegionModel.fromJS(item));
            }
            else {
                this.productRegions = <any>null;
            }
            if (Array.isArray(_data["physicalCardOrderDetails"])) {
                this.physicalCardOrderDetails = [] as any;
                for (let item of _data["physicalCardOrderDetails"])
                    this.physicalCardOrderDetails!.push(PhysicalCardOrderDetailModel.fromJS(item));
            }
            else {
                this.physicalCardOrderDetails = <any>null;
            }
        }
    }

    static fromJS(data: any): ProductModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        data["productName"] = this.productName !== undefined ? this.productName : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["upc"] = this.upc !== undefined ? this.upc : <any>null;
        data["sku"] = this.sku !== undefined ? this.sku : <any>null;
        data["canPreOrder"] = this.canPreOrder !== undefined ? this.canPreOrder : <any>null;
        data["canImmediate"] = this.canImmediate !== undefined ? this.canImmediate : <any>null;
        data["setInRootPriceList"] = this.setInRootPriceList !== undefined ? this.setInRootPriceList : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["isPhysical"] = this.isPhysical !== undefined ? this.isPhysical : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["category"] = this.category ? this.category.toJSON() : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        if (Array.isArray(this.productRegions)) {
            data["productRegions"] = [];
            for (let item of this.productRegions)
                data["productRegions"].push(item.toJSON());
        }
        if (Array.isArray(this.physicalCardOrderDetails)) {
            data["physicalCardOrderDetails"] = [];
            for (let item of this.physicalCardOrderDetails)
                data["physicalCardOrderDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductModel {
    productId: number;
    productName: string;
    categoryId: number;
    isActive: boolean;
    currencyId: number;
    upc?: string | null;
    sku: string;
    canPreOrder: boolean;
    canImmediate: boolean;
    setInRootPriceList: boolean;
    imageUrl?: string | null;
    description?: string | null;
    isDefault: boolean;
    isPhysical: boolean;
    createdTime: Date;
    modifiedTime: Date;
    category?: CategoryModel | null;
    currency?: CurrencyModel | null;
    productRegions?: ProductRegionModel[] | null;
    physicalCardOrderDetails?: PhysicalCardOrderDetailModel[] | null;
}

export class CategoryModel implements ICategoryModel {
    categoryId!: number;
    categoryName!: string;
    imageUrl?: string | null;
    parentCategoryId?: number | null;
    createdTime!: Date;
    modifiedTime!: Date;
    parentCategory?: CategoryModel | null;
    categories?: CategoryModel[] | null;
    products?: ProductModel[] | null;

    constructor(data?: ICategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.parentCategoryId = _data["parentCategoryId"] !== undefined ? _data["parentCategoryId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.parentCategory = _data["parentCategory"] ? CategoryModel.fromJS(_data["parentCategory"]) : <any>null;
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CategoryModel.fromJS(item));
            }
            else {
                this.categories = <any>null;
            }
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductModel.fromJS(item));
            }
            else {
                this.products = <any>null;
            }
        }
    }

    static fromJS(data: any): CategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["parentCategoryId"] = this.parentCategoryId !== undefined ? this.parentCategoryId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["parentCategory"] = this.parentCategory ? this.parentCategory.toJSON() : <any>null;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryModel {
    categoryId: number;
    categoryName: string;
    imageUrl?: string | null;
    parentCategoryId?: number | null;
    createdTime: Date;
    modifiedTime: Date;
    parentCategory?: CategoryModel | null;
    categories?: CategoryModel[] | null;
    products?: ProductModel[] | null;
}

export class ProductRegionModel implements IProductRegionModel {
    productId!: number;
    product?: ProductModel | null;
    regionId!: number;
    region?: RegionModel | null;

    constructor(data?: IProductRegionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
            this.product = _data["product"] ? ProductModel.fromJS(_data["product"]) : <any>null;
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
            this.region = _data["region"] ? RegionModel.fromJS(_data["region"]) : <any>null;
        }
    }

    static fromJS(data: any): ProductRegionModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductRegionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        data["product"] = this.product ? this.product.toJSON() : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["region"] = this.region ? this.region.toJSON() : <any>null;
        return data;
    }
}

export interface IProductRegionModel {
    productId: number;
    product?: ProductModel | null;
    regionId: number;
    region?: RegionModel | null;
}

export class RegionModel implements IRegionModel {
    regionId!: number;
    name!: string;
    code!: string;
    imageUrl?: string | null;
    createdTime!: Date;
    modifiedTime!: Date;
    productRegions?: ProductRegionModel[] | null;

    constructor(data?: IRegionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.imageUrl = _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            if (Array.isArray(_data["productRegions"])) {
                this.productRegions = [] as any;
                for (let item of _data["productRegions"])
                    this.productRegions!.push(ProductRegionModel.fromJS(item));
            }
            else {
                this.productRegions = <any>null;
            }
        }
    }

    static fromJS(data: any): RegionModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        if (Array.isArray(this.productRegions)) {
            data["productRegions"] = [];
            for (let item of this.productRegions)
                data["productRegions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegionModel {
    regionId: number;
    name: string;
    code: string;
    imageUrl?: string | null;
    createdTime: Date;
    modifiedTime: Date;
    productRegions?: ProductRegionModel[] | null;
}

export class PhysicalCardOrderStateLogModel implements IPhysicalCardOrderStateLogModel {
    physicalCardOrderStateLogId!: number;
    state!: PhysicalCardOrderState;
    description?: string | null;
    physicalCardOrderId!: number;
    createdTime!: Date;
    physicalCardOrder?: PhysicalCardOrderModel | null;

    constructor(data?: IPhysicalCardOrderStateLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.physicalCardOrderStateLogId = _data["physicalCardOrderStateLogId"] !== undefined ? _data["physicalCardOrderStateLogId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.physicalCardOrderId = _data["physicalCardOrderId"] !== undefined ? _data["physicalCardOrderId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.physicalCardOrder = _data["physicalCardOrder"] ? PhysicalCardOrderModel.fromJS(_data["physicalCardOrder"]) : <any>null;
        }
    }

    static fromJS(data: any): PhysicalCardOrderStateLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new PhysicalCardOrderStateLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["physicalCardOrderStateLogId"] = this.physicalCardOrderStateLogId !== undefined ? this.physicalCardOrderStateLogId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["physicalCardOrderId"] = this.physicalCardOrderId !== undefined ? this.physicalCardOrderId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["physicalCardOrder"] = this.physicalCardOrder ? this.physicalCardOrder.toJSON() : <any>null;
        return data;
    }
}

export interface IPhysicalCardOrderStateLogModel {
    physicalCardOrderStateLogId: number;
    state: PhysicalCardOrderState;
    description?: string | null;
    physicalCardOrderId: number;
    createdTime: Date;
    physicalCardOrder?: PhysicalCardOrderModel | null;
}

export class CreditWalletModel implements ICreditWalletModel {
    creditWalletId!: number;
    merchantId!: number;
    merchantCreditWalletId?: number | null;
    customerMerchantId!: number;
    customerMerchantCreditWalletId?: number | null;
    merchant?: MerchantModel | null;
    customerMerchant?: MerchantModel | null;
    walletOrders?: CreditOrderModel[] | null;

    constructor(data?: ICreditWalletModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creditWalletId = _data["creditWalletId"] !== undefined ? _data["creditWalletId"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.merchantCreditWalletId = _data["merchantCreditWalletId"] !== undefined ? _data["merchantCreditWalletId"] : <any>null;
            this.customerMerchantId = _data["customerMerchantId"] !== undefined ? _data["customerMerchantId"] : <any>null;
            this.customerMerchantCreditWalletId = _data["customerMerchantCreditWalletId"] !== undefined ? _data["customerMerchantCreditWalletId"] : <any>null;
            this.merchant = _data["merchant"] ? MerchantModel.fromJS(_data["merchant"]) : <any>null;
            this.customerMerchant = _data["customerMerchant"] ? MerchantModel.fromJS(_data["customerMerchant"]) : <any>null;
            if (Array.isArray(_data["walletOrders"])) {
                this.walletOrders = [] as any;
                for (let item of _data["walletOrders"])
                    this.walletOrders!.push(CreditOrderModel.fromJS(item));
            }
            else {
                this.walletOrders = <any>null;
            }
        }
    }

    static fromJS(data: any): CreditWalletModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreditWalletModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditWalletId"] = this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["merchantCreditWalletId"] = this.merchantCreditWalletId !== undefined ? this.merchantCreditWalletId : <any>null;
        data["customerMerchantId"] = this.customerMerchantId !== undefined ? this.customerMerchantId : <any>null;
        data["customerMerchantCreditWalletId"] = this.customerMerchantCreditWalletId !== undefined ? this.customerMerchantCreditWalletId : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["customerMerchant"] = this.customerMerchant ? this.customerMerchant.toJSON() : <any>null;
        if (Array.isArray(this.walletOrders)) {
            data["walletOrders"] = [];
            for (let item of this.walletOrders)
                data["walletOrders"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreditWalletModel {
    creditWalletId: number;
    merchantId: number;
    merchantCreditWalletId?: number | null;
    customerMerchantId: number;
    customerMerchantCreditWalletId?: number | null;
    merchant?: MerchantModel | null;
    customerMerchant?: MerchantModel | null;
    walletOrders?: CreditOrderModel[] | null;
}

export class CreditOrderModel implements ICreditOrderModel {
    creditOrderId!: number;
    mainWalletOrderId!: string;
    creditWalletOrderId!: string;
    state!: CreditOrderState;
    error?: string | null;
    description!: string;
    creditWalletId!: number;
    currencyId!: number;
    amount!: number;
    firstVerifierUserId?: string | null;
    secondVerifierUserId?: string | null;
    rejecterUserId?: string | null;
    createdByUserId!: string;
    createdTime!: Date;
    modifiedTime!: Date;
    modifiedByUserId!: string;
    currency?: CurrencyModel | null;
    creditWallet?: CreditWalletModel | null;
    creditOrderStateLogs?: CreditOrderStateLogModel[] | null;

    constructor(data?: ICreditOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creditOrderId = _data["creditOrderId"] !== undefined ? _data["creditOrderId"] : <any>null;
            this.mainWalletOrderId = _data["mainWalletOrderId"] !== undefined ? _data["mainWalletOrderId"] : <any>null;
            this.creditWalletOrderId = _data["creditWalletOrderId"] !== undefined ? _data["creditWalletOrderId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.creditWalletId = _data["creditWalletId"] !== undefined ? _data["creditWalletId"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.firstVerifierUserId = _data["firstVerifierUserId"] !== undefined ? _data["firstVerifierUserId"] : <any>null;
            this.secondVerifierUserId = _data["secondVerifierUserId"] !== undefined ? _data["secondVerifierUserId"] : <any>null;
            this.rejecterUserId = _data["rejecterUserId"] !== undefined ? _data["rejecterUserId"] : <any>null;
            this.createdByUserId = _data["createdByUserId"] !== undefined ? _data["createdByUserId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.modifiedByUserId = _data["modifiedByUserId"] !== undefined ? _data["modifiedByUserId"] : <any>null;
            this.currency = _data["currency"] ? CurrencyModel.fromJS(_data["currency"]) : <any>null;
            this.creditWallet = _data["creditWallet"] ? CreditWalletModel.fromJS(_data["creditWallet"]) : <any>null;
            if (Array.isArray(_data["creditOrderStateLogs"])) {
                this.creditOrderStateLogs = [] as any;
                for (let item of _data["creditOrderStateLogs"])
                    this.creditOrderStateLogs!.push(CreditOrderStateLogModel.fromJS(item));
            }
            else {
                this.creditOrderStateLogs = <any>null;
            }
        }
    }

    static fromJS(data: any): CreditOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreditOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditOrderId"] = this.creditOrderId !== undefined ? this.creditOrderId : <any>null;
        data["mainWalletOrderId"] = this.mainWalletOrderId !== undefined ? this.mainWalletOrderId : <any>null;
        data["creditWalletOrderId"] = this.creditWalletOrderId !== undefined ? this.creditWalletOrderId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["creditWalletId"] = this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["firstVerifierUserId"] = this.firstVerifierUserId !== undefined ? this.firstVerifierUserId : <any>null;
        data["secondVerifierUserId"] = this.secondVerifierUserId !== undefined ? this.secondVerifierUserId : <any>null;
        data["rejecterUserId"] = this.rejecterUserId !== undefined ? this.rejecterUserId : <any>null;
        data["createdByUserId"] = this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["modifiedByUserId"] = this.modifiedByUserId !== undefined ? this.modifiedByUserId : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["creditWallet"] = this.creditWallet ? this.creditWallet.toJSON() : <any>null;
        if (Array.isArray(this.creditOrderStateLogs)) {
            data["creditOrderStateLogs"] = [];
            for (let item of this.creditOrderStateLogs)
                data["creditOrderStateLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreditOrderModel {
    creditOrderId: number;
    mainWalletOrderId: string;
    creditWalletOrderId: string;
    state: CreditOrderState;
    error?: string | null;
    description: string;
    creditWalletId: number;
    currencyId: number;
    amount: number;
    firstVerifierUserId?: string | null;
    secondVerifierUserId?: string | null;
    rejecterUserId?: string | null;
    createdByUserId: string;
    createdTime: Date;
    modifiedTime: Date;
    modifiedByUserId: string;
    currency?: CurrencyModel | null;
    creditWallet?: CreditWalletModel | null;
    creditOrderStateLogs?: CreditOrderStateLogModel[] | null;
}

export enum CreditOrderState {
    Created = 0,
    AuthMainWallet = 1,
    SettingMinBalance = 2,
    Fail = 4,
    Success = 5,
    CaptureMainWallet = 6,
    Rejecting = 7,
    Verifying = 8,
    CapturingMainWallet = 9,
}

export class CreditOrderStateLogModel implements ICreditOrderStateLogModel {
    creditOrderStateLogId!: number;
    creditOrderId!: number;
    state!: CreditOrderState;
    reason?: string | null;
    createdTime!: Date;
    creditOrder?: CreditOrderModel | null;

    constructor(data?: ICreditOrderStateLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creditOrderStateLogId = _data["creditOrderStateLogId"] !== undefined ? _data["creditOrderStateLogId"] : <any>null;
            this.creditOrderId = _data["creditOrderId"] !== undefined ? _data["creditOrderId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.reason = _data["reason"] !== undefined ? _data["reason"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.creditOrder = _data["creditOrder"] ? CreditOrderModel.fromJS(_data["creditOrder"]) : <any>null;
        }
    }

    static fromJS(data: any): CreditOrderStateLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreditOrderStateLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creditOrderStateLogId"] = this.creditOrderStateLogId !== undefined ? this.creditOrderStateLogId : <any>null;
        data["creditOrderId"] = this.creditOrderId !== undefined ? this.creditOrderId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["creditOrder"] = this.creditOrder ? this.creditOrder.toJSON() : <any>null;
        return data;
    }
}

export interface ICreditOrderStateLogModel {
    creditOrderStateLogId: number;
    creditOrderId: number;
    state: CreditOrderState;
    reason?: string | null;
    createdTime: Date;
    creditOrder?: CreditOrderModel | null;
}

export class SettleOrderModel implements ISettleOrderModel {
    settleOrderId!: number;
    creditWalletOrderId!: string;
    mainWalletOrderId!: string;
    state!: SettleOrderState;
    reason?: string | null;
    description!: string;
    senderMerchantId!: number;
    senderMerchantCreditWalletId!: number;
    receiverMerchantId!: number;
    receiverMerchantCreditWalletId!: number;
    currencyId!: number;
    creditWalletId!: number;
    amount!: number;
    firstVerifierUserId?: string | null;
    secondVerifierUserId?: string | null;
    rejecterUserId?: string | null;
    createdByUserId!: string;
    createdTime!: Date;
    modifiedTime!: Date;
    modifiedByUserId!: string;
    senderMerchant?: MerchantModel | null;
    receiverMerchant?: MerchantModel | null;
    currency?: CurrencyModel | null;
    creditWallet?: CreditWalletModel | null;
    settleOrderStateLogs?: SettleOrderStateLogModel[] | null;

    constructor(data?: ISettleOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settleOrderId = _data["settleOrderId"] !== undefined ? _data["settleOrderId"] : <any>null;
            this.creditWalletOrderId = _data["creditWalletOrderId"] !== undefined ? _data["creditWalletOrderId"] : <any>null;
            this.mainWalletOrderId = _data["mainWalletOrderId"] !== undefined ? _data["mainWalletOrderId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.reason = _data["reason"] !== undefined ? _data["reason"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.senderMerchantId = _data["senderMerchantId"] !== undefined ? _data["senderMerchantId"] : <any>null;
            this.senderMerchantCreditWalletId = _data["senderMerchantCreditWalletId"] !== undefined ? _data["senderMerchantCreditWalletId"] : <any>null;
            this.receiverMerchantId = _data["receiverMerchantId"] !== undefined ? _data["receiverMerchantId"] : <any>null;
            this.receiverMerchantCreditWalletId = _data["receiverMerchantCreditWalletId"] !== undefined ? _data["receiverMerchantCreditWalletId"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.creditWalletId = _data["creditWalletId"] !== undefined ? _data["creditWalletId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.firstVerifierUserId = _data["firstVerifierUserId"] !== undefined ? _data["firstVerifierUserId"] : <any>null;
            this.secondVerifierUserId = _data["secondVerifierUserId"] !== undefined ? _data["secondVerifierUserId"] : <any>null;
            this.rejecterUserId = _data["rejecterUserId"] !== undefined ? _data["rejecterUserId"] : <any>null;
            this.createdByUserId = _data["createdByUserId"] !== undefined ? _data["createdByUserId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.modifiedByUserId = _data["modifiedByUserId"] !== undefined ? _data["modifiedByUserId"] : <any>null;
            this.senderMerchant = _data["senderMerchant"] ? MerchantModel.fromJS(_data["senderMerchant"]) : <any>null;
            this.receiverMerchant = _data["receiverMerchant"] ? MerchantModel.fromJS(_data["receiverMerchant"]) : <any>null;
            this.currency = _data["currency"] ? CurrencyModel.fromJS(_data["currency"]) : <any>null;
            this.creditWallet = _data["creditWallet"] ? CreditWalletModel.fromJS(_data["creditWallet"]) : <any>null;
            if (Array.isArray(_data["settleOrderStateLogs"])) {
                this.settleOrderStateLogs = [] as any;
                for (let item of _data["settleOrderStateLogs"])
                    this.settleOrderStateLogs!.push(SettleOrderStateLogModel.fromJS(item));
            }
            else {
                this.settleOrderStateLogs = <any>null;
            }
        }
    }

    static fromJS(data: any): SettleOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new SettleOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settleOrderId"] = this.settleOrderId !== undefined ? this.settleOrderId : <any>null;
        data["creditWalletOrderId"] = this.creditWalletOrderId !== undefined ? this.creditWalletOrderId : <any>null;
        data["mainWalletOrderId"] = this.mainWalletOrderId !== undefined ? this.mainWalletOrderId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["senderMerchantId"] = this.senderMerchantId !== undefined ? this.senderMerchantId : <any>null;
        data["senderMerchantCreditWalletId"] = this.senderMerchantCreditWalletId !== undefined ? this.senderMerchantCreditWalletId : <any>null;
        data["receiverMerchantId"] = this.receiverMerchantId !== undefined ? this.receiverMerchantId : <any>null;
        data["receiverMerchantCreditWalletId"] = this.receiverMerchantCreditWalletId !== undefined ? this.receiverMerchantCreditWalletId : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["creditWalletId"] = this.creditWalletId !== undefined ? this.creditWalletId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["firstVerifierUserId"] = this.firstVerifierUserId !== undefined ? this.firstVerifierUserId : <any>null;
        data["secondVerifierUserId"] = this.secondVerifierUserId !== undefined ? this.secondVerifierUserId : <any>null;
        data["rejecterUserId"] = this.rejecterUserId !== undefined ? this.rejecterUserId : <any>null;
        data["createdByUserId"] = this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["modifiedByUserId"] = this.modifiedByUserId !== undefined ? this.modifiedByUserId : <any>null;
        data["senderMerchant"] = this.senderMerchant ? this.senderMerchant.toJSON() : <any>null;
        data["receiverMerchant"] = this.receiverMerchant ? this.receiverMerchant.toJSON() : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["creditWallet"] = this.creditWallet ? this.creditWallet.toJSON() : <any>null;
        if (Array.isArray(this.settleOrderStateLogs)) {
            data["settleOrderStateLogs"] = [];
            for (let item of this.settleOrderStateLogs)
                data["settleOrderStateLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISettleOrderModel {
    settleOrderId: number;
    creditWalletOrderId: string;
    mainWalletOrderId: string;
    state: SettleOrderState;
    reason?: string | null;
    description: string;
    senderMerchantId: number;
    senderMerchantCreditWalletId: number;
    receiverMerchantId: number;
    receiverMerchantCreditWalletId: number;
    currencyId: number;
    creditWalletId: number;
    amount: number;
    firstVerifierUserId?: string | null;
    secondVerifierUserId?: string | null;
    rejecterUserId?: string | null;
    createdByUserId: string;
    createdTime: Date;
    modifiedTime: Date;
    modifiedByUserId: string;
    senderMerchant?: MerchantModel | null;
    receiverMerchant?: MerchantModel | null;
    currency?: CurrencyModel | null;
    creditWallet?: CreditWalletModel | null;
    settleOrderStateLogs?: SettleOrderStateLogModel[] | null;
}

export enum SettleOrderState {
    Created = 0,
    Fail = 1,
    Completed = 2,
    AuthCreditWallet = 3,
    AuthMainWallet = 4,
    RollbackCreditAuthWallet = 5,
    CapturingWallets = 6,
}

export class SettleOrderStateLogModel implements ISettleOrderStateLogModel {
    settleOrderStateLogId!: number;
    settleOrderId!: number;
    state!: SettleOrderState;
    error?: string | null;
    createdTime!: Date;
    settleOrder?: SettleOrderModel | null;

    constructor(data?: ISettleOrderStateLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.settleOrderStateLogId = _data["settleOrderStateLogId"] !== undefined ? _data["settleOrderStateLogId"] : <any>null;
            this.settleOrderId = _data["settleOrderId"] !== undefined ? _data["settleOrderId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.settleOrder = _data["settleOrder"] ? SettleOrderModel.fromJS(_data["settleOrder"]) : <any>null;
        }
    }

    static fromJS(data: any): SettleOrderStateLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new SettleOrderStateLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["settleOrderStateLogId"] = this.settleOrderStateLogId !== undefined ? this.settleOrderStateLogId : <any>null;
        data["settleOrderId"] = this.settleOrderId !== undefined ? this.settleOrderId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["settleOrder"] = this.settleOrder ? this.settleOrder.toJSON() : <any>null;
        return data;
    }
}

export interface ISettleOrderStateLogModel {
    settleOrderStateLogId: number;
    settleOrderId: number;
    state: SettleOrderState;
    error?: string | null;
    createdTime: Date;
    settleOrder?: SettleOrderModel | null;
}

export class OrdinaryOrderModel implements IOrdinaryOrderModel {
    ordinaryOrderId!: number;
    walletOrderId!: string;
    state!: OrdinaryOrderState;
    ordinaryOrderType!: OrdinaryOrderType;
    reason?: string | null;
    description!: string;
    merchantId!: number;
    receiverMerchantId!: number;
    currencyId!: number;
    bankId?: number | null;
    amount!: number;
    firstVerifierUserId?: string | null;
    secondVerifierUserId?: string | null;
    rejecterUserId?: string | null;
    createdByUserId!: string;
    createdTime!: Date;
    modifiedTime!: Date;
    modifiedByUserId!: string;
    currency?: CurrencyModel | null;
    merchant?: MerchantModel | null;
    receiverMerchant?: MerchantModel | null;
    bank?: BankModel | null;
    ordinaryOrderStateLogs?: OrdinaryOrderStateLogModel[] | null;

    constructor(data?: IOrdinaryOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ordinaryOrderId = _data["ordinaryOrderId"] !== undefined ? _data["ordinaryOrderId"] : <any>null;
            this.walletOrderId = _data["walletOrderId"] !== undefined ? _data["walletOrderId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.ordinaryOrderType = _data["ordinaryOrderType"] !== undefined ? _data["ordinaryOrderType"] : <any>null;
            this.reason = _data["reason"] !== undefined ? _data["reason"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.receiverMerchantId = _data["receiverMerchantId"] !== undefined ? _data["receiverMerchantId"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.bankId = _data["bankId"] !== undefined ? _data["bankId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.firstVerifierUserId = _data["firstVerifierUserId"] !== undefined ? _data["firstVerifierUserId"] : <any>null;
            this.secondVerifierUserId = _data["secondVerifierUserId"] !== undefined ? _data["secondVerifierUserId"] : <any>null;
            this.rejecterUserId = _data["rejecterUserId"] !== undefined ? _data["rejecterUserId"] : <any>null;
            this.createdByUserId = _data["createdByUserId"] !== undefined ? _data["createdByUserId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.modifiedByUserId = _data["modifiedByUserId"] !== undefined ? _data["modifiedByUserId"] : <any>null;
            this.currency = _data["currency"] ? CurrencyModel.fromJS(_data["currency"]) : <any>null;
            this.merchant = _data["merchant"] ? MerchantModel.fromJS(_data["merchant"]) : <any>null;
            this.receiverMerchant = _data["receiverMerchant"] ? MerchantModel.fromJS(_data["receiverMerchant"]) : <any>null;
            this.bank = _data["bank"] ? BankModel.fromJS(_data["bank"]) : <any>null;
            if (Array.isArray(_data["ordinaryOrderStateLogs"])) {
                this.ordinaryOrderStateLogs = [] as any;
                for (let item of _data["ordinaryOrderStateLogs"])
                    this.ordinaryOrderStateLogs!.push(OrdinaryOrderStateLogModel.fromJS(item));
            }
            else {
                this.ordinaryOrderStateLogs = <any>null;
            }
        }
    }

    static fromJS(data: any): OrdinaryOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrdinaryOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ordinaryOrderId"] = this.ordinaryOrderId !== undefined ? this.ordinaryOrderId : <any>null;
        data["walletOrderId"] = this.walletOrderId !== undefined ? this.walletOrderId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["ordinaryOrderType"] = this.ordinaryOrderType !== undefined ? this.ordinaryOrderType : <any>null;
        data["reason"] = this.reason !== undefined ? this.reason : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["receiverMerchantId"] = this.receiverMerchantId !== undefined ? this.receiverMerchantId : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["bankId"] = this.bankId !== undefined ? this.bankId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["firstVerifierUserId"] = this.firstVerifierUserId !== undefined ? this.firstVerifierUserId : <any>null;
        data["secondVerifierUserId"] = this.secondVerifierUserId !== undefined ? this.secondVerifierUserId : <any>null;
        data["rejecterUserId"] = this.rejecterUserId !== undefined ? this.rejecterUserId : <any>null;
        data["createdByUserId"] = this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["modifiedByUserId"] = this.modifiedByUserId !== undefined ? this.modifiedByUserId : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["receiverMerchant"] = this.receiverMerchant ? this.receiverMerchant.toJSON() : <any>null;
        data["bank"] = this.bank ? this.bank.toJSON() : <any>null;
        if (Array.isArray(this.ordinaryOrderStateLogs)) {
            data["ordinaryOrderStateLogs"] = [];
            for (let item of this.ordinaryOrderStateLogs)
                data["ordinaryOrderStateLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrdinaryOrderModel {
    ordinaryOrderId: number;
    walletOrderId: string;
    state: OrdinaryOrderState;
    ordinaryOrderType: OrdinaryOrderType;
    reason?: string | null;
    description: string;
    merchantId: number;
    receiverMerchantId: number;
    currencyId: number;
    bankId?: number | null;
    amount: number;
    firstVerifierUserId?: string | null;
    secondVerifierUserId?: string | null;
    rejecterUserId?: string | null;
    createdByUserId: string;
    createdTime: Date;
    modifiedTime: Date;
    modifiedByUserId: string;
    currency?: CurrencyModel | null;
    merchant?: MerchantModel | null;
    receiverMerchant?: MerchantModel | null;
    bank?: BankModel | null;
    ordinaryOrderStateLogs?: OrdinaryOrderStateLogModel[] | null;
}

export enum OrdinaryOrderState {
    Created = "Created",
    Success = "Success",
    Fail = "Fail",
    AuthWallet = "AuthWallet",
    Rejecting = "Rejecting",
    Verifying = "Verifying",
}

export enum OrdinaryOrderType {
    Charge = "Charge",
    Withdraw = "Withdraw",
    Rebate = "Rebate",
}

export class BankModel implements IBankModel {
    bankId!: number;
    bankName!: string;
    ordinaryOrders?: OrdinaryOrderModel[] | null;

    constructor(data?: IBankModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankId = _data["bankId"] !== undefined ? _data["bankId"] : <any>null;
            this.bankName = _data["bankName"] !== undefined ? _data["bankName"] : <any>null;
            if (Array.isArray(_data["ordinaryOrders"])) {
                this.ordinaryOrders = [] as any;
                for (let item of _data["ordinaryOrders"])
                    this.ordinaryOrders!.push(OrdinaryOrderModel.fromJS(item));
            }
            else {
                this.ordinaryOrders = <any>null;
            }
        }
    }

    static fromJS(data: any): BankModel {
        data = typeof data === 'object' ? data : {};
        let result = new BankModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankId"] = this.bankId !== undefined ? this.bankId : <any>null;
        data["bankName"] = this.bankName !== undefined ? this.bankName : <any>null;
        if (Array.isArray(this.ordinaryOrders)) {
            data["ordinaryOrders"] = [];
            for (let item of this.ordinaryOrders)
                data["ordinaryOrders"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBankModel {
    bankId: number;
    bankName: string;
    ordinaryOrders?: OrdinaryOrderModel[] | null;
}

export class OrdinaryOrderStateLogModel implements IOrdinaryOrderStateLogModel {
    ordinaryOrderStateLogId!: number;
    ordinaryOrderId!: number;
    state!: OrdinaryOrderState;
    error?: string | null;
    createdTime!: Date;
    ordinaryOrder?: OrdinaryOrderModel | null;

    constructor(data?: IOrdinaryOrderStateLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ordinaryOrderStateLogId = _data["ordinaryOrderStateLogId"] !== undefined ? _data["ordinaryOrderStateLogId"] : <any>null;
            this.ordinaryOrderId = _data["ordinaryOrderId"] !== undefined ? _data["ordinaryOrderId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.ordinaryOrder = _data["ordinaryOrder"] ? OrdinaryOrderModel.fromJS(_data["ordinaryOrder"]) : <any>null;
        }
    }

    static fromJS(data: any): OrdinaryOrderStateLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrdinaryOrderStateLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ordinaryOrderStateLogId"] = this.ordinaryOrderStateLogId !== undefined ? this.ordinaryOrderStateLogId : <any>null;
        data["ordinaryOrderId"] = this.ordinaryOrderId !== undefined ? this.ordinaryOrderId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["ordinaryOrder"] = this.ordinaryOrder ? this.ordinaryOrder.toJSON() : <any>null;
        return data;
    }
}

export interface IOrdinaryOrderStateLogModel {
    ordinaryOrderStateLogId: number;
    ordinaryOrderId: number;
    state: OrdinaryOrderState;
    error?: string | null;
    createdTime: Date;
    ordinaryOrder?: OrdinaryOrderModel | null;
}

export class InvoiceModel implements IInvoiceModel {
    invoiceId!: number;
    merchantId!: number;
    createdTime!: Date;
    beginTime!: Date;
    endTime!: Date;
    merchant?: MerchantModel | null;
    invoiceDetails?: InvoiceDetailModel[] | null;

    constructor(data?: IInvoiceModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"] !== undefined ? _data["invoiceId"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.beginTime = _data["beginTime"] ? new Date(_data["beginTime"].toString()) : <any>null;
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>null;
            this.merchant = _data["merchant"] ? MerchantModel.fromJS(_data["merchant"]) : <any>null;
            if (Array.isArray(_data["invoiceDetails"])) {
                this.invoiceDetails = [] as any;
                for (let item of _data["invoiceDetails"])
                    this.invoiceDetails!.push(InvoiceDetailModel.fromJS(item));
            }
            else {
                this.invoiceDetails = <any>null;
            }
        }
    }

    static fromJS(data: any): InvoiceModel {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId !== undefined ? this.invoiceId : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["beginTime"] = this.beginTime ? this.beginTime.toISOString() : <any>null;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        if (Array.isArray(this.invoiceDetails)) {
            data["invoiceDetails"] = [];
            for (let item of this.invoiceDetails)
                data["invoiceDetails"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInvoiceModel {
    invoiceId: number;
    merchantId: number;
    createdTime: Date;
    beginTime: Date;
    endTime: Date;
    merchant?: MerchantModel | null;
    invoiceDetails?: InvoiceDetailModel[] | null;
}

export class InvoiceDetailModel implements IInvoiceDetailModel {
    invoiceDetailId!: number;
    invoiceId!: number;
    buyOrderId!: number;
    invoice?: InvoiceModel | null;

    constructor(data?: IInvoiceDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceDetailId = _data["invoiceDetailId"] !== undefined ? _data["invoiceDetailId"] : <any>null;
            this.invoiceId = _data["invoiceId"] !== undefined ? _data["invoiceId"] : <any>null;
            this.buyOrderId = _data["buyOrderId"] !== undefined ? _data["buyOrderId"] : <any>null;
            this.invoice = _data["invoice"] ? InvoiceModel.fromJS(_data["invoice"]) : <any>null;
        }
    }

    static fromJS(data: any): InvoiceDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceDetailId"] = this.invoiceDetailId !== undefined ? this.invoiceDetailId : <any>null;
        data["invoiceId"] = this.invoiceId !== undefined ? this.invoiceId : <any>null;
        data["buyOrderId"] = this.buyOrderId !== undefined ? this.buyOrderId : <any>null;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>null;
        return data;
    }
}

export interface IInvoiceDetailModel {
    invoiceDetailId: number;
    invoiceId: number;
    buyOrderId: number;
    invoice?: InvoiceModel | null;
}

export class MerchantCurrencyLimitModel implements IMerchantCurrencyLimitModel {
    merchantCurrencyLimitId!: number;
    merchantId!: number;
    amount!: number;
    currencyId!: number;
    createdTime!: Date;
    modifiedTime!: Date;
    merchant?: MerchantModel | null;
    currency?: CurrencyModel | null;

    constructor(data?: IMerchantCurrencyLimitModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.merchantCurrencyLimitId = _data["merchantCurrencyLimitId"] !== undefined ? _data["merchantCurrencyLimitId"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.merchant = _data["merchant"] ? MerchantModel.fromJS(_data["merchant"]) : <any>null;
            this.currency = _data["currency"] ? CurrencyModel.fromJS(_data["currency"]) : <any>null;
        }
    }

    static fromJS(data: any): MerchantCurrencyLimitModel {
        data = typeof data === 'object' ? data : {};
        let result = new MerchantCurrencyLimitModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["merchantCurrencyLimitId"] = this.merchantCurrencyLimitId !== undefined ? this.merchantCurrencyLimitId : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
        return data;
    }
}

export interface IMerchantCurrencyLimitModel {
    merchantCurrencyLimitId: number;
    merchantId: number;
    amount: number;
    currencyId: number;
    createdTime: Date;
    modifiedTime: Date;
    merchant?: MerchantModel | null;
    currency?: CurrencyModel | null;
}

export class PostPayInvoiceItemModel implements IPostPayInvoiceItemModel {
    postPayInvoiceItemId!: number;
    postPayInvoiceId!: number;
    merchantId!: number;
    paymentOrderId?: number | null;
    amount!: number;
    createdTime!: Date;
    modifiedTime!: Date;
    description?: string | null;
    paymentOrder?: PaymentOrderModel | null;
    postPayInvoice?: PostPayInvoiceModel | null;
    merchant?: MerchantModel | null;

    constructor(data?: IPostPayInvoiceItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postPayInvoiceItemId = _data["postPayInvoiceItemId"] !== undefined ? _data["postPayInvoiceItemId"] : <any>null;
            this.postPayInvoiceId = _data["postPayInvoiceId"] !== undefined ? _data["postPayInvoiceId"] : <any>null;
            this.merchantId = _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
            this.paymentOrderId = _data["paymentOrderId"] !== undefined ? _data["paymentOrderId"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.paymentOrder = _data["paymentOrder"] ? PaymentOrderModel.fromJS(_data["paymentOrder"]) : <any>null;
            this.postPayInvoice = _data["postPayInvoice"] ? PostPayInvoiceModel.fromJS(_data["postPayInvoice"]) : <any>null;
            this.merchant = _data["merchant"] ? MerchantModel.fromJS(_data["merchant"]) : <any>null;
        }
    }

    static fromJS(data: any): PostPayInvoiceItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new PostPayInvoiceItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postPayInvoiceItemId"] = this.postPayInvoiceItemId !== undefined ? this.postPayInvoiceItemId : <any>null;
        data["postPayInvoiceId"] = this.postPayInvoiceId !== undefined ? this.postPayInvoiceId : <any>null;
        data["merchantId"] = this.merchantId !== undefined ? this.merchantId : <any>null;
        data["paymentOrderId"] = this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["paymentOrder"] = this.paymentOrder ? this.paymentOrder.toJSON() : <any>null;
        data["postPayInvoice"] = this.postPayInvoice ? this.postPayInvoice.toJSON() : <any>null;
        data["merchant"] = this.merchant ? this.merchant.toJSON() : <any>null;
        return data;
    }
}

export interface IPostPayInvoiceItemModel {
    postPayInvoiceItemId: number;
    postPayInvoiceId: number;
    merchantId: number;
    paymentOrderId?: number | null;
    amount: number;
    createdTime: Date;
    modifiedTime: Date;
    description?: string | null;
    paymentOrder?: PaymentOrderModel | null;
    postPayInvoice?: PostPayInvoiceModel | null;
    merchant?: MerchantModel | null;
}

export class PostPayInvoiceModel implements IPostPayInvoiceModel {
    postPayInvoiceId!: number;
    createTime!: Date;
    currencyId!: number;
    postPayInvoiceItems?: PostPayInvoiceItemModel[] | null;

    constructor(data?: IPostPayInvoiceModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.postPayInvoiceId = _data["postPayInvoiceId"] !== undefined ? _data["postPayInvoiceId"] : <any>null;
            this.createTime = _data["createTime"] ? new Date(_data["createTime"].toString()) : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            if (Array.isArray(_data["postPayInvoiceItems"])) {
                this.postPayInvoiceItems = [] as any;
                for (let item of _data["postPayInvoiceItems"])
                    this.postPayInvoiceItems!.push(PostPayInvoiceItemModel.fromJS(item));
            }
            else {
                this.postPayInvoiceItems = <any>null;
            }
        }
    }

    static fromJS(data: any): PostPayInvoiceModel {
        data = typeof data === 'object' ? data : {};
        let result = new PostPayInvoiceModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postPayInvoiceId"] = this.postPayInvoiceId !== undefined ? this.postPayInvoiceId : <any>null;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        if (Array.isArray(this.postPayInvoiceItems)) {
            data["postPayInvoiceItems"] = [];
            for (let item of this.postPayInvoiceItems)
                data["postPayInvoiceItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPostPayInvoiceModel {
    postPayInvoiceId: number;
    createTime: Date;
    currencyId: number;
    postPayInvoiceItems?: PostPayInvoiceItemModel[] | null;
}

export class PaymentOrderStateLogModel implements IPaymentOrderStateLogModel {
    paymentOrderStateLogId!: number;
    paymentOrderId!: number;
    state!: PaymentOrderState;
    error?: string | null;
    createdTime!: Date;
    paymentOrder?: PaymentOrderModel | null;

    constructor(data?: IPaymentOrderStateLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentOrderStateLogId = _data["paymentOrderStateLogId"] !== undefined ? _data["paymentOrderStateLogId"] : <any>null;
            this.paymentOrderId = _data["paymentOrderId"] !== undefined ? _data["paymentOrderId"] : <any>null;
            this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.paymentOrder = _data["paymentOrder"] ? PaymentOrderModel.fromJS(_data["paymentOrder"]) : <any>null;
        }
    }

    static fromJS(data: any): PaymentOrderStateLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentOrderStateLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentOrderStateLogId"] = this.paymentOrderStateLogId !== undefined ? this.paymentOrderStateLogId : <any>null;
        data["paymentOrderId"] = this.paymentOrderId !== undefined ? this.paymentOrderId : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["paymentOrder"] = this.paymentOrder ? this.paymentOrder.toJSON() : <any>null;
        return data;
    }
}

export interface IPaymentOrderStateLogModel {
    paymentOrderStateLogId: number;
    paymentOrderId: number;
    state: PaymentOrderState;
    error?: string | null;
    createdTime: Date;
    paymentOrder?: PaymentOrderModel | null;
}

export class UpdateSettingRequest implements IUpdateSettingRequest {
    startInvoiceDate?: PatchOfDateTime | null;
    invoiceDailyTime?: PatchOfDateTime | null;

    constructor(data?: IUpdateSettingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startInvoiceDate = _data["startInvoiceDate"] ? PatchOfDateTime.fromJS(_data["startInvoiceDate"]) : <any>null;
            this.invoiceDailyTime = _data["invoiceDailyTime"] ? PatchOfDateTime.fromJS(_data["invoiceDailyTime"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateSettingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSettingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startInvoiceDate"] = this.startInvoiceDate ? this.startInvoiceDate.toJSON() : <any>null;
        data["invoiceDailyTime"] = this.invoiceDailyTime ? this.invoiceDailyTime.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdateSettingRequest {
    startInvoiceDate?: PatchOfDateTime | null;
    invoiceDailyTime?: PatchOfDateTime | null;
}

export class PatchOfDateTime implements IPatchOfDateTime {
    value!: Date;

    constructor(data?: IPatchOfDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PatchOfDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toISOString() : <any>null;
        return data;
    }
}

export interface IPatchOfDateTime {
    value: Date;
}

export class CreatePaymentProfileRequest implements ICreatePaymentProfileRequest {
    description!: string;
    name!: string;
    currencyId!: number;
    providerProfileId!: number;
    minAmount!: number;
    maxAmount!: number;
    imageUri1!: string;
    imageUri2!: string;
    hasAutoPayment!: boolean;

    constructor(data?: ICreatePaymentProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.currencyId = _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
            this.providerProfileId = _data["providerProfileId"] !== undefined ? _data["providerProfileId"] : <any>null;
            this.minAmount = _data["minAmount"] !== undefined ? _data["minAmount"] : <any>null;
            this.maxAmount = _data["maxAmount"] !== undefined ? _data["maxAmount"] : <any>null;
            this.imageUri1 = _data["imageUri1"] !== undefined ? _data["imageUri1"] : <any>null;
            this.imageUri2 = _data["imageUri2"] !== undefined ? _data["imageUri2"] : <any>null;
            this.hasAutoPayment = _data["hasAutoPayment"] !== undefined ? _data["hasAutoPayment"] : <any>null;
        }
    }

    static fromJS(data: any): CreatePaymentProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["currencyId"] = this.currencyId !== undefined ? this.currencyId : <any>null;
        data["providerProfileId"] = this.providerProfileId !== undefined ? this.providerProfileId : <any>null;
        data["minAmount"] = this.minAmount !== undefined ? this.minAmount : <any>null;
        data["maxAmount"] = this.maxAmount !== undefined ? this.maxAmount : <any>null;
        data["imageUri1"] = this.imageUri1 !== undefined ? this.imageUri1 : <any>null;
        data["imageUri2"] = this.imageUri2 !== undefined ? this.imageUri2 : <any>null;
        data["hasAutoPayment"] = this.hasAutoPayment !== undefined ? this.hasAutoPayment : <any>null;
        return data;
    }
}

export interface ICreatePaymentProfileRequest {
    description: string;
    name: string;
    currencyId: number;
    providerProfileId: number;
    minAmount: number;
    maxAmount: number;
    imageUri1: string;
    imageUri2: string;
    hasAutoPayment: boolean;
}

export class UpdatePaymentProfileRequest implements IUpdatePaymentProfileRequest {
    description?: PatchOfString | null;
    name?: PatchOfString | null;
    minAmount?: PatchOfNullableDecimal | null;
    maxAmount?: PatchOfNullableDecimal | null;
    imageUri1?: PatchOfUri | null;
    imageUri2?: PatchOfUri | null;

    constructor(data?: IUpdatePaymentProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"] ? PatchOfString.fromJS(_data["description"]) : <any>null;
            this.name = _data["name"] ? PatchOfString.fromJS(_data["name"]) : <any>null;
            this.minAmount = _data["minAmount"] ? PatchOfNullableDecimal.fromJS(_data["minAmount"]) : <any>null;
            this.maxAmount = _data["maxAmount"] ? PatchOfNullableDecimal.fromJS(_data["maxAmount"]) : <any>null;
            this.imageUri1 = _data["imageUri1"] ? PatchOfUri.fromJS(_data["imageUri1"]) : <any>null;
            this.imageUri2 = _data["imageUri2"] ? PatchOfUri.fromJS(_data["imageUri2"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdatePaymentProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description ? this.description.toJSON() : <any>null;
        data["name"] = this.name ? this.name.toJSON() : <any>null;
        data["minAmount"] = this.minAmount ? this.minAmount.toJSON() : <any>null;
        data["maxAmount"] = this.maxAmount ? this.maxAmount.toJSON() : <any>null;
        data["imageUri1"] = this.imageUri1 ? this.imageUri1.toJSON() : <any>null;
        data["imageUri2"] = this.imageUri2 ? this.imageUri2.toJSON() : <any>null;
        return data;
    }
}

export interface IUpdatePaymentProfileRequest {
    description?: PatchOfString | null;
    name?: PatchOfString | null;
    minAmount?: PatchOfNullableDecimal | null;
    maxAmount?: PatchOfNullableDecimal | null;
    imageUri1?: PatchOfUri | null;
    imageUri2?: PatchOfUri | null;
}

export class PatchOfNullableDecimal implements IPatchOfNullableDecimal {
    value?: number | null;

    constructor(data?: IPatchOfNullableDecimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfNullableDecimal {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfNullableDecimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfNullableDecimal {
    value?: number | null;
}

export class UserRole2 implements IUserRole2 {
    resourceId!: string;
    userId!: string;
    role!: Role;

    constructor(data?: IUserRole2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new Role();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"] !== undefined ? _data["resourceId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : new Role();
        }
    }

    static fromJS(data: any): UserRole2 {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId !== undefined ? this.resourceId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["role"] = this.role ? this.role.toJSON() : <any>null;
        return data;
    }
}

export interface IUserRole2 {
    resourceId: string;
    userId: string;
    role: Role;
}

export class UserRole extends UserRole2 implements IUserRole {
    user?: User | null;

    constructor(data?: IUserRole) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>null;
        }
    }

    static override fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IUserRole extends IUserRole2 {
    user?: User | null;
}

export class User implements IUser {
    userId!: string;
    email?: string | null;
    name?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    pictureUrl?: string | null;
    phone?: string | null;
    createdTime!: Date;
    accessedTime?: Date | null;
    authorizationCode?: string | null;
    isDisabled!: boolean;
    isEmailVerified!: boolean;
    isPhoneVerified!: boolean;
    isBot!: boolean;
    description?: string | null;
    exData?: string | null;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.pictureUrl = _data["pictureUrl"] !== undefined ? _data["pictureUrl"] : <any>null;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.accessedTime = _data["accessedTime"] ? new Date(_data["accessedTime"].toString()) : <any>null;
            this.authorizationCode = _data["authorizationCode"] !== undefined ? _data["authorizationCode"] : <any>null;
            this.isDisabled = _data["isDisabled"] !== undefined ? _data["isDisabled"] : <any>null;
            this.isEmailVerified = _data["isEmailVerified"] !== undefined ? _data["isEmailVerified"] : <any>null;
            this.isPhoneVerified = _data["isPhoneVerified"] !== undefined ? _data["isPhoneVerified"] : <any>null;
            this.isBot = _data["isBot"] !== undefined ? _data["isBot"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.exData = _data["exData"] !== undefined ? _data["exData"] : <any>null;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["pictureUrl"] = this.pictureUrl !== undefined ? this.pictureUrl : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["accessedTime"] = this.accessedTime ? this.accessedTime.toISOString() : <any>null;
        data["authorizationCode"] = this.authorizationCode !== undefined ? this.authorizationCode : <any>null;
        data["isDisabled"] = this.isDisabled !== undefined ? this.isDisabled : <any>null;
        data["isEmailVerified"] = this.isEmailVerified !== undefined ? this.isEmailVerified : <any>null;
        data["isPhoneVerified"] = this.isPhoneVerified !== undefined ? this.isPhoneVerified : <any>null;
        data["isBot"] = this.isBot !== undefined ? this.isBot : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["exData"] = this.exData !== undefined ? this.exData : <any>null;
        return data;
    }
}

export interface IUser {
    userId: string;
    email?: string | null;
    name?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    pictureUrl?: string | null;
    phone?: string | null;
    createdTime: Date;
    accessedTime?: Date | null;
    authorizationCode?: string | null;
    isDisabled: boolean;
    isEmailVerified: boolean;
    isPhoneVerified: boolean;
    isBot: boolean;
    description?: string | null;
    exData?: string | null;
}

export class Role implements IRole {
    roleId!: string;
    roleName!: string;
    description?: string | null;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IRole {
    roleId: string;
    roleName: string;
    description?: string | null;
}

export class ApiKey implements IApiKey {
    accessToken!: Token;
    refreshToken?: Token | null;
    userId!: string;

    constructor(data?: IApiKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accessToken = new Token();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] ? Token.fromJS(_data["accessToken"]) : new Token();
            this.refreshToken = _data["refreshToken"] ? Token.fromJS(_data["refreshToken"]) : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
        }
    }

    static fromJS(data: any): ApiKey {
        data = typeof data === 'object' ? data : {};
        let result = new ApiKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : <any>null;
        data["refreshToken"] = this.refreshToken ? this.refreshToken.toJSON() : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        return data;
    }
}

export interface IApiKey {
    accessToken: Token;
    refreshToken?: Token | null;
    userId: string;
}

export class Token implements IToken {
    value!: string;
    expirationTime!: Date;
    scheme!: string;
    issuedTime!: Date;

    constructor(data?: IToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>null;
            this.scheme = _data["scheme"] !== undefined ? _data["scheme"] : <any>null;
            this.issuedTime = _data["issuedTime"] ? new Date(_data["issuedTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Token {
        data = typeof data === 'object' ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>null;
        data["scheme"] = this.scheme !== undefined ? this.scheme : <any>null;
        data["issuedTime"] = this.issuedTime ? this.issuedTime.toISOString() : <any>null;
        return data;
    }
}

export interface IToken {
    value: string;
    expirationTime: Date;
    scheme: string;
    issuedTime: Date;
}

export class TeamUpdateBotParam implements ITeamUpdateBotParam {
    name?: PatchOfString | null;

    constructor(data?: ITeamUpdateBotParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? PatchOfString.fromJS(_data["name"]) : <any>null;
        }
    }

    static fromJS(data: any): TeamUpdateBotParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamUpdateBotParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>null;
        return data;
    }
}

export interface ITeamUpdateBotParam {
    name?: PatchOfString | null;
}

export class ListResultOfUserRole implements IListResultOfUserRole {
    totalCount?: number | null;
    items!: UserRole[];

    constructor(data?: IListResultOfUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserRole.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): ListResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultOfUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultOfUserRole {
    totalCount?: number | null;
    items: UserRole[];
}

export class TeamUserOfUserAndUserRoleAndRole implements ITeamUserOfUserAndUserRoleAndRole {
    user!: User;
    roles!: Role[];

    constructor(data?: ITeamUserOfUserAndUserRoleAndRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
            else {
                this.roles = <any>null;
            }
        }
    }

    static fromJS(data: any): TeamUserOfUserAndUserRoleAndRole {
        data = typeof data === 'object' ? data : {};
        let result = new TeamUserOfUserAndUserRoleAndRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITeamUserOfUserAndUserRoleAndRole {
    user: User;
    roles: Role[];
}

export class TeamAddBotParam implements ITeamAddBotParam {
    name!: string;

    constructor(data?: ITeamAddBotParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): TeamAddBotParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamAddBotParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ITeamAddBotParam {
    name: string;
}

export class TeamAddEmailParam implements ITeamAddEmailParam {

    constructor(data?: ITeamAddEmailParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): TeamAddEmailParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamAddEmailParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ITeamAddEmailParam {
}

export class SignInRequest implements ISignInRequest {
    idToken!: string;
    refreshTokenType!: RefreshTokenType;

    constructor(data?: ISignInRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idToken = _data["idToken"] !== undefined ? _data["idToken"] : <any>null;
            this.refreshTokenType = _data["refreshTokenType"] !== undefined ? _data["refreshTokenType"] : <any>null;
        }
    }

    static fromJS(data: any): SignInRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignInRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idToken"] = this.idToken !== undefined ? this.idToken : <any>null;
        data["refreshTokenType"] = this.refreshTokenType !== undefined ? this.refreshTokenType : <any>null;
        return data;
    }
}

export interface ISignInRequest {
    idToken: string;
    refreshTokenType: RefreshTokenType;
}

export enum RefreshTokenType {
    None = "None",
    Web = "Web",
    App = "App",
}

export class SignUpRequest implements ISignUpRequest {
    idToken!: string;
    refreshTokenType!: RefreshTokenType;

    constructor(data?: ISignUpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idToken = _data["idToken"] !== undefined ? _data["idToken"] : <any>null;
            this.refreshTokenType = _data["refreshTokenType"] !== undefined ? _data["refreshTokenType"] : <any>null;
        }
    }

    static fromJS(data: any): SignUpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idToken"] = this.idToken !== undefined ? this.idToken : <any>null;
        data["refreshTokenType"] = this.refreshTokenType !== undefined ? this.refreshTokenType : <any>null;
        return data;
    }
}

export interface ISignUpRequest {
    idToken: string;
    refreshTokenType: RefreshTokenType;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken!: string;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken: string;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

export class ApiException extends Error {
    statusCode: number;
    response?: string;
    exceptionTypeName?: string;
    exceptionTypeFullName?: string;
    headers: any;
    data: any = {};

    constructor(
        message: string,
        statusCode: number,
        response?: any,
        headers?: any,
        innerException?: Error | null
    ) {
        if (!(response instanceof String)) response = JSON.stringify(response);
        super(ApiException.buildMessage(message, statusCode, response));
        Object.setPrototypeOf(this, ApiException.prototype);

        this.statusCode = statusCode;
        this.response = response;
        this.headers = headers;

        let serverException: ServerException | null = ServerException.tryParse(response);
        if (serverException) {
            Object.keys(serverException.Data).forEach((key) => {
                if (serverException)
                    this.data[key] = serverException.Data[key];
            });
            this.exceptionTypeName = serverException.TypeName;
            this.exceptionTypeFullName = serverException.TypeFullName;
        }

        if (innerException) {
            this.stack = innerException.stack;
        }
    }

    private static buildMessage(
        message: string,
        statusCode: number,
        response?: string
    ): string {
        let serverException = ServerException.tryParse(response);
        if (serverException)
            return serverException.Message || '';

        return `${message}\n\nStatus: ${statusCode}\nResponse:\n${response?.substring(0, Math.min(512, response.length))}`;
    }

    override toString(): string {
        return `HTTP Response:\n\n${this.response}\n\n${super.toString()}`;
    }
}

class ServerException {
    Data!: { [key: string]: string | null };
    TypeName?: string;
    TypeFullName?: string;
    Message?: string;

    public static tryParse(value: string | undefined): ServerException | null {
        if (!value)
            return null;

        try {
            let serverException: ServerException = JSON.parse(value);
            return serverException.TypeName ? serverException : null;
        } catch {
            return null;
        }
    }
}