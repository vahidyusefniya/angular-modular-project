//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from "rxjs/operators";
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
} from "rxjs";
import { Injectable, Inject, Optional, InjectionToken } from "@angular/core";
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
  HttpContext,
} from "@angular/common/http";
import { ApiException } from "./api-exception";

export const API_BASE_URL = new InjectionToken<string>("API_BASE_URL");

@Injectable()
export class BuyOrdersClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  placeOrder(
    branchId: number,
    request: PlaceDigitalCardOrderRequest,
    httpContext?: HttpContext
  ): Observable<number> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/place-order";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPlaceOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPlaceOrder(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processPlaceOrder(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getBuyOrders(
    branchId: number,
    currencyId?: number | null | undefined,
    isPhysicalCardOrder?: boolean | undefined,
    searchCriteria?: string | null | undefined,
    buyOrderStates?: string | null | undefined,
    beginTime?: Date | null | undefined,
    endTime?: Date | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<BuyOrder[]> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/buys?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (currencyId !== undefined && currencyId !== null)
      url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
    if (isPhysicalCardOrder === null)
      throw new Error("The parameter 'isPhysicalCardOrder' cannot be null.");
    else if (isPhysicalCardOrder !== undefined)
      url_ +=
        "isPhysicalCardOrder=" +
        encodeURIComponent("" + isPhysicalCardOrder) +
        "&";
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    if (buyOrderStates !== undefined && buyOrderStates !== null)
      url_ += "buyOrderStates=" + encodeURIComponent("" + buyOrderStates) + "&";
    if (beginTime !== undefined && beginTime !== null)
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime !== undefined && endTime !== null)
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBuyOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBuyOrders(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BuyOrder[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<BuyOrder[]>;
        })
      );
  }

  protected processGetBuyOrders(
    response: HttpResponseBase
  ): Observable<BuyOrder[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(BuyOrder.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCompletedBuyOrders(
    branchId: number,
    beginCompletedTime: Date,
    endCompletedTime: Date,
    httpContext?: HttpContext
  ): Observable<BuyOrder[]> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/completed-buys?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (beginCompletedTime === undefined || beginCompletedTime === null)
      throw new Error(
        "The parameter 'beginCompletedTime' must be defined and cannot be null."
      );
    else
      url_ +=
        "beginCompletedTime=" +
        encodeURIComponent(
          beginCompletedTime ? "" + beginCompletedTime.toISOString() : ""
        ) +
        "&";
    if (endCompletedTime === undefined || endCompletedTime === null)
      throw new Error(
        "The parameter 'endCompletedTime' must be defined and cannot be null."
      );
    else
      url_ +=
        "endCompletedTime=" +
        encodeURIComponent(
          endCompletedTime ? "" + endCompletedTime.toISOString() : ""
        ) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCompletedBuyOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCompletedBuyOrders(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BuyOrder[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<BuyOrder[]>;
        })
      );
  }

  protected processGetCompletedBuyOrders(
    response: HttpResponseBase
  ): Observable<BuyOrder[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(BuyOrder.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSaleOrders(
    branchId: number,
    subMerchantIds?: string | null | undefined,
    currencyId?: number | null | undefined,
    isPhysicalCardOrder?: boolean | undefined,
    searchCriteria?: string | null | undefined,
    buyOrderStates?: string | null | undefined,
    beginTime?: Date | null | undefined,
    endTime?: Date | null | undefined,
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<BuyOrder[]> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/sales?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (subMerchantIds !== undefined && subMerchantIds !== null)
      url_ += "subMerchantIds=" + encodeURIComponent("" + subMerchantIds) + "&";
    if (currencyId !== undefined && currencyId !== null)
      url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
    if (isPhysicalCardOrder === null)
      throw new Error("The parameter 'isPhysicalCardOrder' cannot be null.");
    else if (isPhysicalCardOrder !== undefined)
      url_ +=
        "isPhysicalCardOrder=" +
        encodeURIComponent("" + isPhysicalCardOrder) +
        "&";
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    if (buyOrderStates !== undefined && buyOrderStates !== null)
      url_ += "buyOrderStates=" + encodeURIComponent("" + buyOrderStates) + "&";
    if (beginTime !== undefined && beginTime !== null)
      url_ +=
        "beginTime=" +
        encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") +
        "&";
    if (endTime !== undefined && endTime !== null)
      url_ +=
        "endTime=" +
        encodeURIComponent(endTime ? "" + endTime.toISOString() : "") +
        "&";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSaleOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSaleOrders(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BuyOrder[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<BuyOrder[]>;
        })
      );
  }

  protected processGetSaleOrders(
    response: HttpResponseBase
  ): Observable<BuyOrder[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(BuyOrder.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getBuy(
    branchId: number,
    orderId: number,
    httpContext?: HttpContext
  ): Observable<BuyOrder> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/buy/{orderId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBuy(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBuy(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BuyOrder>;
            }
          } else
            return _observableThrow(response_) as any as Observable<BuyOrder>;
        })
      );
  }

  protected processGetBuy(response: HttpResponseBase): Observable<BuyOrder> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyOrder.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getBuySummary(
    branchId: number,
    orderId: number,
    httpContext?: HttpContext
  ): Observable<BuyOrderSummary> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/buy-orders/buy-summary/{orderId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBuySummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBuySummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BuyOrderSummary>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<BuyOrderSummary>;
        })
      );
  }

  protected processGetBuySummary(
    response: HttpResponseBase
  ): Observable<BuyOrderSummary> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyOrderSummary.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSale(
    branchId: number,
    orderId: number,
    httpContext?: HttpContext
  ): Observable<BuyOrder> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/sale/{orderId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSale(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSale(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BuyOrder>;
            }
          } else
            return _observableThrow(response_) as any as Observable<BuyOrder>;
        })
      );
  }

  protected processGetSale(response: HttpResponseBase): Observable<BuyOrder> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BuyOrder.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getExchanges(
    branchId: number,
    merchantId: number,
    httpContext?: HttpContext
  ): Observable<ExchangeOrder[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/buy-orders/exchanges/{merchantId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (merchantId === undefined || merchantId === null)
      throw new Error("The parameter 'merchantId' must be defined.");
    url_ = url_.replace("{merchantId}", encodeURIComponent("" + merchantId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExchanges(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExchanges(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExchangeOrder[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ExchangeOrder[]
            >;
        })
      );
  }

  protected processGetExchanges(
    response: HttpResponseBase
  ): Observable<ExchangeOrder[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ExchangeOrder.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getExchangeCalc(
    branchId: number,
    merchantId: number,
    currencyId: number,
    amount: number,
    httpContext?: HttpContext
  ): Observable<ExchangeCalc> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/buy-orders/exchange-calculator?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (merchantId === undefined || merchantId === null)
      throw new Error(
        "The parameter 'merchantId' must be defined and cannot be null."
      );
    else url_ += "merchantId=" + encodeURIComponent("" + merchantId) + "&";
    if (currencyId === undefined || currencyId === null)
      throw new Error(
        "The parameter 'currencyId' must be defined and cannot be null."
      );
    else url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
    if (amount === undefined || amount === null)
      throw new Error(
        "The parameter 'amount' must be defined and cannot be null."
      );
    else url_ += "amount=" + encodeURIComponent("" + amount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExchangeCalc(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExchangeCalc(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExchangeCalc>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ExchangeCalc>;
        })
      );
  }

  protected processGetExchangeCalc(
    response: HttpResponseBase
  ): Observable<ExchangeCalc> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExchangeCalc.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getProductCodes(
    branchId: number,
    orderId: number,
    otpCode?: string | null | undefined,
    httpContext?: HttpContext
  ): Observable<ProductItemCode> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/product-codes?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (orderId === undefined || orderId === null)
      throw new Error(
        "The parameter 'orderId' must be defined and cannot be null."
      );
    else url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
    if (otpCode !== undefined && otpCode !== null)
      url_ += "otpCode=" + encodeURIComponent("" + otpCode) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProductCodes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProductCodes(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductItemCode>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ProductItemCode>;
        })
      );
  }

  protected processGetProductCodes(
    response: HttpResponseBase
  ): Observable<ProductItemCode> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductItemCode.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  resendProductCodes(
    branchId: number,
    orderId: number,
    deliveryType: BuyOrderDeliveryType,
    deliveryTypeValue?: string | null | undefined,
    otpCode?: string | null | undefined,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/buy-orders/{orderId}/resend-product-codes?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
    if (deliveryType === undefined || deliveryType === null)
      throw new Error(
        "The parameter 'deliveryType' must be defined and cannot be null."
      );
    else url_ += "deliveryType=" + encodeURIComponent("" + deliveryType) + "&";
    if (deliveryTypeValue !== undefined && deliveryTypeValue !== null)
      url_ +=
        "deliveryTypeValue=" + encodeURIComponent("" + deliveryTypeValue) + "&";
    if (otpCode !== undefined && otpCode !== null)
      url_ += "otpCode=" + encodeURIComponent("" + otpCode) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResendProductCodes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResendProductCodes(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processResendProductCodes(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getBuyOrderStateLogs(
    branchId: number,
    orderId: number,
    httpContext?: HttpContext
  ): Observable<BuyOrderStateLog[]> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/buy-orders/state-logs?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (orderId === undefined || orderId === null)
      throw new Error(
        "The parameter 'orderId' must be defined and cannot be null."
      );
    else url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBuyOrderStateLogs(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBuyOrderStateLogs(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                BuyOrderStateLog[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              BuyOrderStateLog[]
            >;
        })
      );
  }

  protected processGetBuyOrderStateLogs(
    response: HttpResponseBase
  ): Observable<BuyOrderStateLog[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(BuyOrderStateLog.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class CurrenciesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getCurrencies(httpContext?: HttpContext): Observable<Currency[]> {
    let url_ = this.baseUrl + "/api/v1/currencies";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrencies(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrencies(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Currency[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Currency[]>;
        })
      );
  }

  protected processGetCurrencies(
    response: HttpResponseBase
  ): Observable<Currency[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Currency.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getExchangeRates(
    httpContext?: HttpContext
  ): Observable<CurrencyExchangeRate[]> {
    let url_ = this.baseUrl + "/api/v1/currencies/currency-exchange-rates";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExchangeRates(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExchangeRates(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                CurrencyExchangeRate[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              CurrencyExchangeRate[]
            >;
        })
      );
  }

  protected processGetExchangeRates(
    response: HttpResponseBase
  ): Observable<CurrencyExchangeRate[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(CurrencyExchangeRate.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class DigitalDeliveriesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getProductItemCodes(
    buyOrderKey: string,
    shareCode?: string | null | undefined,
    httpContext?: HttpContext
  ): Observable<ProductItemCode> {
    let url_ =
      this.baseUrl +
      "/api/v1/buy-orders/{buyOrderKey}/digital-deliveries/product-item-codes?";
    if (buyOrderKey === undefined || buyOrderKey === null)
      throw new Error("The parameter 'buyOrderKey' must be defined.");
    url_ = url_.replace("{buyOrderKey}", encodeURIComponent("" + buyOrderKey));
    if (shareCode !== undefined && shareCode !== null)
      url_ += "shareCode=" + encodeURIComponent("" + shareCode) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProductItemCodes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProductItemCodes(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProductItemCode>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ProductItemCode>;
        })
      );
  }

  protected processGetProductItemCodes(
    response: HttpResponseBase
  ): Observable<ProductItemCode> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductItemCode.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class PhysicalCardsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  activate(
    branchId: number,
    request: PlaceActivatePhysicalCardOrderRequest,
    httpContext?: HttpContext
  ): Observable<number> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/physical-cards/activate";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processActivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processActivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else
            return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processActivate(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  checkActivation(
    branchId: number,
    serialNumber: string,
    httpContext?: HttpContext
  ): Observable<PhysicalCardActivation> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/physical-cards/check-activation?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (serialNumber === undefined || serialNumber === null)
      throw new Error(
        "The parameter 'serialNumber' must be defined and cannot be null."
      );
    else url_ += "serialNumber=" + encodeURIComponent("" + serialNumber) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckActivation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckActivation(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PhysicalCardActivation>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PhysicalCardActivation>;
        })
      );
  }

  protected processCheckActivation(
    response: HttpResponseBase
  ): Observable<PhysicalCardActivation> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PhysicalCardActivation.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class ProductsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getProductInvoice(
    branchId: number,
    productId: number,
    productPrice: number,
    httpContext?: HttpContext
  ): Observable<PriceInvoice> {
    let url_ =
      this.baseUrl +
      "/api/v1/branches/{branchId}/products/{productId}/pre-invoice?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    if (productPrice === undefined || productPrice === null)
      throw new Error(
        "The parameter 'productPrice' must be defined and cannot be null."
      );
    else url_ += "productPrice=" + encodeURIComponent("" + productPrice) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProductInvoice(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProductInvoice(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PriceInvoice>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PriceInvoice>;
        })
      );
  }

  protected processGetProductInvoice(
    response: HttpResponseBase
  ): Observable<PriceInvoice> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PriceInvoice.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getProducts(
    branchId: number,
    onlyDigitalCards?: boolean | undefined,
    regionId?: number | null | undefined,
    searchCriteria?: string | null | undefined,
    httpContext?: HttpContext
  ): Observable<CategoryProduct> {
    let url_ = this.baseUrl + "/api/v1/branches/{branchId}/products?";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (onlyDigitalCards === null)
      throw new Error("The parameter 'onlyDigitalCards' cannot be null.");
    else if (onlyDigitalCards !== undefined)
      url_ +=
        "onlyDigitalCards=" + encodeURIComponent("" + onlyDigitalCards) + "&";
    if (regionId !== undefined && regionId !== null)
      url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
    if (searchCriteria !== undefined && searchCriteria !== null)
      url_ += "searchCriteria=" + encodeURIComponent("" + searchCriteria) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProducts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProducts(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CategoryProduct>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<CategoryProduct>;
        })
      );
  }

  protected processGetProducts(
    response: HttpResponseBase
  ): Observable<CategoryProduct> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CategoryProduct.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(
    branchId: number,
    productId: number,
    httpContext?: HttpContext
  ): Observable<Product> {
    let url_ =
      this.baseUrl + "/api/v1/branches/{branchId}/products/{productId}";
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace("{branchId}", encodeURIComponent("" + branchId));
    if (productId === undefined || productId === null)
      throw new Error("The parameter 'productId' must be defined.");
    url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Product>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Product>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<Product> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Product.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class RegionsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getRegions(
    pageNumber?: number | null | undefined,
    pageSize?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<Region[]> {
    let url_ = this.baseUrl + "/api/v1/regions?";
    if (pageNumber !== undefined && pageNumber !== null)
      url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize !== undefined && pageSize !== null)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRegions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRegions(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Region[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Region[]>;
        })
      );
  }

  protected processGetRegions(
    response: HttpResponseBase
  ): Observable<Region[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(Region.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class SyncClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  clearDb(httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/clear-db";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processClearDb(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processClearDb(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processClearDb(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  putMerchant(
    request: PutMerchantRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/merchants";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutMerchant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutMerchant(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPutMerchant(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  putBranch(
    request: PutBranchRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/branches";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutBranch(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutBranch(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPutBranch(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  putCurrency(
    request: PutCurrencyRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/currencies";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutCurrency(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutCurrency(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPutCurrency(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  putCategory(
    request: PutCategoryRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/categories";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutCategory(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPutCategory(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  putProduct(
    request: PutProductRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/products";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPutProduct(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  putRegion(
    request: PutRegionRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/regions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutRegion(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutRegion(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPutRegion(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  putProductRegion(
    request: PutProductRegionRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/product-region";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutProductRegion(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutProductRegion(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPutProductRegion(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  putCurrencyExchangeRate(
    request: PutCurrencyExchangeRateRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/currency-exchange-rate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutCurrencyExchangeRate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutCurrencyExchangeRate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPutCurrencyExchangeRate(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  putUserPins(
    request: PutUserPinRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/user-pins";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutUserPins(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutUserPins(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPutUserPins(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  putMerchantCurrencyLimit(
    request: PutMerchantCurrencyLimitRequest,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/sync/merchant-currency-limit";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPutMerchantCurrencyLimit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPutMerchantCurrencyLimit(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPutMerchantCurrencyLimit(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteMerchantCurrencyLimit(
    merchantCurrencyLimitId: number,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/sync/merchant-currency-limit/{merchantCurrencyLimitId}";
    if (
      merchantCurrencyLimitId === undefined ||
      merchantCurrencyLimitId === null
    )
      throw new Error(
        "The parameter 'merchantCurrencyLimitId' must be defined."
      );
    url_ = url_.replace(
      "{merchantCurrencyLimitId}",
      encodeURIComponent("" + merchantCurrencyLimitId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteMerchantCurrencyLimit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteMerchantCurrencyLimit(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDeleteMerchantCurrencyLimit(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class TeamClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  listCurrentUserResources(httpContext?: HttpContext): Observable<string[]> {
    let url_ = this.baseUrl + "/api/v1/team/users/current/resources";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processListCurrentUserResources(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processListCurrentUserResources(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<string[]>;
        })
      );
  }

  protected processListCurrentUserResources(
    response: HttpResponseBase
  ): Observable<string[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(item);
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  listCurrentUserPermissions(
    resourceId: string,
    httpContext?: HttpContext
  ): Observable<string[]> {
    let url_ =
      this.baseUrl +
      "/api/v1/team/users/current/resources/{resourceId}/permissions";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processListCurrentUserPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processListCurrentUserPermissions(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<string[]>;
        })
      );
  }

  protected processListCurrentUserPermissions(
    response: HttpResponseBase
  ): Observable<string[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(item);
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  resetBotApiKey(
    userId: string,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/team/users/{userId}/bot/reset-api-key";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetBotApiKey(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetBotApiKey(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processResetBotApiKey(
    response: HttpResponseBase
  ): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateBot(
    userId: string,
    updateParam: TeamUpdateBotParam,
    httpContext?: HttpContext
  ): Observable<User> {
    let url_ = this.baseUrl + "/api/v1/team/users/{userId}/bot";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(updateParam);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("patch", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateBot(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateBot(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<User>;
            }
          } else return _observableThrow(response_) as any as Observable<User>;
        })
      );
  }

  protected processUpdateBot(response: HttpResponseBase): Observable<User> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = User.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  listRoles(resourceId: string, httpContext?: HttpContext): Observable<Role[]> {
    let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processListRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processListRoles(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Role[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<Role[]>;
        })
      );
  }

  protected processListRoles(response: HttpResponseBase): Observable<Role[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(Role.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  listUserRoles(
    resourceId: string,
    roleId?: string | null | undefined,
    userId?: string | null | undefined,
    search?: string | null | undefined,
    isBot?: boolean | null | undefined,
    recordIndex?: number | undefined,
    recordCount?: number | null | undefined,
    httpContext?: HttpContext
  ): Observable<ListResultOfUserRole> {
    let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/user-roles?";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (roleId !== undefined && roleId !== null)
      url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
    if (userId !== undefined && userId !== null)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    if (search !== undefined && search !== null)
      url_ += "search=" + encodeURIComponent("" + search) + "&";
    if (isBot !== undefined && isBot !== null)
      url_ += "isBot=" + encodeURIComponent("" + isBot) + "&";
    if (recordIndex === null)
      throw new Error("The parameter 'recordIndex' cannot be null.");
    else if (recordIndex !== undefined)
      url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
    if (recordCount !== undefined && recordCount !== null)
      url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processListUserRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processListUserRoles(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ListResultOfUserRole>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ListResultOfUserRole>;
        })
      );
  }

  protected processListUserRoles(
    response: HttpResponseBase
  ): Observable<ListResultOfUserRole> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListResultOfUserRole.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getUser(
    resourceId: string,
    userId: string,
    httpContext?: HttpContext
  ): Observable<TeamUserOfUserAndUserRoleAndRole> {
    let url_ =
      this.baseUrl + "/api/v1/team/resources/{resourceId}/users/{userId}";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUser(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<TeamUserOfUserAndUserRoleAndRole>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<TeamUserOfUserAndUserRoleAndRole>;
        })
      );
  }

  protected processGetUser(
    response: HttpResponseBase
  ): Observable<TeamUserOfUserAndUserRoleAndRole> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TeamUserOfUserAndUserRoleAndRole.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getUserByEmail(
    resourceId: string,
    email: string,
    httpContext?: HttpContext
  ): Observable<TeamUserOfUserAndUserRoleAndRole> {
    let url_ =
      this.baseUrl + "/api/v1/team/resources/{resourceId}/users/email:{email}";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (email === undefined || email === null)
      throw new Error("The parameter 'email' must be defined.");
    url_ = url_.replace("{email}", encodeURIComponent("" + email));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserByEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserByEmail(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<TeamUserOfUserAndUserRoleAndRole>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<TeamUserOfUserAndUserRoleAndRole>;
        })
      );
  }

  protected processGetUserByEmail(
    response: HttpResponseBase
  ): Observable<TeamUserOfUserAndUserRoleAndRole> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TeamUserOfUserAndUserRoleAndRole.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  addNewBot(
    resourceId: string,
    roleId: string,
    addParam: TeamAddBotParam,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ =
      this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/bots";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (roleId === undefined || roleId === null)
      throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(addParam);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddNewBot(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddNewBot(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processAddNewBot(response: HttpResponseBase): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  addUserByEmail(
    resourceId: string,
    roleId: string,
    email: string,
    addParam?: TeamAddEmailParam | undefined,
    httpContext?: HttpContext
  ): Observable<UserRole> {
    let url_ =
      this.baseUrl +
      "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/email:{email}";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (roleId === undefined || roleId === null)
      throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
    if (email === undefined || email === null)
      throw new Error("The parameter 'email' must be defined.");
    url_ = url_.replace("{email}", encodeURIComponent("" + email));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(addParam);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddUserByEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddUserByEmail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserRole>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserRole>;
        })
      );
  }

  protected processAddUserByEmail(
    response: HttpResponseBase
  ): Observable<UserRole> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserRole.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  addUser(
    resourceId: string,
    roleId: string,
    userId: string,
    httpContext?: HttpContext
  ): Observable<UserRole> {
    let url_ =
      this.baseUrl +
      "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (roleId === undefined || roleId === null)
      throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserRole>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserRole>;
        })
      );
  }

  protected processAddUser(response: HttpResponseBase): Observable<UserRole> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserRole.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  removeUser(
    resourceId: string,
    roleId: string,
    userId: string,
    httpContext?: HttpContext
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
    if (resourceId === undefined || resourceId === null)
      throw new Error("The parameter 'resourceId' must be defined.");
    url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
    if (roleId === undefined || roleId === null)
      throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRemoveUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createSystemApiKey(
    secret: string,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/team/system/api-key";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (secret === null || secret === undefined)
      throw new Error("The parameter 'secret' cannot be null.");
    else content_.append("secret", secret.toString());

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateSystemApiKey(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateSystemApiKey(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processCreateSystemApiKey(
    response: HttpResponseBase
  ): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AuthenticationClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  getCurrentUser(httpContext?: HttpContext): Observable<User> {
    let url_ = this.baseUrl + "/api/v1/authentication/current";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrentUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrentUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<User>;
            }
          } else return _observableThrow(response_) as any as Observable<User>;
        })
      );
  }

  protected processGetCurrentUser(
    response: HttpResponseBase
  ): Observable<User> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = User.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  signOutAll(httpContext?: HttpContext): Observable<void> {
    let url_ = this.baseUrl + "/api/v1/authentication/current/signout-all";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSignOutAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSignOutAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processSignOutAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  resetCurrentUserApiKey(httpContext?: HttpContext): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/authentication/current/reset-api-key";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetCurrentUserApiKey(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetCurrentUserApiKey(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processResetCurrentUserApiKey(
    response: HttpResponseBase
  ): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  signIn(
    request: SignInRequest,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/authentication/signin";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSignIn(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSignIn(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processSignIn(response: HttpResponseBase): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  signUp(
    request: SignUpRequest,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/authentication/signup";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSignUp(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSignUp(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processSignUp(response: HttpResponseBase): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  refreshToken(
    request: RefreshTokenRequest,
    httpContext?: HttpContext
  ): Observable<ApiKey> {
    let url_ = this.baseUrl + "/api/v1/authentication/refresh-token";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        Accept: "application/json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefreshToken(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefreshToken(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApiKey>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ApiKey>;
        })
      );
  }

  protected processRefreshToken(
    response: HttpResponseBase
  ): Observable<ApiKey> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiKey.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  googleSignInHandler(
    httpContext?: HttpContext
  ): Observable<FileResponse | null> {
    let url_ =
      this.baseUrl + "/api/v1/authentication/external/google/signin-handler";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/octet-stream",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGoogleSignInHandler(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGoogleSignInHandler(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<FileResponse | null>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<FileResponse | null>;
        })
      );
  }

  protected processGoogleSignInHandler(
    response: HttpResponseBase
  ): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getGoogleSignInUrl(
    csrfToken: string,
    nonce?: string | null | undefined,
    httpContext?: HttpContext
  ): Observable<string> {
    let url_ =
      this.baseUrl + "/api/v1/authentication/external/google/signin-url?";
    if (csrfToken === undefined || csrfToken === null)
      throw new Error(
        "The parameter 'csrfToken' must be defined and cannot be null."
      );
    else url_ += "csrfToken=" + encodeURIComponent("" + csrfToken) + "&";
    if (nonce !== undefined && nonce !== null)
      url_ += "nonce=" + encodeURIComponent("" + nonce) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      withCredentials: false,
      context: httpContext,
      headers: new HttpHeaders({
        Accept: "application/json",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetGoogleSignInUrl(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetGoogleSignInUrl(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string>;
            }
          } else
            return _observableThrow(response_) as any as Observable<string>;
        })
      );
  }

  protected processGetGoogleSignInUrl(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export class PlaceDigitalCardOrderRequest
  implements IPlaceDigitalCardOrderRequest
{
  productId!: number;
  productPrice!: number;
  quantity!: number;
  buyPrice!: number;
  deliveryType?: BuyOrderDeliveryType | null;
  deliveryTypeValue?: string | null;
  withExchange!: boolean;
  pin?: string | null;

  constructor(data?: IPlaceDigitalCardOrderRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.productPrice =
        _data["productPrice"] !== undefined ? _data["productPrice"] : <any>null;
      this.quantity =
        _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
      this.buyPrice =
        _data["buyPrice"] !== undefined ? _data["buyPrice"] : <any>null;
      this.deliveryType =
        _data["deliveryType"] !== undefined ? _data["deliveryType"] : <any>null;
      this.deliveryTypeValue =
        _data["deliveryTypeValue"] !== undefined
          ? _data["deliveryTypeValue"]
          : <any>null;
      this.withExchange =
        _data["withExchange"] !== undefined ? _data["withExchange"] : <any>null;
      this.pin = _data["pin"] !== undefined ? _data["pin"] : <any>null;
    }
  }

  static fromJS(data: any): PlaceDigitalCardOrderRequest {
    data = typeof data === "object" ? data : {};
    let result = new PlaceDigitalCardOrderRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["productPrice"] =
      this.productPrice !== undefined ? this.productPrice : <any>null;
    data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
    data["buyPrice"] = this.buyPrice !== undefined ? this.buyPrice : <any>null;
    data["deliveryType"] =
      this.deliveryType !== undefined ? this.deliveryType : <any>null;
    data["deliveryTypeValue"] =
      this.deliveryTypeValue !== undefined ? this.deliveryTypeValue : <any>null;
    data["withExchange"] =
      this.withExchange !== undefined ? this.withExchange : <any>null;
    data["pin"] = this.pin !== undefined ? this.pin : <any>null;
    return data;
  }
}

export interface IPlaceDigitalCardOrderRequest {
  productId: number;
  productPrice: number;
  quantity: number;
  buyPrice: number;
  deliveryType?: BuyOrderDeliveryType | null;
  deliveryTypeValue?: string | null;
  withExchange: boolean;
  pin?: string | null;
}

export enum BuyOrderDeliveryType {
  Email = "Email",
  Sms = "Sms",
  WhatsApp = "WhatsApp",
}

export class BuyOrder implements IBuyOrder {
  buyOrderId!: number;
  buyOrderExternalId!: string;
  productId!: number;
  productName!: string;
  isPhysicalProduct!: boolean;
  quantity!: number;
  faceValue!: number;
  buyOrderState!: BuyOrderState;
  sellerMerchant!: MerchantSummary;
  buyerMerchant!: MerchantSummary;
  buyOrderDelivery?: BuyOrderDelivery | null;
  saleManager?: SaleManagerSummary | null;
  totalBuyAmount!: number;
  unitBuyAmount!: number;
  profit?: number | null;
  productCurrency!: Currency;
  buyCurrency!: Currency;
  createdTime!: Date;
  canDownloadCodes!: boolean;
  exchangeCalc?: ExchangeCalc | null;
  createdByUserId!: string;

  constructor(data?: IBuyOrder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.sellerMerchant = new MerchantSummary();
      this.buyerMerchant = new MerchantSummary();
      this.productCurrency = new Currency();
      this.buyCurrency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.buyOrderId =
        _data["buyOrderId"] !== undefined ? _data["buyOrderId"] : <any>null;
      this.buyOrderExternalId =
        _data["buyOrderExternalId"] !== undefined
          ? _data["buyOrderExternalId"]
          : <any>null;
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.isPhysicalProduct =
        _data["isPhysicalProduct"] !== undefined
          ? _data["isPhysicalProduct"]
          : <any>null;
      this.quantity =
        _data["quantity"] !== undefined ? _data["quantity"] : <any>null;
      this.faceValue =
        _data["faceValue"] !== undefined ? _data["faceValue"] : <any>null;
      this.buyOrderState =
        _data["buyOrderState"] !== undefined
          ? _data["buyOrderState"]
          : <any>null;
      this.sellerMerchant = _data["sellerMerchant"]
        ? MerchantSummary.fromJS(_data["sellerMerchant"])
        : new MerchantSummary();
      this.buyerMerchant = _data["buyerMerchant"]
        ? MerchantSummary.fromJS(_data["buyerMerchant"])
        : new MerchantSummary();
      this.buyOrderDelivery = _data["buyOrderDelivery"]
        ? BuyOrderDelivery.fromJS(_data["buyOrderDelivery"])
        : <any>null;
      this.saleManager = _data["saleManager"]
        ? SaleManagerSummary.fromJS(_data["saleManager"])
        : <any>null;
      this.totalBuyAmount =
        _data["totalBuyAmount"] !== undefined
          ? _data["totalBuyAmount"]
          : <any>null;
      this.unitBuyAmount =
        _data["unitBuyAmount"] !== undefined
          ? _data["unitBuyAmount"]
          : <any>null;
      this.profit = _data["profit"] !== undefined ? _data["profit"] : <any>null;
      this.productCurrency = _data["productCurrency"]
        ? Currency.fromJS(_data["productCurrency"])
        : new Currency();
      this.buyCurrency = _data["buyCurrency"]
        ? Currency.fromJS(_data["buyCurrency"])
        : new Currency();
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.canDownloadCodes =
        _data["canDownloadCodes"] !== undefined
          ? _data["canDownloadCodes"]
          : <any>null;
      this.exchangeCalc = _data["exchangeCalc"]
        ? ExchangeCalc.fromJS(_data["exchangeCalc"])
        : <any>null;
      this.createdByUserId =
        _data["createdByUserId"] !== undefined
          ? _data["createdByUserId"]
          : <any>null;
    }
  }

  static fromJS(data: any): BuyOrder {
    data = typeof data === "object" ? data : {};
    let result = new BuyOrder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["buyOrderId"] =
      this.buyOrderId !== undefined ? this.buyOrderId : <any>null;
    data["buyOrderExternalId"] =
      this.buyOrderExternalId !== undefined
        ? this.buyOrderExternalId
        : <any>null;
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    data["isPhysicalProduct"] =
      this.isPhysicalProduct !== undefined ? this.isPhysicalProduct : <any>null;
    data["quantity"] = this.quantity !== undefined ? this.quantity : <any>null;
    data["faceValue"] =
      this.faceValue !== undefined ? this.faceValue : <any>null;
    data["buyOrderState"] =
      this.buyOrderState !== undefined ? this.buyOrderState : <any>null;
    data["sellerMerchant"] = this.sellerMerchant
      ? this.sellerMerchant.toJSON()
      : <any>null;
    data["buyerMerchant"] = this.buyerMerchant
      ? this.buyerMerchant.toJSON()
      : <any>null;
    data["buyOrderDelivery"] = this.buyOrderDelivery
      ? this.buyOrderDelivery.toJSON()
      : <any>null;
    data["saleManager"] = this.saleManager
      ? this.saleManager.toJSON()
      : <any>null;
    data["totalBuyAmount"] =
      this.totalBuyAmount !== undefined ? this.totalBuyAmount : <any>null;
    data["unitBuyAmount"] =
      this.unitBuyAmount !== undefined ? this.unitBuyAmount : <any>null;
    data["profit"] = this.profit !== undefined ? this.profit : <any>null;
    data["productCurrency"] = this.productCurrency
      ? this.productCurrency.toJSON()
      : <any>null;
    data["buyCurrency"] = this.buyCurrency
      ? this.buyCurrency.toJSON()
      : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["canDownloadCodes"] =
      this.canDownloadCodes !== undefined ? this.canDownloadCodes : <any>null;
    data["exchangeCalc"] = this.exchangeCalc
      ? this.exchangeCalc.toJSON()
      : <any>null;
    data["createdByUserId"] =
      this.createdByUserId !== undefined ? this.createdByUserId : <any>null;
    return data;
  }
}

export interface IBuyOrder {
  buyOrderId: number;
  buyOrderExternalId: string;
  productId: number;
  productName: string;
  isPhysicalProduct: boolean;
  quantity: number;
  faceValue: number;
  buyOrderState: BuyOrderState;
  sellerMerchant: MerchantSummary;
  buyerMerchant: MerchantSummary;
  buyOrderDelivery?: BuyOrderDelivery | null;
  saleManager?: SaleManagerSummary | null;
  totalBuyAmount: number;
  unitBuyAmount: number;
  profit?: number | null;
  productCurrency: Currency;
  buyCurrency: Currency;
  createdTime: Date;
  canDownloadCodes: boolean;
  exchangeCalc?: ExchangeCalc | null;
  createdByUserId: string;
}

export enum BuyOrderState {
  Reserved = "Reserved",
  Created = "Created",
  CreateStockOrder = "CreateStockOrder",
  AuthWallet = "AuthWallet",
  Failed = "Failed",
  Complete = "Complete",
  CancelAuthWallet = "CancelAuthWallet",
  CompleteStockOrder = "CompleteStockOrder",
  CreateActivatePhysicalCardOrder = "CreateActivatePhysicalCardOrder",
  CompleteActivatePhysicalCardOrder = "CompleteActivatePhysicalCardOrder",
}

export class MerchantSummary implements IMerchantSummary {
  merchantId!: number;
  merchantName!: string;
  saleManager?: SaleManagerSummary | null;

  constructor(data?: IMerchantSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.merchantName =
        _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
      this.saleManager = _data["saleManager"]
        ? SaleManagerSummary.fromJS(_data["saleManager"])
        : <any>null;
    }
  }

  static fromJS(data: any): MerchantSummary {
    data = typeof data === "object" ? data : {};
    let result = new MerchantSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["merchantName"] =
      this.merchantName !== undefined ? this.merchantName : <any>null;
    data["saleManager"] = this.saleManager
      ? this.saleManager.toJSON()
      : <any>null;
    return data;
  }
}

export interface IMerchantSummary {
  merchantId: number;
  merchantName: string;
  saleManager?: SaleManagerSummary | null;
}

export class SaleManagerSummary implements ISaleManagerSummary {
  saleManagerId!: number;
  name?: string | null;

  constructor(data?: ISaleManagerSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.saleManagerId =
        _data["saleManagerId"] !== undefined
          ? _data["saleManagerId"]
          : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
    }
  }

  static fromJS(data: any): SaleManagerSummary {
    data = typeof data === "object" ? data : {};
    let result = new SaleManagerSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["saleManagerId"] =
      this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    return data;
  }
}

export interface ISaleManagerSummary {
  saleManagerId: number;
  name?: string | null;
}

export class BuyOrderDelivery implements IBuyOrderDelivery {
  deliveryType!: BuyOrderDeliveryType;
  deliveryTypeValue?: string | null;
  deliveredTime?: Date | null;

  constructor(data?: IBuyOrderDelivery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.deliveryType =
        _data["deliveryType"] !== undefined ? _data["deliveryType"] : <any>null;
      this.deliveryTypeValue =
        _data["deliveryTypeValue"] !== undefined
          ? _data["deliveryTypeValue"]
          : <any>null;
      this.deliveredTime = _data["deliveredTime"]
        ? new Date(_data["deliveredTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): BuyOrderDelivery {
    data = typeof data === "object" ? data : {};
    let result = new BuyOrderDelivery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["deliveryType"] =
      this.deliveryType !== undefined ? this.deliveryType : <any>null;
    data["deliveryTypeValue"] =
      this.deliveryTypeValue !== undefined ? this.deliveryTypeValue : <any>null;
    data["deliveredTime"] = this.deliveredTime
      ? this.deliveredTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IBuyOrderDelivery {
  deliveryType: BuyOrderDeliveryType;
  deliveryTypeValue?: string | null;
  deliveredTime?: Date | null;
}

export class Currency implements ICurrency {
  currencyId!: number;
  currencyName!: string;
  symbol?: string | null;
  isForTest?: boolean | null;

  constructor(data?: ICurrency) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.currencyName =
        _data["currencyName"] !== undefined ? _data["currencyName"] : <any>null;
      this.symbol = _data["symbol"] !== undefined ? _data["symbol"] : <any>null;
      this.isForTest =
        _data["isForTest"] !== undefined ? _data["isForTest"] : <any>null;
    }
  }

  static fromJS(data: any): Currency {
    data = typeof data === "object" ? data : {};
    let result = new Currency();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["currencyName"] =
      this.currencyName !== undefined ? this.currencyName : <any>null;
    data["symbol"] = this.symbol !== undefined ? this.symbol : <any>null;
    data["isForTest"] =
      this.isForTest !== undefined ? this.isForTest : <any>null;
    return data;
  }
}

export interface ICurrency {
  currencyId: number;
  currencyName: string;
  symbol?: string | null;
  isForTest?: boolean | null;
}

export class ExchangeCalc implements IExchangeCalc {
  baseCurrency!: Currency;
  baseAmount!: number;
  targetCurrency!: Currency;
  targetAmount!: number;
  exchangeRate!: number;

  constructor(data?: IExchangeCalc) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.baseCurrency = new Currency();
      this.targetCurrency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.baseCurrency = _data["baseCurrency"]
        ? Currency.fromJS(_data["baseCurrency"])
        : new Currency();
      this.baseAmount =
        _data["baseAmount"] !== undefined ? _data["baseAmount"] : <any>null;
      this.targetCurrency = _data["targetCurrency"]
        ? Currency.fromJS(_data["targetCurrency"])
        : new Currency();
      this.targetAmount =
        _data["targetAmount"] !== undefined ? _data["targetAmount"] : <any>null;
      this.exchangeRate =
        _data["exchangeRate"] !== undefined ? _data["exchangeRate"] : <any>null;
    }
  }

  static fromJS(data: any): ExchangeCalc {
    data = typeof data === "object" ? data : {};
    let result = new ExchangeCalc();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["baseCurrency"] = this.baseCurrency
      ? this.baseCurrency.toJSON()
      : <any>null;
    data["baseAmount"] =
      this.baseAmount !== undefined ? this.baseAmount : <any>null;
    data["targetCurrency"] = this.targetCurrency
      ? this.targetCurrency.toJSON()
      : <any>null;
    data["targetAmount"] =
      this.targetAmount !== undefined ? this.targetAmount : <any>null;
    data["exchangeRate"] =
      this.exchangeRate !== undefined ? this.exchangeRate : <any>null;
    return data;
  }
}

export interface IExchangeCalc {
  baseCurrency: Currency;
  baseAmount: number;
  targetCurrency: Currency;
  targetAmount: number;
  exchangeRate: number;
}

export class BuyOrderSummary implements IBuyOrderSummary {
  buyOrderId!: number;
  merchantId!: number;
  buyOrderExternalId!: string;
  buyOrderState!: BuyOrderState;

  constructor(data?: IBuyOrderSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.buyOrderId =
        _data["buyOrderId"] !== undefined ? _data["buyOrderId"] : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.buyOrderExternalId =
        _data["buyOrderExternalId"] !== undefined
          ? _data["buyOrderExternalId"]
          : <any>null;
      this.buyOrderState =
        _data["buyOrderState"] !== undefined
          ? _data["buyOrderState"]
          : <any>null;
    }
  }

  static fromJS(data: any): BuyOrderSummary {
    data = typeof data === "object" ? data : {};
    let result = new BuyOrderSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["buyOrderId"] =
      this.buyOrderId !== undefined ? this.buyOrderId : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["buyOrderExternalId"] =
      this.buyOrderExternalId !== undefined
        ? this.buyOrderExternalId
        : <any>null;
    data["buyOrderState"] =
      this.buyOrderState !== undefined ? this.buyOrderState : <any>null;
    return data;
  }
}

export interface IBuyOrderSummary {
  buyOrderId: number;
  merchantId: number;
  buyOrderExternalId: string;
  buyOrderState: BuyOrderState;
}

export class ExchangeOrder implements IExchangeOrder {
  exchangeId!: number;
  buyOrderId!: number;
  baseCurrency!: Currency;
  baseAmount!: number;
  targetCurrency!: Currency;
  targetAmount!: number;
  createdTime!: Date;

  constructor(data?: IExchangeOrder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.baseCurrency = new Currency();
      this.targetCurrency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.exchangeId =
        _data["exchangeId"] !== undefined ? _data["exchangeId"] : <any>null;
      this.buyOrderId =
        _data["buyOrderId"] !== undefined ? _data["buyOrderId"] : <any>null;
      this.baseCurrency = _data["baseCurrency"]
        ? Currency.fromJS(_data["baseCurrency"])
        : new Currency();
      this.baseAmount =
        _data["baseAmount"] !== undefined ? _data["baseAmount"] : <any>null;
      this.targetCurrency = _data["targetCurrency"]
        ? Currency.fromJS(_data["targetCurrency"])
        : new Currency();
      this.targetAmount =
        _data["targetAmount"] !== undefined ? _data["targetAmount"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): ExchangeOrder {
    data = typeof data === "object" ? data : {};
    let result = new ExchangeOrder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["exchangeId"] =
      this.exchangeId !== undefined ? this.exchangeId : <any>null;
    data["buyOrderId"] =
      this.buyOrderId !== undefined ? this.buyOrderId : <any>null;
    data["baseCurrency"] = this.baseCurrency
      ? this.baseCurrency.toJSON()
      : <any>null;
    data["baseAmount"] =
      this.baseAmount !== undefined ? this.baseAmount : <any>null;
    data["targetCurrency"] = this.targetCurrency
      ? this.targetCurrency.toJSON()
      : <any>null;
    data["targetAmount"] =
      this.targetAmount !== undefined ? this.targetAmount : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IExchangeOrder {
  exchangeId: number;
  buyOrderId: number;
  baseCurrency: Currency;
  baseAmount: number;
  targetCurrency: Currency;
  targetAmount: number;
  createdTime: Date;
}

export class ProductItemCode implements IProductItemCode {
  productId!: number;
  productName!: string;
  imageUrl?: string | null;
  description?: string | null;
  productPrice!: number;
  currency!: Currency;
  codes!: ProductCodeSummary[];

  constructor(data?: IProductItemCode) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
      this.codes = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.productPrice =
        _data["productPrice"] !== undefined ? _data["productPrice"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      if (Array.isArray(_data["codes"])) {
        this.codes = [] as any;
        for (let item of _data["codes"])
          this.codes!.push(ProductCodeSummary.fromJS(item));
      } else {
        this.codes = <any>null;
      }
    }
  }

  static fromJS(data: any): ProductItemCode {
    data = typeof data === "object" ? data : {};
    let result = new ProductItemCode();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["productPrice"] =
      this.productPrice !== undefined ? this.productPrice : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    if (Array.isArray(this.codes)) {
      data["codes"] = [];
      for (let item of this.codes) data["codes"].push(item.toJSON());
    }
    return data;
  }
}

export interface IProductItemCode {
  productId: number;
  productName: string;
  imageUrl?: string | null;
  description?: string | null;
  productPrice: number;
  currency: Currency;
  codes: ProductCodeSummary[];
}

export class ProductCodeSummary implements IProductCodeSummary {
  cardNumber!: string;
  shareCode?: string | null;
  pin?: string | null;
  expirationTime?: Date | null;

  constructor(data?: IProductCodeSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cardNumber =
        _data["cardNumber"] !== undefined ? _data["cardNumber"] : <any>null;
      this.shareCode =
        _data["shareCode"] !== undefined ? _data["shareCode"] : <any>null;
      this.pin = _data["pin"] !== undefined ? _data["pin"] : <any>null;
      this.expirationTime = _data["expirationTime"]
        ? new Date(_data["expirationTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): ProductCodeSummary {
    data = typeof data === "object" ? data : {};
    let result = new ProductCodeSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["cardNumber"] =
      this.cardNumber !== undefined ? this.cardNumber : <any>null;
    data["shareCode"] =
      this.shareCode !== undefined ? this.shareCode : <any>null;
    data["pin"] = this.pin !== undefined ? this.pin : <any>null;
    data["expirationTime"] = this.expirationTime
      ? formatDate(this.expirationTime)
      : <any>null;
    return data;
  }
}

export interface IProductCodeSummary {
  cardNumber: string;
  shareCode?: string | null;
  pin?: string | null;
  expirationTime?: Date | null;
}

export class BuyOrderStateLog implements IBuyOrderStateLog {
  state!: BuyOrderState;
  reason?: string | null;
  createdTime!: Date;

  constructor(data?: IBuyOrderStateLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.state = _data["state"] !== undefined ? _data["state"] : <any>null;
      this.reason = _data["reason"] !== undefined ? _data["reason"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): BuyOrderStateLog {
    data = typeof data === "object" ? data : {};
    let result = new BuyOrderStateLog();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["state"] = this.state !== undefined ? this.state : <any>null;
    data["reason"] = this.reason !== undefined ? this.reason : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IBuyOrderStateLog {
  state: BuyOrderState;
  reason?: string | null;
  createdTime: Date;
}

export class CurrencyExchangeRate implements ICurrencyExchangeRate {
  baseCurrency!: Currency;
  targetCurrency!: Currency;
  exchangeRate!: number;
  exchangeRateFee!: number;
  exchangeRateUpdateTime?: Date | null;

  constructor(data?: ICurrencyExchangeRate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.baseCurrency = new Currency();
      this.targetCurrency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.baseCurrency = _data["baseCurrency"]
        ? Currency.fromJS(_data["baseCurrency"])
        : new Currency();
      this.targetCurrency = _data["targetCurrency"]
        ? Currency.fromJS(_data["targetCurrency"])
        : new Currency();
      this.exchangeRate =
        _data["exchangeRate"] !== undefined ? _data["exchangeRate"] : <any>null;
      this.exchangeRateFee =
        _data["exchangeRateFee"] !== undefined
          ? _data["exchangeRateFee"]
          : <any>null;
      this.exchangeRateUpdateTime = _data["exchangeRateUpdateTime"]
        ? new Date(_data["exchangeRateUpdateTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): CurrencyExchangeRate {
    data = typeof data === "object" ? data : {};
    let result = new CurrencyExchangeRate();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["baseCurrency"] = this.baseCurrency
      ? this.baseCurrency.toJSON()
      : <any>null;
    data["targetCurrency"] = this.targetCurrency
      ? this.targetCurrency.toJSON()
      : <any>null;
    data["exchangeRate"] =
      this.exchangeRate !== undefined ? this.exchangeRate : <any>null;
    data["exchangeRateFee"] =
      this.exchangeRateFee !== undefined ? this.exchangeRateFee : <any>null;
    data["exchangeRateUpdateTime"] = this.exchangeRateUpdateTime
      ? this.exchangeRateUpdateTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface ICurrencyExchangeRate {
  baseCurrency: Currency;
  targetCurrency: Currency;
  exchangeRate: number;
  exchangeRateFee: number;
  exchangeRateUpdateTime?: Date | null;
}

export class PlaceActivatePhysicalCardOrderRequest
  implements IPlaceActivatePhysicalCardOrderRequest
{
  serialNumber!: string;
  productPrice!: number;
  withExchange!: boolean;
  buyPrice!: number;
  pin?: string | null;

  constructor(data?: IPlaceActivatePhysicalCardOrderRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.serialNumber =
        _data["serialNumber"] !== undefined ? _data["serialNumber"] : <any>null;
      this.productPrice =
        _data["productPrice"] !== undefined ? _data["productPrice"] : <any>null;
      this.withExchange =
        _data["withExchange"] !== undefined ? _data["withExchange"] : <any>null;
      this.buyPrice =
        _data["buyPrice"] !== undefined ? _data["buyPrice"] : <any>null;
      this.pin = _data["pin"] !== undefined ? _data["pin"] : <any>null;
    }
  }

  static fromJS(data: any): PlaceActivatePhysicalCardOrderRequest {
    data = typeof data === "object" ? data : {};
    let result = new PlaceActivatePhysicalCardOrderRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["serialNumber"] =
      this.serialNumber !== undefined ? this.serialNumber : <any>null;
    data["productPrice"] =
      this.productPrice !== undefined ? this.productPrice : <any>null;
    data["withExchange"] =
      this.withExchange !== undefined ? this.withExchange : <any>null;
    data["buyPrice"] = this.buyPrice !== undefined ? this.buyPrice : <any>null;
    data["pin"] = this.pin !== undefined ? this.pin : <any>null;
    return data;
  }
}

export interface IPlaceActivatePhysicalCardOrderRequest {
  serialNumber: string;
  productPrice: number;
  withExchange: boolean;
  buyPrice: number;
  pin?: string | null;
}

export class PhysicalCardActivation implements IPhysicalCardActivation {
  product!: ProductSummary;
  status!: PhysicalCardActivationStatus;

  constructor(data?: IPhysicalCardActivation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.product = new ProductSummary();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.product = _data["product"]
        ? ProductSummary.fromJS(_data["product"])
        : new ProductSummary();
      this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
    }
  }

  static fromJS(data: any): PhysicalCardActivation {
    data = typeof data === "object" ? data : {};
    let result = new PhysicalCardActivation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["product"] = this.product ? this.product.toJSON() : <any>null;
    data["status"] = this.status !== undefined ? this.status : <any>null;
    return data;
  }
}

export interface IPhysicalCardActivation {
  product: ProductSummary;
  status: PhysicalCardActivationStatus;
}

export class ProductSummary implements IProductSummary {
  productId!: number;
  productName!: string;
  imageUrl?: string | null;
  providerSku!: string;
  upc?: string | null;
  isPhysical!: boolean;
  hasDescription!: boolean;
  category!: CategorySummary;
  currency!: Currency;

  constructor(data?: IProductSummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.category = new CategorySummary();
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.providerSku =
        _data["providerSku"] !== undefined ? _data["providerSku"] : <any>null;
      this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
      this.isPhysical =
        _data["isPhysical"] !== undefined ? _data["isPhysical"] : <any>null;
      this.hasDescription =
        _data["hasDescription"] !== undefined
          ? _data["hasDescription"]
          : <any>null;
      this.category = _data["category"]
        ? CategorySummary.fromJS(_data["category"])
        : new CategorySummary();
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
    }
  }

  static fromJS(data: any): ProductSummary {
    data = typeof data === "object" ? data : {};
    let result = new ProductSummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["providerSku"] =
      this.providerSku !== undefined ? this.providerSku : <any>null;
    data["upc"] = this.upc !== undefined ? this.upc : <any>null;
    data["isPhysical"] =
      this.isPhysical !== undefined ? this.isPhysical : <any>null;
    data["hasDescription"] =
      this.hasDescription !== undefined ? this.hasDescription : <any>null;
    data["category"] = this.category ? this.category.toJSON() : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    return data;
  }
}

export interface IProductSummary {
  productId: number;
  productName: string;
  imageUrl?: string | null;
  providerSku: string;
  upc?: string | null;
  isPhysical: boolean;
  hasDescription: boolean;
  category: CategorySummary;
  currency: Currency;
}

export class CategorySummary implements ICategorySummary {
  categoryId!: number;
  categoryName!: string;

  constructor(data?: ICategorySummary) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryId =
        _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
      this.categoryName =
        _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
    }
  }

  static fromJS(data: any): CategorySummary {
    data = typeof data === "object" ? data : {};
    let result = new CategorySummary();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["categoryId"] =
      this.categoryId !== undefined ? this.categoryId : <any>null;
    data["categoryName"] =
      this.categoryName !== undefined ? this.categoryName : <any>null;
    return data;
  }
}

export interface ICategorySummary {
  categoryId: number;
  categoryName: string;
}

export enum PhysicalCardActivationStatus {
  ReadyToActivate = "ReadyToActivate",
  Activated = "Activated",
  FailedToActivate = "FailedToActivate",
  InProgress = "InProgress",
}

export class PriceInvoice implements IPriceInvoice {
  merchantId!: number;
  branchId!: number;
  priceListId!: number;
  buyAmount!: number;
  benefit!: number;
  consumerTax!: number;
  consumerFee!: number;
  sellAmount!: number;
  errors!: PriceRuleError[];

  constructor(data?: IPriceInvoice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.errors = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.priceListId =
        _data["priceListId"] !== undefined ? _data["priceListId"] : <any>null;
      this.buyAmount =
        _data["buyAmount"] !== undefined ? _data["buyAmount"] : <any>null;
      this.benefit =
        _data["benefit"] !== undefined ? _data["benefit"] : <any>null;
      this.consumerTax =
        _data["consumerTax"] !== undefined ? _data["consumerTax"] : <any>null;
      this.consumerFee =
        _data["consumerFee"] !== undefined ? _data["consumerFee"] : <any>null;
      this.sellAmount =
        _data["sellAmount"] !== undefined ? _data["sellAmount"] : <any>null;
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"])
          this.errors!.push(PriceRuleError.fromJS(item));
      } else {
        this.errors = <any>null;
      }
    }
  }

  static fromJS(data: any): PriceInvoice {
    data = typeof data === "object" ? data : {};
    let result = new PriceInvoice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["priceListId"] =
      this.priceListId !== undefined ? this.priceListId : <any>null;
    data["buyAmount"] =
      this.buyAmount !== undefined ? this.buyAmount : <any>null;
    data["benefit"] = this.benefit !== undefined ? this.benefit : <any>null;
    data["consumerTax"] =
      this.consumerTax !== undefined ? this.consumerTax : <any>null;
    data["consumerFee"] =
      this.consumerFee !== undefined ? this.consumerFee : <any>null;
    data["sellAmount"] =
      this.sellAmount !== undefined ? this.sellAmount : <any>null;
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPriceInvoice {
  merchantId: number;
  branchId: number;
  priceListId: number;
  buyAmount: number;
  benefit: number;
  consumerTax: number;
  consumerFee: number;
  sellAmount: number;
  errors: PriceRuleError[];
}

export class PriceRuleError implements IPriceRuleError {
  propertyName!: string;
  message!: string;
  errorCode!: ErrorCode;

  constructor(data?: IPriceRuleError) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyName =
        _data["propertyName"] !== undefined ? _data["propertyName"] : <any>null;
      this.message =
        _data["message"] !== undefined ? _data["message"] : <any>null;
      this.errorCode =
        _data["errorCode"] !== undefined ? _data["errorCode"] : <any>null;
    }
  }

  static fromJS(data: any): PriceRuleError {
    data = typeof data === "object" ? data : {};
    let result = new PriceRuleError();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["propertyName"] =
      this.propertyName !== undefined ? this.propertyName : <any>null;
    data["message"] = this.message !== undefined ? this.message : <any>null;
    data["errorCode"] =
      this.errorCode !== undefined ? this.errorCode : <any>null;
    return data;
  }
}

export interface IPriceRuleError {
  propertyName: string;
  message: string;
  errorCode: ErrorCode;
}

export enum ErrorCode {
  General = "General",
  ProductNotFound = "ProductNotFound",
}

export class CategoryProduct implements ICategoryProduct {
  categoryId!: number;
  categoryName!: string;
  imageUrl?: string | null;
  parentCategoryId?: number | null;
  categories?: CategoryProduct[] | null;
  productBuyPrices!: ProductBuyPrice[];

  constructor(data?: ICategoryProduct) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.productBuyPrices = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryId =
        _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
      this.categoryName =
        _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.parentCategoryId =
        _data["parentCategoryId"] !== undefined
          ? _data["parentCategoryId"]
          : <any>null;
      if (Array.isArray(_data["categories"])) {
        this.categories = [] as any;
        for (let item of _data["categories"])
          this.categories!.push(CategoryProduct.fromJS(item));
      } else {
        this.categories = <any>null;
      }
      if (Array.isArray(_data["productBuyPrices"])) {
        this.productBuyPrices = [] as any;
        for (let item of _data["productBuyPrices"])
          this.productBuyPrices!.push(ProductBuyPrice.fromJS(item));
      } else {
        this.productBuyPrices = <any>null;
      }
    }
  }

  static fromJS(data: any): CategoryProduct {
    data = typeof data === "object" ? data : {};
    let result = new CategoryProduct();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["categoryId"] =
      this.categoryId !== undefined ? this.categoryId : <any>null;
    data["categoryName"] =
      this.categoryName !== undefined ? this.categoryName : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["parentCategoryId"] =
      this.parentCategoryId !== undefined ? this.parentCategoryId : <any>null;
    if (Array.isArray(this.categories)) {
      data["categories"] = [];
      for (let item of this.categories) data["categories"].push(item.toJSON());
    }
    if (Array.isArray(this.productBuyPrices)) {
      data["productBuyPrices"] = [];
      for (let item of this.productBuyPrices)
        data["productBuyPrices"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICategoryProduct {
  categoryId: number;
  categoryName: string;
  imageUrl?: string | null;
  parentCategoryId?: number | null;
  categories?: CategoryProduct[] | null;
  productBuyPrices: ProductBuyPrice[];
}

export class ProductBuyPrice implements IProductBuyPrice {
  productId!: number;
  upc?: string | null;
  categoryId?: number | null;
  productName!: string;
  imageUrl?: string | null;
  hasDescription!: boolean;
  currency!: Currency;
  faceValues?: PriceRangeDto[] | null;

  constructor(data?: IProductBuyPrice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
      this.categoryId =
        _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.hasDescription =
        _data["hasDescription"] !== undefined
          ? _data["hasDescription"]
          : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
      if (Array.isArray(_data["faceValues"])) {
        this.faceValues = [] as any;
        for (let item of _data["faceValues"])
          this.faceValues!.push(PriceRangeDto.fromJS(item));
      } else {
        this.faceValues = <any>null;
      }
    }
  }

  static fromJS(data: any): ProductBuyPrice {
    data = typeof data === "object" ? data : {};
    let result = new ProductBuyPrice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["upc"] = this.upc !== undefined ? this.upc : <any>null;
    data["categoryId"] =
      this.categoryId !== undefined ? this.categoryId : <any>null;
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["hasDescription"] =
      this.hasDescription !== undefined ? this.hasDescription : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    if (Array.isArray(this.faceValues)) {
      data["faceValues"] = [];
      for (let item of this.faceValues) data["faceValues"].push(item.toJSON());
    }
    return data;
  }
}

export interface IProductBuyPrice {
  productId: number;
  upc?: string | null;
  categoryId?: number | null;
  productName: string;
  imageUrl?: string | null;
  hasDescription: boolean;
  currency: Currency;
  faceValues?: PriceRangeDto[] | null;
}

export class PriceRangeDto implements IPriceRangeDto {
  start!: number;
  end?: number | null;
  endValue!: number;
  isEndless!: boolean;
  faceValue!: number;
  consumerFee!: number;
  consumerTax!: number;

  constructor(data?: IPriceRangeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.start = _data["start"] !== undefined ? _data["start"] : <any>null;
      this.end = _data["end"] !== undefined ? _data["end"] : <any>null;
      this.endValue =
        _data["endValue"] !== undefined ? _data["endValue"] : <any>null;
      this.isEndless =
        _data["isEndless"] !== undefined ? _data["isEndless"] : <any>null;
      this.faceValue =
        _data["faceValue"] !== undefined ? _data["faceValue"] : <any>null;
      this.consumerFee =
        _data["consumerFee"] !== undefined ? _data["consumerFee"] : <any>null;
      this.consumerTax =
        _data["consumerTax"] !== undefined ? _data["consumerTax"] : <any>null;
    }
  }

  static fromJS(data: any): PriceRangeDto {
    data = typeof data === "object" ? data : {};
    let result = new PriceRangeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["start"] = this.start !== undefined ? this.start : <any>null;
    data["end"] = this.end !== undefined ? this.end : <any>null;
    data["endValue"] = this.endValue !== undefined ? this.endValue : <any>null;
    data["isEndless"] =
      this.isEndless !== undefined ? this.isEndless : <any>null;
    data["faceValue"] =
      this.faceValue !== undefined ? this.faceValue : <any>null;
    data["consumerFee"] =
      this.consumerFee !== undefined ? this.consumerFee : <any>null;
    data["consumerTax"] =
      this.consumerTax !== undefined ? this.consumerTax : <any>null;
    return data;
  }
}

export interface IPriceRangeDto {
  start: number;
  end?: number | null;
  endValue: number;
  isEndless: boolean;
  faceValue: number;
  consumerFee: number;
  consumerTax: number;
}

export class Product implements IProduct {
  productId!: number;
  productName!: string;
  regions?: Region[] | null;
  providerSku!: string;
  canPreOrder?: boolean | null;
  canImmediate?: boolean | null;
  isActive?: boolean | null;
  upc?: string | null;
  isPhysical!: boolean;
  description?: string | null;
  categoryId!: number;
  imageUrl?: string | null;
  currency!: Currency;

  constructor(data?: IProduct) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.currency = new Currency();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      if (Array.isArray(_data["regions"])) {
        this.regions = [] as any;
        for (let item of _data["regions"])
          this.regions!.push(Region.fromJS(item));
      } else {
        this.regions = <any>null;
      }
      this.providerSku =
        _data["providerSku"] !== undefined ? _data["providerSku"] : <any>null;
      this.canPreOrder =
        _data["canPreOrder"] !== undefined ? _data["canPreOrder"] : <any>null;
      this.canImmediate =
        _data["canImmediate"] !== undefined ? _data["canImmediate"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
      this.isPhysical =
        _data["isPhysical"] !== undefined ? _data["isPhysical"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.categoryId =
        _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.currency = _data["currency"]
        ? Currency.fromJS(_data["currency"])
        : new Currency();
    }
  }

  static fromJS(data: any): Product {
    data = typeof data === "object" ? data : {};
    let result = new Product();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    if (Array.isArray(this.regions)) {
      data["regions"] = [];
      for (let item of this.regions) data["regions"].push(item.toJSON());
    }
    data["providerSku"] =
      this.providerSku !== undefined ? this.providerSku : <any>null;
    data["canPreOrder"] =
      this.canPreOrder !== undefined ? this.canPreOrder : <any>null;
    data["canImmediate"] =
      this.canImmediate !== undefined ? this.canImmediate : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["upc"] = this.upc !== undefined ? this.upc : <any>null;
    data["isPhysical"] =
      this.isPhysical !== undefined ? this.isPhysical : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["categoryId"] =
      this.categoryId !== undefined ? this.categoryId : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>null;
    return data;
  }
}

export interface IProduct {
  productId: number;
  productName: string;
  regions?: Region[] | null;
  providerSku: string;
  canPreOrder?: boolean | null;
  canImmediate?: boolean | null;
  isActive?: boolean | null;
  upc?: string | null;
  isPhysical: boolean;
  description?: string | null;
  categoryId: number;
  imageUrl?: string | null;
  currency: Currency;
}

export class Region implements IRegion {
  regionId!: number;
  name!: string;
  code!: string;
  imageUrl?: string | null;

  constructor(data?: IRegion) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.regionId =
        _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
    }
  }

  static fromJS(data: any): Region {
    data = typeof data === "object" ? data : {};
    let result = new Region();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["code"] = this.code !== undefined ? this.code : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    return data;
  }
}

export interface IRegion {
  regionId: number;
  name: string;
  code: string;
  imageUrl?: string | null;
}

export class PutMerchantRequest implements IPutMerchantRequest {
  merchantId!: number;
  merchantName!: string;
  parentBranchId?: number | null;
  saleManagerId?: number | null;
  email!: string;
  phoneNumber?: Phone | null;
  whatsappNumber?: Phone | null;
  isActive!: boolean;
  isActivePin!: boolean;
  activated2FaModifiedTime?: Date | null;
  walletId!: number;
  exchangeTargetCurrencyId!: number;
  rootBranch!: PutBranchRequest;
  createdTime!: Date;
  modifiedTime!: Date;

  constructor(data?: IPutMerchantRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.rootBranch = new PutBranchRequest();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.merchantName =
        _data["merchantName"] !== undefined ? _data["merchantName"] : <any>null;
      this.parentBranchId =
        _data["parentBranchId"] !== undefined
          ? _data["parentBranchId"]
          : <any>null;
      this.saleManagerId =
        _data["saleManagerId"] !== undefined
          ? _data["saleManagerId"]
          : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.phoneNumber = _data["phoneNumber"]
        ? Phone.fromJS(_data["phoneNumber"])
        : <any>null;
      this.whatsappNumber = _data["whatsappNumber"]
        ? Phone.fromJS(_data["whatsappNumber"])
        : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.isActivePin =
        _data["isActivePin"] !== undefined ? _data["isActivePin"] : <any>null;
      this.activated2FaModifiedTime = _data["activated2FaModifiedTime"]
        ? new Date(_data["activated2FaModifiedTime"].toString())
        : <any>null;
      this.walletId =
        _data["walletId"] !== undefined ? _data["walletId"] : <any>null;
      this.exchangeTargetCurrencyId =
        _data["exchangeTargetCurrencyId"] !== undefined
          ? _data["exchangeTargetCurrencyId"]
          : <any>null;
      this.rootBranch = _data["rootBranch"]
        ? PutBranchRequest.fromJS(_data["rootBranch"])
        : new PutBranchRequest();
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PutMerchantRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutMerchantRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["merchantName"] =
      this.merchantName !== undefined ? this.merchantName : <any>null;
    data["parentBranchId"] =
      this.parentBranchId !== undefined ? this.parentBranchId : <any>null;
    data["saleManagerId"] =
      this.saleManagerId !== undefined ? this.saleManagerId : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["phoneNumber"] = this.phoneNumber
      ? this.phoneNumber.toJSON()
      : <any>null;
    data["whatsappNumber"] = this.whatsappNumber
      ? this.whatsappNumber.toJSON()
      : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["isActivePin"] =
      this.isActivePin !== undefined ? this.isActivePin : <any>null;
    data["activated2FaModifiedTime"] = this.activated2FaModifiedTime
      ? this.activated2FaModifiedTime.toISOString()
      : <any>null;
    data["walletId"] = this.walletId !== undefined ? this.walletId : <any>null;
    data["exchangeTargetCurrencyId"] =
      this.exchangeTargetCurrencyId !== undefined
        ? this.exchangeTargetCurrencyId
        : <any>null;
    data["rootBranch"] = this.rootBranch ? this.rootBranch.toJSON() : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPutMerchantRequest {
  merchantId: number;
  merchantName: string;
  parentBranchId?: number | null;
  saleManagerId?: number | null;
  email: string;
  phoneNumber?: Phone | null;
  whatsappNumber?: Phone | null;
  isActive: boolean;
  isActivePin: boolean;
  activated2FaModifiedTime?: Date | null;
  walletId: number;
  exchangeTargetCurrencyId: number;
  rootBranch: PutBranchRequest;
  createdTime: Date;
  modifiedTime: Date;
}

export class Phone implements IPhone {
  countryCode!: string;
  number!: string;

  constructor(data?: IPhone) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.countryCode =
        _data["countryCode"] !== undefined ? _data["countryCode"] : <any>null;
      this.number = _data["number"] !== undefined ? _data["number"] : <any>null;
    }
  }

  static fromJS(data: any): Phone {
    data = typeof data === "object" ? data : {};
    let result = new Phone();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["countryCode"] =
      this.countryCode !== undefined ? this.countryCode : <any>null;
    data["number"] = this.number !== undefined ? this.number : <any>null;
    return data;
  }
}

export interface IPhone {
  countryCode: string;
  number: string;
}

export class PutBranchRequest implements IPutBranchRequest {
  branchId!: number;
  branchName!: string;
  merchantId!: number;
  rootPriceListId?: number | null;
  canPlaceOrder!: boolean;
  calculateProfitByStockTotalBuyPrice!: boolean;
  createdTime!: Date;
  modifiedTime!: Date;

  constructor(data?: IPutBranchRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.branchName =
        _data["branchName"] !== undefined ? _data["branchName"] : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.rootPriceListId =
        _data["rootPriceListId"] !== undefined
          ? _data["rootPriceListId"]
          : <any>null;
      this.canPlaceOrder =
        _data["canPlaceOrder"] !== undefined
          ? _data["canPlaceOrder"]
          : <any>null;
      this.calculateProfitByStockTotalBuyPrice =
        _data["calculateProfitByStockTotalBuyPrice"] !== undefined
          ? _data["calculateProfitByStockTotalBuyPrice"]
          : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PutBranchRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutBranchRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["branchName"] =
      this.branchName !== undefined ? this.branchName : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["rootPriceListId"] =
      this.rootPriceListId !== undefined ? this.rootPriceListId : <any>null;
    data["canPlaceOrder"] =
      this.canPlaceOrder !== undefined ? this.canPlaceOrder : <any>null;
    data["calculateProfitByStockTotalBuyPrice"] =
      this.calculateProfitByStockTotalBuyPrice !== undefined
        ? this.calculateProfitByStockTotalBuyPrice
        : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPutBranchRequest {
  branchId: number;
  branchName: string;
  merchantId: number;
  rootPriceListId?: number | null;
  canPlaceOrder: boolean;
  calculateProfitByStockTotalBuyPrice: boolean;
  createdTime: Date;
  modifiedTime: Date;
}

export class PutCurrencyRequest implements IPutCurrencyRequest {
  currencyId!: number;
  currencyName!: string;

  constructor(data?: IPutCurrencyRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.currencyName =
        _data["currencyName"] !== undefined ? _data["currencyName"] : <any>null;
    }
  }

  static fromJS(data: any): PutCurrencyRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutCurrencyRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["currencyName"] =
      this.currencyName !== undefined ? this.currencyName : <any>null;
    return data;
  }
}

export interface IPutCurrencyRequest {
  currencyId: number;
  currencyName: string;
}

export class PutCategoryRequest implements IPutCategoryRequest {
  categoryId!: number;
  categoryName!: string;
  imageUrl?: string | null;
  parentCategoryId?: number | null;
  createdTime!: Date;
  modifiedTime!: Date;

  constructor(data?: IPutCategoryRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryId =
        _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
      this.categoryName =
        _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.parentCategoryId =
        _data["parentCategoryId"] !== undefined
          ? _data["parentCategoryId"]
          : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PutCategoryRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutCategoryRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["categoryId"] =
      this.categoryId !== undefined ? this.categoryId : <any>null;
    data["categoryName"] =
      this.categoryName !== undefined ? this.categoryName : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["parentCategoryId"] =
      this.parentCategoryId !== undefined ? this.parentCategoryId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPutCategoryRequest {
  categoryId: number;
  categoryName: string;
  imageUrl?: string | null;
  parentCategoryId?: number | null;
  createdTime: Date;
  modifiedTime: Date;
}

export class PutProductRequest implements IPutProductRequest {
  productId!: number;
  productName!: string;
  categoryId!: number;
  isActive!: boolean;
  currencyId!: number;
  sku!: string;
  upc?: string | null;
  canPreOrder!: boolean;
  canImmediate!: boolean;
  isPhysical!: boolean;
  imageUrl?: string | null;
  description?: string | null;
  createdTime!: Date;
  modifiedTime!: Date;

  constructor(data?: IPutProductRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      this.productName =
        _data["productName"] !== undefined ? _data["productName"] : <any>null;
      this.categoryId =
        _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
      this.isActive =
        _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.sku = _data["sku"] !== undefined ? _data["sku"] : <any>null;
      this.upc = _data["upc"] !== undefined ? _data["upc"] : <any>null;
      this.canPreOrder =
        _data["canPreOrder"] !== undefined ? _data["canPreOrder"] : <any>null;
      this.canImmediate =
        _data["canImmediate"] !== undefined ? _data["canImmediate"] : <any>null;
      this.isPhysical =
        _data["isPhysical"] !== undefined ? _data["isPhysical"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PutProductRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutProductRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    data["productName"] =
      this.productName !== undefined ? this.productName : <any>null;
    data["categoryId"] =
      this.categoryId !== undefined ? this.categoryId : <any>null;
    data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["sku"] = this.sku !== undefined ? this.sku : <any>null;
    data["upc"] = this.upc !== undefined ? this.upc : <any>null;
    data["canPreOrder"] =
      this.canPreOrder !== undefined ? this.canPreOrder : <any>null;
    data["canImmediate"] =
      this.canImmediate !== undefined ? this.canImmediate : <any>null;
    data["isPhysical"] =
      this.isPhysical !== undefined ? this.isPhysical : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPutProductRequest {
  productId: number;
  productName: string;
  categoryId: number;
  isActive: boolean;
  currencyId: number;
  sku: string;
  upc?: string | null;
  canPreOrder: boolean;
  canImmediate: boolean;
  isPhysical: boolean;
  imageUrl?: string | null;
  description?: string | null;
  createdTime: Date;
  modifiedTime: Date;
}

export class PutRegionRequest implements IPutRegionRequest {
  regionId!: number;
  name!: string;
  code!: string;
  imageUrl?: string | null;
  createdTime!: Date;
  modifiedTime!: Date;

  constructor(data?: IPutRegionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.regionId =
        _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
      this.imageUrl =
        _data["imageUrl"] !== undefined ? _data["imageUrl"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PutRegionRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutRegionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["code"] = this.code !== undefined ? this.code : <any>null;
    data["imageUrl"] = this.imageUrl !== undefined ? this.imageUrl : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPutRegionRequest {
  regionId: number;
  name: string;
  code: string;
  imageUrl?: string | null;
  createdTime: Date;
  modifiedTime: Date;
}

export class PutProductRegionRequest implements IPutProductRegionRequest {
  productId!: number;
  regionIds!: number[];

  constructor(data?: IPutProductRegionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.regionIds = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId =
        _data["productId"] !== undefined ? _data["productId"] : <any>null;
      if (Array.isArray(_data["regionIds"])) {
        this.regionIds = [] as any;
        for (let item of _data["regionIds"]) this.regionIds!.push(item);
      } else {
        this.regionIds = <any>null;
      }
    }
  }

  static fromJS(data: any): PutProductRegionRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutProductRegionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] =
      this.productId !== undefined ? this.productId : <any>null;
    if (Array.isArray(this.regionIds)) {
      data["regionIds"] = [];
      for (let item of this.regionIds) data["regionIds"].push(item);
    }
    return data;
  }
}

export interface IPutProductRegionRequest {
  productId: number;
  regionIds: number[];
}

export class PutCurrencyExchangeRateRequest
  implements IPutCurrencyExchangeRateRequest
{
  baseCurrencyId!: number;
  targetCurrencyId!: number;
  exchangeRate!: number;
  exchangeRateFee!: number;
  createdTime!: Date;
  modifiedTime!: Date;

  constructor(data?: IPutCurrencyExchangeRateRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.baseCurrencyId =
        _data["baseCurrencyId"] !== undefined
          ? _data["baseCurrencyId"]
          : <any>null;
      this.targetCurrencyId =
        _data["targetCurrencyId"] !== undefined
          ? _data["targetCurrencyId"]
          : <any>null;
      this.exchangeRate =
        _data["exchangeRate"] !== undefined ? _data["exchangeRate"] : <any>null;
      this.exchangeRateFee =
        _data["exchangeRateFee"] !== undefined
          ? _data["exchangeRateFee"]
          : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PutCurrencyExchangeRateRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutCurrencyExchangeRateRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["baseCurrencyId"] =
      this.baseCurrencyId !== undefined ? this.baseCurrencyId : <any>null;
    data["targetCurrencyId"] =
      this.targetCurrencyId !== undefined ? this.targetCurrencyId : <any>null;
    data["exchangeRate"] =
      this.exchangeRate !== undefined ? this.exchangeRate : <any>null;
    data["exchangeRateFee"] =
      this.exchangeRateFee !== undefined ? this.exchangeRateFee : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPutCurrencyExchangeRateRequest {
  baseCurrencyId: number;
  targetCurrencyId: number;
  exchangeRate: number;
  exchangeRateFee: number;
  createdTime: Date;
  modifiedTime: Date;
}

export class PutUserPinRequest implements IPutUserPinRequest {
  userPinId!: number;
  branchId!: number;
  userId!: string;
  pin!: string;
  createdTime!: Date;
  modifiedTime!: Date;

  constructor(data?: IPutUserPinRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userPinId =
        _data["userPinId"] !== undefined ? _data["userPinId"] : <any>null;
      this.branchId =
        _data["branchId"] !== undefined ? _data["branchId"] : <any>null;
      this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
      this.pin = _data["pin"] !== undefined ? _data["pin"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PutUserPinRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutUserPinRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userPinId"] =
      this.userPinId !== undefined ? this.userPinId : <any>null;
    data["branchId"] = this.branchId !== undefined ? this.branchId : <any>null;
    data["userId"] = this.userId !== undefined ? this.userId : <any>null;
    data["pin"] = this.pin !== undefined ? this.pin : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPutUserPinRequest {
  userPinId: number;
  branchId: number;
  userId: string;
  pin: string;
  createdTime: Date;
  modifiedTime: Date;
}

export class PutMerchantCurrencyLimitRequest
  implements IPutMerchantCurrencyLimitRequest
{
  merchantCurrencyLimitId!: number;
  amount!: number;
  currencyId!: number;
  merchantId!: number;
  createdTime!: Date;
  modifiedTime!: Date;

  constructor(data?: IPutMerchantCurrencyLimitRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.merchantCurrencyLimitId =
        _data["merchantCurrencyLimitId"] !== undefined
          ? _data["merchantCurrencyLimitId"]
          : <any>null;
      this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
      this.currencyId =
        _data["currencyId"] !== undefined ? _data["currencyId"] : <any>null;
      this.merchantId =
        _data["merchantId"] !== undefined ? _data["merchantId"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.modifiedTime = _data["modifiedTime"]
        ? new Date(_data["modifiedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): PutMerchantCurrencyLimitRequest {
    data = typeof data === "object" ? data : {};
    let result = new PutMerchantCurrencyLimitRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["merchantCurrencyLimitId"] =
      this.merchantCurrencyLimitId !== undefined
        ? this.merchantCurrencyLimitId
        : <any>null;
    data["amount"] = this.amount !== undefined ? this.amount : <any>null;
    data["currencyId"] =
      this.currencyId !== undefined ? this.currencyId : <any>null;
    data["merchantId"] =
      this.merchantId !== undefined ? this.merchantId : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["modifiedTime"] = this.modifiedTime
      ? this.modifiedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IPutMerchantCurrencyLimitRequest {
  merchantCurrencyLimitId: number;
  amount: number;
  currencyId: number;
  merchantId: number;
  createdTime: Date;
  modifiedTime: Date;
}

export class ApiKey implements IApiKey {
  accessToken!: Token;
  refreshToken?: Token | null;
  userId!: string;

  constructor(data?: IApiKey) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.accessToken = new Token();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"]
        ? Token.fromJS(_data["accessToken"])
        : new Token();
      this.refreshToken = _data["refreshToken"]
        ? Token.fromJS(_data["refreshToken"])
        : <any>null;
      this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
    }
  }

  static fromJS(data: any): ApiKey {
    data = typeof data === "object" ? data : {};
    let result = new ApiKey();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken
      ? this.accessToken.toJSON()
      : <any>null;
    data["refreshToken"] = this.refreshToken
      ? this.refreshToken.toJSON()
      : <any>null;
    data["userId"] = this.userId !== undefined ? this.userId : <any>null;
    return data;
  }
}

export interface IApiKey {
  accessToken: Token;
  refreshToken?: Token | null;
  userId: string;
}

export class Token implements IToken {
  value!: string;
  expirationTime!: Date;
  scheme!: string;
  issuedTime!: Date;

  constructor(data?: IToken) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
      this.expirationTime = _data["expirationTime"]
        ? new Date(_data["expirationTime"].toString())
        : <any>null;
      this.scheme = _data["scheme"] !== undefined ? _data["scheme"] : <any>null;
      this.issuedTime = _data["issuedTime"]
        ? new Date(_data["issuedTime"].toString())
        : <any>null;
    }
  }

  static fromJS(data: any): Token {
    data = typeof data === "object" ? data : {};
    let result = new Token();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value !== undefined ? this.value : <any>null;
    data["expirationTime"] = this.expirationTime
      ? this.expirationTime.toISOString()
      : <any>null;
    data["scheme"] = this.scheme !== undefined ? this.scheme : <any>null;
    data["issuedTime"] = this.issuedTime
      ? this.issuedTime.toISOString()
      : <any>null;
    return data;
  }
}

export interface IToken {
  value: string;
  expirationTime: Date;
  scheme: string;
  issuedTime: Date;
}

export class User implements IUser {
  userId!: string;
  email?: string | null;
  name?: string | null;
  firstName?: string | null;
  lastName?: string | null;
  pictureUrl?: string | null;
  phone?: string | null;
  createdTime!: Date;
  accessedTime?: Date | null;
  authorizationCode?: string | null;
  isDisabled!: boolean;
  isEmailVerified!: boolean;
  isPhoneVerified!: boolean;
  isBot!: boolean;
  description?: string | null;
  exData?: string | null;

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
      this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
      this.firstName =
        _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
      this.lastName =
        _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
      this.pictureUrl =
        _data["pictureUrl"] !== undefined ? _data["pictureUrl"] : <any>null;
      this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
      this.createdTime = _data["createdTime"]
        ? new Date(_data["createdTime"].toString())
        : <any>null;
      this.accessedTime = _data["accessedTime"]
        ? new Date(_data["accessedTime"].toString())
        : <any>null;
      this.authorizationCode =
        _data["authorizationCode"] !== undefined
          ? _data["authorizationCode"]
          : <any>null;
      this.isDisabled =
        _data["isDisabled"] !== undefined ? _data["isDisabled"] : <any>null;
      this.isEmailVerified =
        _data["isEmailVerified"] !== undefined
          ? _data["isEmailVerified"]
          : <any>null;
      this.isPhoneVerified =
        _data["isPhoneVerified"] !== undefined
          ? _data["isPhoneVerified"]
          : <any>null;
      this.isBot = _data["isBot"] !== undefined ? _data["isBot"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
      this.exData = _data["exData"] !== undefined ? _data["exData"] : <any>null;
    }
  }

  static fromJS(data: any): User {
    data = typeof data === "object" ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId !== undefined ? this.userId : <any>null;
    data["email"] = this.email !== undefined ? this.email : <any>null;
    data["name"] = this.name !== undefined ? this.name : <any>null;
    data["firstName"] =
      this.firstName !== undefined ? this.firstName : <any>null;
    data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
    data["pictureUrl"] =
      this.pictureUrl !== undefined ? this.pictureUrl : <any>null;
    data["phone"] = this.phone !== undefined ? this.phone : <any>null;
    data["createdTime"] = this.createdTime
      ? this.createdTime.toISOString()
      : <any>null;
    data["accessedTime"] = this.accessedTime
      ? this.accessedTime.toISOString()
      : <any>null;
    data["authorizationCode"] =
      this.authorizationCode !== undefined ? this.authorizationCode : <any>null;
    data["isDisabled"] =
      this.isDisabled !== undefined ? this.isDisabled : <any>null;
    data["isEmailVerified"] =
      this.isEmailVerified !== undefined ? this.isEmailVerified : <any>null;
    data["isPhoneVerified"] =
      this.isPhoneVerified !== undefined ? this.isPhoneVerified : <any>null;
    data["isBot"] = this.isBot !== undefined ? this.isBot : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    data["exData"] = this.exData !== undefined ? this.exData : <any>null;
    return data;
  }
}

export interface IUser {
  userId: string;
  email?: string | null;
  name?: string | null;
  firstName?: string | null;
  lastName?: string | null;
  pictureUrl?: string | null;
  phone?: string | null;
  createdTime: Date;
  accessedTime?: Date | null;
  authorizationCode?: string | null;
  isDisabled: boolean;
  isEmailVerified: boolean;
  isPhoneVerified: boolean;
  isBot: boolean;
  description?: string | null;
  exData?: string | null;
}

export class TeamUpdateBotParam implements ITeamUpdateBotParam {
  name?: PatchOfString | null;

  constructor(data?: ITeamUpdateBotParam) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"]
        ? PatchOfString.fromJS(_data["name"])
        : <any>null;
    }
  }

  static fromJS(data: any): TeamUpdateBotParam {
    data = typeof data === "object" ? data : {};
    let result = new TeamUpdateBotParam();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name ? this.name.toJSON() : <any>null;
    return data;
  }
}

export interface ITeamUpdateBotParam {
  name?: PatchOfString | null;
}

export class PatchOfString implements IPatchOfString {
  value?: string | null;

  constructor(data?: IPatchOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
    }
  }

  static fromJS(data: any): PatchOfString {
    data = typeof data === "object" ? data : {};
    let result = new PatchOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["value"] = this.value !== undefined ? this.value : <any>null;
    return data;
  }
}

export interface IPatchOfString {
  value?: string | null;
}

export class Role implements IRole {
  roleId!: string;
  roleName!: string;
  description?: string | null;

  constructor(data?: IRole) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
      this.roleName =
        _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
      this.description =
        _data["description"] !== undefined ? _data["description"] : <any>null;
    }
  }

  static fromJS(data: any): Role {
    data = typeof data === "object" ? data : {};
    let result = new Role();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
    data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
    data["description"] =
      this.description !== undefined ? this.description : <any>null;
    return data;
  }
}

export interface IRole {
  roleId: string;
  roleName: string;
  description?: string | null;
}

export class ListResultOfUserRole implements IListResultOfUserRole {
  totalCount?: number | null;
  items!: UserRole[];

  constructor(data?: IListResultOfUserRole) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.items = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount =
        _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(UserRole.fromJS(item));
      } else {
        this.items = <any>null;
      }
    }
  }

  static fromJS(data: any): ListResultOfUserRole {
    data = typeof data === "object" ? data : {};
    let result = new ListResultOfUserRole();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalCount"] =
      this.totalCount !== undefined ? this.totalCount : <any>null;
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }
}

export interface IListResultOfUserRole {
  totalCount?: number | null;
  items: UserRole[];
}

export class UserRole2 implements IUserRole2 {
  resourceId!: string;
  userId!: string;
  role!: Role;

  constructor(data?: IUserRole2) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.role = new Role();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.resourceId =
        _data["resourceId"] !== undefined ? _data["resourceId"] : <any>null;
      this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
      this.role = _data["role"] ? Role.fromJS(_data["role"]) : new Role();
    }
  }

  static fromJS(data: any): UserRole2 {
    data = typeof data === "object" ? data : {};
    let result = new UserRole2();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["resourceId"] =
      this.resourceId !== undefined ? this.resourceId : <any>null;
    data["userId"] = this.userId !== undefined ? this.userId : <any>null;
    data["role"] = this.role ? this.role.toJSON() : <any>null;
    return data;
  }
}

export interface IUserRole2 {
  resourceId: string;
  userId: string;
  role: Role;
}

export class UserRole extends UserRole2 implements IUserRole {
  user?: User | null;

  constructor(data?: IUserRole) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>null;
    }
  }

  static override fromJS(data: any): UserRole {
    data = typeof data === "object" ? data : {};
    let result = new UserRole();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["user"] = this.user ? this.user.toJSON() : <any>null;
    super.toJSON(data);
    return data;
  }
}

export interface IUserRole extends IUserRole2 {
  user?: User | null;
}

export class TeamUserOfUserAndUserRoleAndRole
  implements ITeamUserOfUserAndUserRoleAndRole
{
  user!: User;
  roles!: Role[];

  constructor(data?: ITeamUserOfUserAndUserRoleAndRole) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.user = new User();
      this.roles = [];
    }
  }

  init(_data?: any) {
    if (_data) {
      this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
      if (Array.isArray(_data["roles"])) {
        this.roles = [] as any;
        for (let item of _data["roles"]) this.roles!.push(Role.fromJS(item));
      } else {
        this.roles = <any>null;
      }
    }
  }

  static fromJS(data: any): TeamUserOfUserAndUserRoleAndRole {
    data = typeof data === "object" ? data : {};
    let result = new TeamUserOfUserAndUserRoleAndRole();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["user"] = this.user ? this.user.toJSON() : <any>null;
    if (Array.isArray(this.roles)) {
      data["roles"] = [];
      for (let item of this.roles) data["roles"].push(item.toJSON());
    }
    return data;
  }
}

export interface ITeamUserOfUserAndUserRoleAndRole {
  user: User;
  roles: Role[];
}

export class TeamAddBotParam implements ITeamAddBotParam {
  name!: string;

  constructor(data?: ITeamAddBotParam) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
    }
  }

  static fromJS(data: any): TeamAddBotParam {
    data = typeof data === "object" ? data : {};
    let result = new TeamAddBotParam();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name !== undefined ? this.name : <any>null;
    return data;
  }
}

export interface ITeamAddBotParam {
  name: string;
}

export class TeamAddEmailParam implements ITeamAddEmailParam {
  constructor(data?: ITeamAddEmailParam) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): TeamAddEmailParam {
    data = typeof data === "object" ? data : {};
    let result = new TeamAddEmailParam();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface ITeamAddEmailParam {}

export class SignInRequest implements ISignInRequest {
  idToken!: string;
  refreshTokenType!: RefreshTokenType;

  constructor(data?: ISignInRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.idToken =
        _data["idToken"] !== undefined ? _data["idToken"] : <any>null;
      this.refreshTokenType =
        _data["refreshTokenType"] !== undefined
          ? _data["refreshTokenType"]
          : <any>null;
    }
  }

  static fromJS(data: any): SignInRequest {
    data = typeof data === "object" ? data : {};
    let result = new SignInRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idToken"] = this.idToken !== undefined ? this.idToken : <any>null;
    data["refreshTokenType"] =
      this.refreshTokenType !== undefined ? this.refreshTokenType : <any>null;
    return data;
  }
}

export interface ISignInRequest {
  idToken: string;
  refreshTokenType: RefreshTokenType;
}

export enum RefreshTokenType {
  None = "None",
  Web = "Web",
  App = "App",
}

export class SignUpRequest implements ISignUpRequest {
  idToken!: string;
  refreshTokenType!: RefreshTokenType;

  constructor(data?: ISignUpRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.idToken =
        _data["idToken"] !== undefined ? _data["idToken"] : <any>null;
      this.refreshTokenType =
        _data["refreshTokenType"] !== undefined
          ? _data["refreshTokenType"]
          : <any>null;
    }
  }

  static fromJS(data: any): SignUpRequest {
    data = typeof data === "object" ? data : {};
    let result = new SignUpRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["idToken"] = this.idToken !== undefined ? this.idToken : <any>null;
    data["refreshTokenType"] =
      this.refreshTokenType !== undefined ? this.refreshTokenType : <any>null;
    return data;
  }
}

export interface ISignUpRequest {
  idToken: string;
  refreshTokenType: RefreshTokenType;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
  refreshToken!: string;

  constructor(data?: IRefreshTokenRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken =
        _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
    }
  }

  static fromJS(data: any): RefreshTokenRequest {
    data = typeof data === "object" ? data : {};
    let result = new RefreshTokenRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["refreshToken"] =
      this.refreshToken !== undefined ? this.refreshToken : <any>null;
    return data;
  }
}

export interface IRefreshTokenRequest {
  refreshToken: string;
}

function formatDate(d: Date) {
  return (
    d.getFullYear() +
    "-" +
    (d.getMonth() < 9 ? "0" + (d.getMonth() + 1) : d.getMonth() + 1) +
    "-" +
    (d.getDate() < 10 ? "0" + d.getDate() : d.getDate())
  );
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
